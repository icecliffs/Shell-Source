<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Contributed Scripts</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><LINK
REL="HOME"
TITLE="Advanced Bash-Scripting Guide"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Bibliography"
HREF="biblio.html"><LINK
REL="NEXT"
TITLE="Reference Cards"
HREF="refcards.html"><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"><LINK
REL="stylesheet"
HREF="common/kde-common.css"
TYPE="text/css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=iso-8859-1"><META
HTTP-EQUIV="Content-Language"
CONTENT="en"><LINK
REL="stylesheet"
HREF="common/kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"><LINK
REL="stylesheet"
HREF="common/kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"></HEAD
><BODY
CLASS="APPENDIX"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#AA0000"
VLINK="#AA0055"
ALINK="#AA0000"
STYLE="font-family: sans-serif;"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Advanced Bash-Scripting Guide: An in-depth exploration of the art of shell scripting</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="biblio.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="refcards.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="APPENDIX"
><H1
><A
NAME="CONTRIBUTED-SCRIPTS"
></A
>Appendix A. Contributed Scripts</H1
><P
>These scripts, while not fitting into the text of this document, do
    illustrate some interesting shell programming techniques. They are useful,
    too. Have fun analyzing and running them.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="MAILFORMAT"
></A
><P
><B
>Example A-1. <I
CLASS="FIRSTTERM"
>mailformat</I
>: Formatting an e-mail
      message</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# mail-format.sh (ver. 1.1): Format e-mail messages.
   3&nbsp;
   4&nbsp;# Gets rid of carets, tabs, and also folds excessively long lines.
   5&nbsp;
   6&nbsp;# =================================================================
   7&nbsp;#                 Standard Check for Script Argument(s)
   8&nbsp;ARGS=1
   9&nbsp;E_BADARGS=65
  10&nbsp;E_NOFILE=66
  11&nbsp;
  12&nbsp;if [ $# -ne $ARGS ]  # Correct number of arguments passed to script?
  13&nbsp;then
  14&nbsp;  echo "Usage: `basename $0` filename"
  15&nbsp;  exit $E_BADARGS
  16&nbsp;fi
  17&nbsp;
  18&nbsp;if [ -f "$1" ]       # Check if file exists.
  19&nbsp;then
  20&nbsp;    file_name=$1
  21&nbsp;else
  22&nbsp;    echo "File \"$1\" does not exist."
  23&nbsp;    exit $E_NOFILE
  24&nbsp;fi
  25&nbsp;# =================================================================
  26&nbsp;
  27&nbsp;MAXWIDTH=70          # Width to fold excessively long lines to.
  28&nbsp;
  29&nbsp;# ---------------------------------
  30&nbsp;# A variable can hold a sed script.
  31&nbsp;sedscript='s/^&#62;//
  32&nbsp;s/^  *&#62;//
  33&nbsp;s/^  *//
  34&nbsp;s/		*//'
  35&nbsp;# ---------------------------------
  36&nbsp;
  37&nbsp;#  Delete carets and tabs at beginning of lines,
  38&nbsp;#+ then fold lines to $MAXWIDTH characters.
  39&nbsp;sed "$sedscript" $1 | fold -s --width=$MAXWIDTH
  40&nbsp;                        #  -s option to "fold"
  41&nbsp;                        #+ breaks lines at whitespace, if possible.
  42&nbsp;
  43&nbsp;
  44&nbsp;#  This script was inspired by an article in a well-known trade journal
  45&nbsp;#+ extolling a 164K MS Windows utility with similar functionality.
  46&nbsp;#
  47&nbsp;#  An nice set of text processing utilities and an efficient
  48&nbsp;#+ scripting language provide an alternative to bloated executables.
  49&nbsp;
  50&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="RN"
></A
><P
><B
>Example A-2. <I
CLASS="FIRSTTERM"
>rn</I
>: A simple-minded file renaming
      utility</B
></P
><P
>This script is a modification of <A
HREF="textproc.html#LOWERCASE"
>Example 15-21</A
>.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#! /bin/bash
   2&nbsp;#
   3&nbsp;# Very simpleminded filename "rename" utility (based on "lowercase.sh").
   4&nbsp;#
   5&nbsp;#  The "ren" utility, by Vladimir Lanin (lanin@csd2.nyu.edu),
   6&nbsp;#+ does a much better job of this.
   7&nbsp;
   8&nbsp;
   9&nbsp;ARGS=2
  10&nbsp;E_BADARGS=65
  11&nbsp;ONE=1                     # For getting singular/plural right (see below).
  12&nbsp;
  13&nbsp;if [ $# -ne "$ARGS" ]
  14&nbsp;then
  15&nbsp;  echo "Usage: `basename $0` old-pattern new-pattern"
  16&nbsp;  # As in "rn gif jpg", which renames all gif files in working directory to jpg.
  17&nbsp;  exit $E_BADARGS
  18&nbsp;fi
  19&nbsp;
  20&nbsp;number=0                  # Keeps track of how many files actually renamed.
  21&nbsp;
  22&nbsp;
  23&nbsp;for filename in *$1*      #Traverse all matching files in directory.
  24&nbsp;do
  25&nbsp;   if [ -f "$filename" ]  # If finds match...
  26&nbsp;   then
  27&nbsp;     fname=`basename $filename`            # Strip off path.
  28&nbsp;     n=`echo $fname | sed -e "s/$1/$2/"`   # Substitute new for old in filename.
  29&nbsp;     mv $fname $n                          # Rename.
  30&nbsp;     let "number += 1"
  31&nbsp;   fi
  32&nbsp;done   
  33&nbsp;
  34&nbsp;if [ "$number" -eq "$ONE" ]                # For correct grammar.
  35&nbsp;then
  36&nbsp; echo "$number file renamed."
  37&nbsp;else 
  38&nbsp; echo "$number files renamed."
  39&nbsp;fi 
  40&nbsp;
  41&nbsp;exit 0
  42&nbsp;
  43&nbsp;
  44&nbsp;# Exercises:
  45&nbsp;# ---------
  46&nbsp;# What type of files will this not work on?
  47&nbsp;# How can this be fixed?
  48&nbsp;#
  49&nbsp;#  Rewrite this script to process all the files in a directory
  50&nbsp;#+ containing spaces in their names, and to rename them,
  51&nbsp;#+ substituting an underscore for each space.</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="BLANKRENAME"
></A
><P
><B
>Example A-3. <I
CLASS="FIRSTTERM"
>blank-rename</I
>: Renames filenames containing
        blanks</B
></P
><P
>This is an even simpler-minded version of previous script.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#! /bin/bash
   2&nbsp;# blank-rename.sh
   3&nbsp;#
   4&nbsp;# Substitutes underscores for blanks in all the filenames in a directory.
   5&nbsp;
   6&nbsp;ONE=1                     # For getting singular/plural right (see below).
   7&nbsp;number=0                  # Keeps track of how many files actually renamed.
   8&nbsp;FOUND=0                   # Successful return value.
   9&nbsp;
  10&nbsp;for filename in *         #Traverse all files in directory.
  11&nbsp;do
  12&nbsp;     echo "$filename" | grep -q " "         #  Check whether filename
  13&nbsp;     if [ $? -eq $FOUND ]                   #+ contains space(s).
  14&nbsp;     then
  15&nbsp;       fname=$filename                      # Yes, this filename needs work.
  16&nbsp;       n=`echo $fname | sed -e "s/ /_/g"`   # Substitute underscore for blank.
  17&nbsp;       mv "$fname" "$n"                     # Do the actual renaming.
  18&nbsp;       let "number += 1"
  19&nbsp;     fi
  20&nbsp;done   
  21&nbsp;
  22&nbsp;if [ "$number" -eq "$ONE" ]                 # For correct grammar.
  23&nbsp;then
  24&nbsp; echo "$number file renamed."
  25&nbsp;else 
  26&nbsp; echo "$number files renamed."
  27&nbsp;fi 
  28&nbsp;
  29&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="ENCRYPTEDPW"
></A
><P
><B
>Example A-4. <I
CLASS="FIRSTTERM"
>encryptedpw</I
>: Uploading to an ftp site,
      using a locally encrypted password</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;# Example "ex72.sh" modified to use encrypted password.
   4&nbsp;
   5&nbsp;#  Note that this is still rather insecure,
   6&nbsp;#+ since the decrypted password is sent in the clear.
   7&nbsp;#  Use something like "ssh" if this is a concern.
   8&nbsp;
   9&nbsp;E_BADARGS=65
  10&nbsp;
  11&nbsp;if [ -z "$1" ]
  12&nbsp;then
  13&nbsp;  echo "Usage: `basename $0` filename"
  14&nbsp;  exit $E_BADARGS
  15&nbsp;fi  
  16&nbsp;
  17&nbsp;Username=bozo           # Change to suit.
  18&nbsp;pword=/home/bozo/secret/password_encrypted.file
  19&nbsp;# File containing encrypted password.
  20&nbsp;
  21&nbsp;Filename=`basename $1`  # Strips pathname out of file name.
  22&nbsp;
  23&nbsp;Server="XXX"
  24&nbsp;Directory="YYY"         # Change above to actual server name &#38; directory.
  25&nbsp;
  26&nbsp;
  27&nbsp;Password=`cruft &#60;$pword`          # Decrypt password.
  28&nbsp;#  Uses the author's own "cruft" file encryption package,
  29&nbsp;#+ based on the classic "onetime pad" algorithm,
  30&nbsp;#+ and obtainable from:
  31&nbsp;#+ Primary-site:   ftp://ibiblio.org/pub/Linux/utils/file
  32&nbsp;#+                 cruft-0.2.tar.gz [16k]
  33&nbsp;
  34&nbsp;
  35&nbsp;ftp -n $Server &#60;&#60;End-Of-Session
  36&nbsp;user $Username $Password
  37&nbsp;binary
  38&nbsp;bell
  39&nbsp;cd $Directory
  40&nbsp;put $Filename
  41&nbsp;bye
  42&nbsp;End-Of-Session
  43&nbsp;# -n option to "ftp" disables auto-logon.
  44&nbsp;# Note that "bell" rings 'bell' after each file transfer.
  45&nbsp;
  46&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="COPYCD"
></A
><P
><B
>Example A-5. <I
CLASS="FIRSTTERM"
>copy-cd</I
>: Copying a data CD</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# copy-cd.sh: copying a data CD
   3&nbsp;
   4&nbsp;CDROM=/dev/cdrom                           # CD ROM device
   5&nbsp;OF=/home/bozo/projects/cdimage.iso         # output file
   6&nbsp;#       /xxxx/xxxxxxx/                     Change to suit your system.
   7&nbsp;BLOCKSIZE=2048
   8&nbsp;SPEED=2                                    # May use higher speed if supported.
   9&nbsp;DEVICE=cdrom
  10&nbsp;# DEVICE="0,0"    on older versions of cdrecord.
  11&nbsp;
  12&nbsp;echo; echo "Insert source CD, but do *not* mount it."
  13&nbsp;echo "Press ENTER when ready. "
  14&nbsp;read ready                                 # Wait for input, $ready not used.
  15&nbsp;
  16&nbsp;echo; echo "Copying the source CD to $OF."
  17&nbsp;echo "This may take a while. Please be patient."
  18&nbsp;
  19&nbsp;dd if=$CDROM of=$OF bs=$BLOCKSIZE          # Raw device copy.
  20&nbsp;
  21&nbsp;
  22&nbsp;echo; echo "Remove data CD."
  23&nbsp;echo "Insert blank CDR."
  24&nbsp;echo "Press ENTER when ready. "
  25&nbsp;read ready                                 # Wait for input, $ready not used.
  26&nbsp;
  27&nbsp;echo "Copying $OF to CDR."
  28&nbsp;
  29&nbsp;cdrecord -v -isosize speed=$SPEED dev=$DEVICE $OF
  30&nbsp;# Uses Joerg Schilling's "cdrecord" package (see its docs).
  31&nbsp;# http://www.fokus.gmd.de/nthp/employees/schilling/cdrecord.html
  32&nbsp;
  33&nbsp;
  34&nbsp;echo; echo "Done copying $OF to CDR on device $CDROM."
  35&nbsp;
  36&nbsp;echo "Do you want to erase the image file (y/n)? "  # Probably a huge file.
  37&nbsp;read answer
  38&nbsp;
  39&nbsp;case "$answer" in
  40&nbsp;[yY]) rm -f $OF
  41&nbsp;      echo "$OF erased."
  42&nbsp;      ;;
  43&nbsp;*)    echo "$OF not erased.";;
  44&nbsp;esac
  45&nbsp;
  46&nbsp;echo
  47&nbsp;
  48&nbsp;# Exercise:
  49&nbsp;# Change the above "case" statement to also accept "yes" and "Yes" as input.
  50&nbsp;
  51&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="COLLATZ"
></A
><P
><B
>Example A-6. Collatz series</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# collatz.sh
   3&nbsp;
   4&nbsp;#  The notorious "hailstone" or Collatz series.
   5&nbsp;#  -------------------------------------------
   6&nbsp;#  1) Get the integer "seed" from the command line.
   7&nbsp;#  2) NUMBER &#60;--- seed
   8&nbsp;#  3) Print NUMBER.
   9&nbsp;#  4)  If NUMBER is even, divide by 2, or
  10&nbsp;#  5)+ if odd, multiply by 3 and add 1.
  11&nbsp;#  6) NUMBER &#60;--- result 
  12&nbsp;#  7) Loop back to step 3 (for specified number of iterations).
  13&nbsp;#
  14&nbsp;#  The theory is that every sequence,
  15&nbsp;#+ no matter how large the initial value,
  16&nbsp;#+ eventually settles down to repeating "4,2,1..." cycles,
  17&nbsp;#+ even after fluctuating through a wide range of values.
  18&nbsp;#
  19&nbsp;#  This is an instance of an "iterate,"
  20&nbsp;#+ an operation that feeds its output back into the input.
  21&nbsp;#  Sometimes the result is a "chaotic" series.
  22&nbsp;
  23&nbsp;
  24&nbsp;MAX_ITERATIONS=200
  25&nbsp;# For large seed numbers (&#62;32000), increase MAX_ITERATIONS.
  26&nbsp;
  27&nbsp;h=${1:-$$}                      #  Seed
  28&nbsp;                                #  Use $PID as seed,
  29&nbsp;                                #+ if not specified as command-line arg.
  30&nbsp;
  31&nbsp;echo
  32&nbsp;echo "C($h) --- $MAX_ITERATIONS Iterations"
  33&nbsp;echo
  34&nbsp;
  35&nbsp;for ((i=1; i&#60;=MAX_ITERATIONS; i++))
  36&nbsp;do
  37&nbsp;
  38&nbsp;echo -n "$h	"
  39&nbsp;#          ^^^^^
  40&nbsp;#           tab
  41&nbsp;
  42&nbsp;  let "remainder = h % 2"
  43&nbsp;  if [ "$remainder" -eq 0 ]   # Even?
  44&nbsp;  then
  45&nbsp;    let "h /= 2"              # Divide by 2.
  46&nbsp;  else
  47&nbsp;    let "h = h*3 + 1"         # Multiply by 3 and add 1.
  48&nbsp;  fi
  49&nbsp;
  50&nbsp;
  51&nbsp;COLUMNS=10                    # Output 10 values per line.
  52&nbsp;let "line_break = i % $COLUMNS"
  53&nbsp;if [ "$line_break" -eq 0 ]
  54&nbsp;then
  55&nbsp;  echo
  56&nbsp;fi  
  57&nbsp;
  58&nbsp;done
  59&nbsp;
  60&nbsp;echo
  61&nbsp;
  62&nbsp;#  For more information on this mathematical function,
  63&nbsp;#+ see _Computers, Pattern, Chaos, and Beauty_, by Pickover, p. 185 ff.,
  64&nbsp;#+ as listed in the bibliography.
  65&nbsp;
  66&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
><A
NAME="DAYSBETWEEN0"
></A
></P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="DAYSBETWEEN"
></A
><P
><B
>Example A-7. <I
CLASS="FIRSTTERM"
>days-between</I
>: Days between two
        dates</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# days-between.sh:    Number of days between two dates.
   3&nbsp;# Usage: ./days-between.sh [M]M/[D]D/YYYY [M]M/[D]D/YYYY
   4&nbsp;#
   5&nbsp;# Note: Script modified to account for changes in Bash, v. 2.05b +,
   6&nbsp;#+      that closed the loophole permitting large negative
   7&nbsp;#+      integer return values.
   8&nbsp;
   9&nbsp;ARGS=2                # Two command line parameters expected.
  10&nbsp;E_PARAM_ERR=65        # Param error.
  11&nbsp;
  12&nbsp;REFYR=1600            # Reference year.
  13&nbsp;CENTURY=100
  14&nbsp;DIY=365
  15&nbsp;ADJ_DIY=367           # Adjusted for leap year + fraction.
  16&nbsp;MIY=12
  17&nbsp;DIM=31
  18&nbsp;LEAPCYCLE=4
  19&nbsp;
  20&nbsp;MAXRETVAL=255         #  Largest permissible
  21&nbsp;                      #+ positive return value from a function.
  22&nbsp;
  23&nbsp;diff=                 # Declare global variable for date difference.
  24&nbsp;value=                # Declare global variable for absolute value.
  25&nbsp;day=                  # Declare globals for day, month, year.
  26&nbsp;month=
  27&nbsp;year=
  28&nbsp;
  29&nbsp;
  30&nbsp;Param_Error ()        # Command line parameters wrong.
  31&nbsp;{
  32&nbsp;  echo "Usage: `basename $0` [M]M/[D]D/YYYY [M]M/[D]D/YYYY"
  33&nbsp;  echo "       (date must be after 1/3/1600)"
  34&nbsp;  exit $E_PARAM_ERR
  35&nbsp;}  
  36&nbsp;
  37&nbsp;
  38&nbsp;Parse_Date ()                 # Parse date from command line params.
  39&nbsp;{
  40&nbsp;  month=${1%%/**}
  41&nbsp;  dm=${1%/**}                 # Day and month.
  42&nbsp;  day=${dm#*/}
  43&nbsp;  let "year = `basename $1`"  # Not a filename, but works just the same.
  44&nbsp;}  
  45&nbsp;
  46&nbsp;
  47&nbsp;check_date ()                 # Checks for invalid date(s) passed.
  48&nbsp;{
  49&nbsp;  [ "$day" -gt "$DIM" ] || [ "$month" -gt "$MIY" ] ||
  50&nbsp;  [ "$year" -lt "$REFYR" ] &#38;&#38; Param_Error
  51&nbsp;  # Exit script on bad value(s).
  52&nbsp;  # Uses or-list / and-list.
  53&nbsp;  #
  54&nbsp;  # Exercise: Implement more rigorous date checking.
  55&nbsp;}
  56&nbsp;
  57&nbsp;
  58&nbsp;strip_leading_zero () #  Better to strip possible leading zero(s)
  59&nbsp;{                     #+ from day and/or month
  60&nbsp;  return ${1#0}       #+ since otherwise Bash will interpret them
  61&nbsp;}                     #+ as octal values (POSIX.2, sect 2.9.2.1).
  62&nbsp;
  63&nbsp;
  64&nbsp;day_index ()          # Gauss' Formula:
  65&nbsp;{                     # Days from March 1, 1600 to date passed as param.
  66&nbsp;                      #           ^^^^^^^^^^^^^
  67&nbsp;  day=$1
  68&nbsp;  month=$2
  69&nbsp;  year=$3
  70&nbsp;
  71&nbsp;  let "month = $month - 2"
  72&nbsp;  if [ "$month" -le 0 ]
  73&nbsp;  then
  74&nbsp;    let "month += 12"
  75&nbsp;    let "year -= 1"
  76&nbsp;  fi  
  77&nbsp;
  78&nbsp;  let "year -= $REFYR"
  79&nbsp;  let "indexyr = $year / $CENTURY"
  80&nbsp;
  81&nbsp;
  82&nbsp;  let "Days = $DIY*$year + $year/$LEAPCYCLE - $indexyr \
  83&nbsp;              + $indexyr/$LEAPCYCLE + $ADJ_DIY*$month/$MIY + $day - $DIM"
  84&nbsp;  #  For an in-depth explanation of this algorithm, see
  85&nbsp;  #+   http://weblogs.asp.net/pgreborio/archive/2005/01/06/347968.aspx
  86&nbsp;
  87&nbsp;
  88&nbsp;  echo $Days
  89&nbsp;
  90&nbsp;}  
  91&nbsp;
  92&nbsp;
  93&nbsp;calculate_difference ()            # Difference between two day indices.
  94&nbsp;{
  95&nbsp;  let "diff = $1 - $2"             # Global variable.
  96&nbsp;}  
  97&nbsp;
  98&nbsp;
  99&nbsp;abs ()                             #  Absolute value
 100&nbsp;{                                  #  Uses global "value" variable.
 101&nbsp;  if [ "$1" -lt 0 ]                #  If negative
 102&nbsp;  then                             #+ then
 103&nbsp;    let "value = 0 - $1"           #+ change sign,
 104&nbsp;  else                             #+ else
 105&nbsp;    let "value = $1"               #+ leave it alone.
 106&nbsp;  fi
 107&nbsp;}
 108&nbsp;
 109&nbsp;
 110&nbsp;
 111&nbsp;if [ $# -ne "$ARGS" ]              # Require two command line params.
 112&nbsp;then
 113&nbsp;  Param_Error
 114&nbsp;fi  
 115&nbsp;
 116&nbsp;Parse_Date $1
 117&nbsp;check_date $day $month $year       #  See if valid date.
 118&nbsp;
 119&nbsp;strip_leading_zero $day            #  Remove any leading zeroes
 120&nbsp;day=$?                             #+ on day and/or month.
 121&nbsp;strip_leading_zero $month
 122&nbsp;month=$?
 123&nbsp;
 124&nbsp;let "date1 = `day_index $day $month $year`"
 125&nbsp;
 126&nbsp;
 127&nbsp;Parse_Date $2
 128&nbsp;check_date $day $month $year
 129&nbsp;
 130&nbsp;strip_leading_zero $day
 131&nbsp;day=$?
 132&nbsp;strip_leading_zero $month
 133&nbsp;month=$?
 134&nbsp;
 135&nbsp;date2=$(day_index $day $month $year) # Command substitution.
 136&nbsp;
 137&nbsp;
 138&nbsp;calculate_difference $date1 $date2
 139&nbsp;
 140&nbsp;abs $diff                            # Make sure it's positive.
 141&nbsp;diff=$value
 142&nbsp;
 143&nbsp;echo $diff
 144&nbsp;
 145&nbsp;exit 0
 146&nbsp;
 147&nbsp;#  Compare this script with
 148&nbsp;#+ the implementation of Gauss' Formula in a C program at:
 149&nbsp;#+    http://buschencrew.hypermart.net/software/datedif</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="MAKEDICT"
></A
><P
><B
>Example A-8. Making a <I
CLASS="FIRSTTERM"
>dictionary</I
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# makedict.sh  [make dictionary]
   3&nbsp;
   4&nbsp;# Modification of /usr/sbin/mkdict (/usr/sbin/cracklib-forman) script.
   5&nbsp;# Original script copyright 1993, by Alec Muffett.
   6&nbsp;#
   7&nbsp;#  This modified script included in this document in a manner
   8&nbsp;#+ consistent with the "LICENSE" document of the "Crack" package
   9&nbsp;#+ that the original script is a part of.
  10&nbsp;
  11&nbsp;#  This script processes text files to produce a sorted list
  12&nbsp;#+ of words found in the files.
  13&nbsp;#  This may be useful for compiling dictionaries
  14&nbsp;#+ and for other lexicographic purposes.
  15&nbsp;
  16&nbsp;
  17&nbsp;E_BADARGS=65
  18&nbsp;
  19&nbsp;if [ ! -r "$1" ]                    #  Need at least one
  20&nbsp;then                                #+ valid file argument.
  21&nbsp;  echo "Usage: $0 files-to-process"
  22&nbsp;  exit $E_BADARGS
  23&nbsp;fi  
  24&nbsp;
  25&nbsp;
  26&nbsp;# SORT="sort"                       #  No longer necessary to define options
  27&nbsp;                                    #+ to sort. Changed from original script.
  28&nbsp;
  29&nbsp;cat $* |                            # Contents of specified files to stdout.
  30&nbsp;        tr A-Z a-z |                # Convert to lowercase.
  31&nbsp;        tr ' ' '\012' |             # New: change spaces to newlines.
  32&nbsp;#       tr -cd '\012[a-z][0-9]' |   #  Get rid of everything non-alphanumeric
  33&nbsp;                                    #+ (in original script).
  34&nbsp;        tr -c '\012a-z'  '\012' |   #  Rather than deleting non-alpha chars,
  35&nbsp;                                    #+ change them to newlines.
  36&nbsp;        sort |                      # $SORT options unnecessary now.
  37&nbsp;        uniq |                      # Remove duplicates.
  38&nbsp;        grep -v '^#' |              # Delete lines beginning with a hashmark.
  39&nbsp;        grep -v '^$'                # Delete blank lines.
  40&nbsp;
  41&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
><A
NAME="SOUNDEX0"
></A
></P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="SOUNDEX"
></A
><P
><B
>Example A-9. Soundex conversion</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# soundex.sh: Calculate "soundex" code for names
   3&nbsp;
   4&nbsp;# =======================================================
   5&nbsp;#        Soundex script
   6&nbsp;#              by
   7&nbsp;#         Mendel Cooper
   8&nbsp;#     thegrendel@theriver.com
   9&nbsp;#       23 January, 2002
  10&nbsp;#
  11&nbsp;#   Placed in the Public Domain.
  12&nbsp;#
  13&nbsp;# A slightly different version of this script appeared in
  14&nbsp;#+ Ed Schaefer's July, 2002 "Shell Corner" column
  15&nbsp;#+ in "Unix Review" on-line,
  16&nbsp;#+ http://www.unixreview.com/documents/uni1026336632258/
  17&nbsp;# =======================================================
  18&nbsp;
  19&nbsp;
  20&nbsp;ARGCOUNT=1                     # Need name as argument.
  21&nbsp;E_WRONGARGS=70
  22&nbsp;
  23&nbsp;if [ $# -ne "$ARGCOUNT" ]
  24&nbsp;then
  25&nbsp;  echo "Usage: `basename $0` name"
  26&nbsp;  exit $E_WRONGARGS
  27&nbsp;fi  
  28&nbsp;
  29&nbsp;
  30&nbsp;assign_value ()                #  Assigns numerical value
  31&nbsp;{                              #+ to letters of name.
  32&nbsp;
  33&nbsp;  val1=bfpv                    # 'b,f,p,v' = 1
  34&nbsp;  val2=cgjkqsxz                # 'c,g,j,k,q,s,x,z' = 2
  35&nbsp;  val3=dt                      #  etc.
  36&nbsp;  val4=l
  37&nbsp;  val5=mn
  38&nbsp;  val6=r
  39&nbsp;
  40&nbsp;# Exceptionally clever use of 'tr' follows.
  41&nbsp;# Try to figure out what is going on here.
  42&nbsp;
  43&nbsp;value=$( echo "$1" \
  44&nbsp;| tr -d wh \
  45&nbsp;| tr $val1 1 | tr $val2 2 | tr $val3 3 \
  46&nbsp;| tr $val4 4 | tr $val5 5 | tr $val6 6 \
  47&nbsp;| tr -s 123456 \
  48&nbsp;| tr -d aeiouy )
  49&nbsp;
  50&nbsp;# Assign letter values.
  51&nbsp;# Remove duplicate numbers, except when separated by vowels.
  52&nbsp;# Ignore vowels, except as separators, so delete them last.
  53&nbsp;# Ignore 'w' and 'h', even as separators, so delete them first.
  54&nbsp;#
  55&nbsp;# The above command substitution lays more pipe than a plumber &#60;g&#62;.
  56&nbsp;
  57&nbsp;}  
  58&nbsp;
  59&nbsp;
  60&nbsp;input_name="$1"
  61&nbsp;echo
  62&nbsp;echo "Name = $input_name"
  63&nbsp;
  64&nbsp;
  65&nbsp;# Change all characters of name input to lowercase.
  66&nbsp;# ------------------------------------------------
  67&nbsp;name=$( echo $input_name | tr A-Z a-z )
  68&nbsp;# ------------------------------------------------
  69&nbsp;# Just in case argument to script is mixed case.
  70&nbsp;
  71&nbsp;
  72&nbsp;# Prefix of soundex code: first letter of name.
  73&nbsp;# --------------------------------------------
  74&nbsp;
  75&nbsp;
  76&nbsp;char_pos=0                     # Initialize character position. 
  77&nbsp;prefix0=${name:$char_pos:1}
  78&nbsp;prefix=`echo $prefix0 | tr a-z A-Z`
  79&nbsp;                               # Uppercase 1st letter of soundex.
  80&nbsp;
  81&nbsp;let "char_pos += 1"            # Bump character position to 2nd letter of name.
  82&nbsp;name1=${name:$char_pos}
  83&nbsp;
  84&nbsp;
  85&nbsp;# ++++++++++++++++++++++++++ Exception Patch +++++++++++++++++++++++++++++++++
  86&nbsp;#  Now, we run both the input name and the name shifted one char to the right
  87&nbsp;#+ through the value-assigning function.
  88&nbsp;#  If we get the same value out, that means that the first two characters
  89&nbsp;#+ of the name have the same value assigned, and that one should cancel.
  90&nbsp;#  However, we also need to test whether the first letter of the name
  91&nbsp;#+ is a vowel or 'w' or 'h', because otherwise this would bollix things up.
  92&nbsp;
  93&nbsp;char1=`echo $prefix | tr A-Z a-z`    # First letter of name, lowercased.
  94&nbsp;
  95&nbsp;assign_value $name
  96&nbsp;s1=$value
  97&nbsp;assign_value $name1
  98&nbsp;s2=$value
  99&nbsp;assign_value $char1
 100&nbsp;s3=$value
 101&nbsp;s3=9$s3                              #  If first letter of name is a vowel
 102&nbsp;                                     #+ or 'w' or 'h',
 103&nbsp;                                     #+ then its "value" will be null (unset).
 104&nbsp;				     #+ Therefore, set it to 9, an otherwise
 105&nbsp;				     #+ unused value, which can be tested for.
 106&nbsp;
 107&nbsp;
 108&nbsp;if [[ "$s1" -ne "$s2" || "$s3" -eq 9 ]]
 109&nbsp;then
 110&nbsp;  suffix=$s2
 111&nbsp;else  
 112&nbsp;  suffix=${s2:$char_pos}
 113&nbsp;fi  
 114&nbsp;# ++++++++++++++++++++++ end Exception Patch +++++++++++++++++++++++++++++++++
 115&nbsp;
 116&nbsp;
 117&nbsp;padding=000                    # Use at most 3 zeroes to pad.
 118&nbsp;
 119&nbsp;
 120&nbsp;soun=$prefix$suffix$padding    # Pad with zeroes.
 121&nbsp;
 122&nbsp;MAXLEN=4                       # Truncate to maximum of 4 chars.
 123&nbsp;soundex=${soun:0:$MAXLEN}
 124&nbsp;
 125&nbsp;echo "Soundex = $soundex"
 126&nbsp;
 127&nbsp;echo
 128&nbsp;
 129&nbsp;#  The soundex code is a method of indexing and classifying names
 130&nbsp;#+ by grouping together the ones that sound alike.
 131&nbsp;#  The soundex code for a given name is the first letter of the name,
 132&nbsp;#+ followed by a calculated three-number code.
 133&nbsp;#  Similar sounding names should have almost the same soundex codes.
 134&nbsp;
 135&nbsp;#   Examples:
 136&nbsp;#   Smith and Smythe both have a "S-530" soundex.
 137&nbsp;#   Harrison = H-625
 138&nbsp;#   Hargison = H-622
 139&nbsp;#   Harriman = H-655
 140&nbsp;
 141&nbsp;#  This works out fairly well in practice, but there are numerous anomalies.
 142&nbsp;#
 143&nbsp;#
 144&nbsp;#  The U.S. Census and certain other governmental agencies use soundex,
 145&nbsp;#  as do genealogical researchers.
 146&nbsp;#
 147&nbsp;#  For more information,
 148&nbsp;#+ see the "National Archives and Records Administration home page",
 149&nbsp;#+ http://www.nara.gov/genealogy/soundex/soundex.html
 150&nbsp;
 151&nbsp;
 152&nbsp;
 153&nbsp;# Exercise:
 154&nbsp;# --------
 155&nbsp;# Simplify the "Exception Patch" section of this script.
 156&nbsp;
 157&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
><A
NAME="LIFEREF"
></A
></P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="LIFESLOW"
></A
><P
><B
>Example A-10. <I
CLASS="FIRSTTERM"
>Game of Life</I
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# life.sh: "Life in the Slow Lane"
   3&nbsp;# Version 2: Patched by Daniel Albers
   4&nbsp;#+           to allow non-square grids as input.
   5&nbsp;
   6&nbsp;# ##################################################################### #
   7&nbsp;# This is the Bash script version of John Conway's "Game of Life".      #
   8&nbsp;# "Life" is a simple implementation of cellular automata.               #
   9&nbsp;# --------------------------------------------------------------------- #
  10&nbsp;# On a rectangular grid, let each "cell" be either "living" or "dead".  #
  11&nbsp;# Designate a living cell with a dot, and a dead one with a blank space.#
  12&nbsp;#  Begin with an arbitrarily drawn dot-and-blank grid,                  #
  13&nbsp;#+ and let this be the starting generation, "generation 0".             #
  14&nbsp;# Determine each successive generation by the following rules:          #
  15&nbsp;# 1) Each cell has 8 neighbors, the adjoining cells                     #
  16&nbsp;#+   left, right, top, bottom, and the 4 diagonals.                     #
  17&nbsp;#                       123                                             #
  18&nbsp;#                       4*5                                             #
  19&nbsp;#                       678                                             #
  20&nbsp;#                                                                       #
  21&nbsp;# 2) A living cell with either 2 or 3 living neighbors remains alive.   #
  22&nbsp;# 3) A dead cell with 3 living neighbors becomes alive (a "birth").     #
  23&nbsp;SURVIVE=2                                                               #
  24&nbsp;BIRTH=3                                                                 #
  25&nbsp;# 4) All other cases result in a dead cell for the next generation.     #
  26&nbsp;# ##################################################################### #
  27&nbsp;
  28&nbsp;
  29&nbsp;startfile=gen0   # Read the starting generation from the file "gen0".
  30&nbsp;                 # Default, if no other file specified when invoking script.
  31&nbsp;                 #
  32&nbsp;if [ -n "$1" ]   # Specify another "generation 0" file.
  33&nbsp;then
  34&nbsp;    startfile="$1"
  35&nbsp;fi  
  36&nbsp;
  37&nbsp;############################################
  38&nbsp;#  Abort script if "startfile" not specified
  39&nbsp;#+ AND
  40&nbsp;#+ "gen0" not present.
  41&nbsp;
  42&nbsp;E_NOSTARTFILE=68
  43&nbsp;
  44&nbsp;if [ ! -e "$startfile" ]
  45&nbsp;then
  46&nbsp;  echo "Startfile \""$startfile"\" missing!"
  47&nbsp;  exit $E_NOSTARTFILE
  48&nbsp;fi
  49&nbsp;############################################
  50&nbsp;
  51&nbsp;
  52&nbsp;ALIVE1=.
  53&nbsp;DEAD1=_
  54&nbsp;                 # Represent living and "dead" cells in the start-up file.
  55&nbsp;
  56&nbsp;#  ---------------------------------------------------------- #
  57&nbsp;#  This script uses a 10 x 10 grid (may be increased,
  58&nbsp;#+ but a large grid will will cause very slow execution).
  59&nbsp;ROWS=10
  60&nbsp;COLS=10
  61&nbsp;#  Change above two variables to match grid size, if necessary.
  62&nbsp;#  ---------------------------------------------------------- #
  63&nbsp;
  64&nbsp;GENERATIONS=10          #  How many generations to cycle through.
  65&nbsp;                        #  Adjust this upwards,
  66&nbsp;                        #+ if you have time on your hands.
  67&nbsp;
  68&nbsp;NONE_ALIVE=80           #  Exit status on premature bailout,
  69&nbsp;                        #+ if no cells left alive.
  70&nbsp;TRUE=0
  71&nbsp;FALSE=1
  72&nbsp;ALIVE=0
  73&nbsp;DEAD=1
  74&nbsp;
  75&nbsp;avar=                   # Global; holds current generation.
  76&nbsp;generation=0            # Initialize generation count.
  77&nbsp;
  78&nbsp;# =================================================================
  79&nbsp;
  80&nbsp;
  81&nbsp;let "cells = $ROWS * $COLS"
  82&nbsp;                        # How many cells.
  83&nbsp;
  84&nbsp;declare -a initial      # Arrays containing "cells".
  85&nbsp;declare -a current
  86&nbsp;
  87&nbsp;display ()
  88&nbsp;{
  89&nbsp;
  90&nbsp;alive=0                 # How many cells "alive" at any given time.
  91&nbsp;                        # Initially zero.
  92&nbsp;
  93&nbsp;declare -a arr
  94&nbsp;arr=( `echo "$1"` )     # Convert passed arg to array.
  95&nbsp;
  96&nbsp;element_count=${#arr[*]}
  97&nbsp;
  98&nbsp;local i
  99&nbsp;local rowcheck
 100&nbsp;
 101&nbsp;for ((i=0; i&#60;$element_count; i++))
 102&nbsp;do
 103&nbsp;
 104&nbsp;  # Insert newline at end of each row.
 105&nbsp;  let "rowcheck = $i % COLS"
 106&nbsp;  if [ "$rowcheck" -eq 0 ]
 107&nbsp;  then
 108&nbsp;    echo                # Newline.
 109&nbsp;    echo -n "      "    # Indent.
 110&nbsp;  fi  
 111&nbsp;
 112&nbsp;  cell=${arr[i]}
 113&nbsp;
 114&nbsp;  if [ "$cell" = . ]
 115&nbsp;  then
 116&nbsp;    let "alive += 1"
 117&nbsp;  fi  
 118&nbsp;
 119&nbsp;  echo -n "$cell" | sed -e 's/_/ /g'
 120&nbsp;  # Print out array and change underscores to spaces.
 121&nbsp;done  
 122&nbsp;
 123&nbsp;return
 124&nbsp;
 125&nbsp;}
 126&nbsp;
 127&nbsp;IsValid ()                            # Test whether cell coordinate valid.
 128&nbsp;{
 129&nbsp;
 130&nbsp;  if [ -z "$1"  -o -z "$2" ]          # Mandatory arguments missing?
 131&nbsp;  then
 132&nbsp;    return $FALSE
 133&nbsp;  fi
 134&nbsp;
 135&nbsp;local row
 136&nbsp;local lower_limit=0                   # Disallow negative coordinate.
 137&nbsp;local upper_limit
 138&nbsp;local left
 139&nbsp;local right
 140&nbsp;
 141&nbsp;let "upper_limit = $ROWS * $COLS - 1" # Total number of cells.
 142&nbsp;
 143&nbsp;
 144&nbsp;if [ "$1" -lt "$lower_limit" -o "$1" -gt "$upper_limit" ]
 145&nbsp;then
 146&nbsp;  return $FALSE                       # Out of array bounds.
 147&nbsp;fi  
 148&nbsp;
 149&nbsp;row=$2
 150&nbsp;let "left = $row * $COLS"             # Left limit.
 151&nbsp;let "right = $left + $COLS - 1"       # Right limit.
 152&nbsp;
 153&nbsp;if [ "$1" -lt "$left" -o "$1" -gt "$right" ]
 154&nbsp;then
 155&nbsp;  return $FALSE                       # Beyond row boundary.
 156&nbsp;fi  
 157&nbsp;
 158&nbsp;return $TRUE                          # Valid coordinate.
 159&nbsp;
 160&nbsp;}  
 161&nbsp;
 162&nbsp;
 163&nbsp;IsAlive ()              # Test whether cell is alive.
 164&nbsp;                        # Takes array, cell number, state of cell as arguments.
 165&nbsp;{
 166&nbsp;  GetCount "$1" $2      # Get alive cell count in neighborhood.
 167&nbsp;  local nhbd=$?
 168&nbsp;
 169&nbsp;
 170&nbsp;  if [ "$nhbd" -eq "$BIRTH" ]  # Alive in any case.
 171&nbsp;  then
 172&nbsp;    return $ALIVE
 173&nbsp;  fi
 174&nbsp;
 175&nbsp;  if [ "$3" = "." -a "$nhbd" -eq "$SURVIVE" ]
 176&nbsp;  then                  # Alive only if previously alive.
 177&nbsp;    return $ALIVE
 178&nbsp;  fi  
 179&nbsp;
 180&nbsp;  return $DEAD          # Default.
 181&nbsp;
 182&nbsp;}  
 183&nbsp;
 184&nbsp;
 185&nbsp;GetCount ()             # Count live cells in passed cell's neighborhood.
 186&nbsp;                        # Two arguments needed:
 187&nbsp;			# $1) variable holding array
 188&nbsp;			# $2) cell number
 189&nbsp;{
 190&nbsp;  local cell_number=$2
 191&nbsp;  local array
 192&nbsp;  local top
 193&nbsp;  local center
 194&nbsp;  local bottom
 195&nbsp;  local r
 196&nbsp;  local row
 197&nbsp;  local i
 198&nbsp;  local t_top
 199&nbsp;  local t_cen
 200&nbsp;  local t_bot
 201&nbsp;  local count=0
 202&nbsp;  local ROW_NHBD=3
 203&nbsp;
 204&nbsp;  array=( `echo "$1"` )
 205&nbsp;
 206&nbsp;  let "top = $cell_number - $COLS - 1"    # Set up cell neighborhood.
 207&nbsp;  let "center = $cell_number - 1"
 208&nbsp;  let "bottom = $cell_number + $COLS - 1"
 209&nbsp;  let "r = $cell_number / $COLS"
 210&nbsp;
 211&nbsp;  for ((i=0; i&#60;$ROW_NHBD; i++))           # Traverse from left to right. 
 212&nbsp;  do
 213&nbsp;    let "t_top = $top + $i"
 214&nbsp;    let "t_cen = $center + $i"
 215&nbsp;    let "t_bot = $bottom + $i"
 216&nbsp;
 217&nbsp;
 218&nbsp;    let "row = $r"                        # Count center row of neighborhood.
 219&nbsp;    IsValid $t_cen $row                   # Valid cell position?
 220&nbsp;    if [ $? -eq "$TRUE" ]
 221&nbsp;    then
 222&nbsp;      if [ ${array[$t_cen]} = "$ALIVE1" ] # Is it alive?
 223&nbsp;      then                                # Yes?
 224&nbsp;        let "count += 1"                  # Increment count.
 225&nbsp;      fi	
 226&nbsp;    fi  
 227&nbsp;
 228&nbsp;    let "row = $r - 1"                    # Count top row.          
 229&nbsp;    IsValid $t_top $row
 230&nbsp;    if [ $? -eq "$TRUE" ]
 231&nbsp;    then
 232&nbsp;      if [ ${array[$t_top]} = "$ALIVE1" ] 
 233&nbsp;      then
 234&nbsp;        let "count += 1"
 235&nbsp;      fi	
 236&nbsp;    fi  
 237&nbsp;
 238&nbsp;    let "row = $r + 1"                    # Count bottom row.
 239&nbsp;    IsValid $t_bot $row
 240&nbsp;    if [ $? -eq "$TRUE" ]
 241&nbsp;    then
 242&nbsp;      if [ ${array[$t_bot]} = "$ALIVE1" ] 
 243&nbsp;      then
 244&nbsp;        let "count += 1"
 245&nbsp;      fi	
 246&nbsp;    fi  
 247&nbsp;
 248&nbsp;  done  
 249&nbsp;
 250&nbsp;
 251&nbsp;  if [ ${array[$cell_number]} = "$ALIVE1" ]
 252&nbsp;  then
 253&nbsp;    let "count -= 1"        #  Make sure value of tested cell itself
 254&nbsp;  fi                        #+ is not counted.
 255&nbsp;
 256&nbsp;
 257&nbsp;  return $count
 258&nbsp;  
 259&nbsp;}
 260&nbsp;
 261&nbsp;next_gen ()               # Update generation array.
 262&nbsp;{
 263&nbsp;
 264&nbsp;local array
 265&nbsp;local i=0
 266&nbsp;
 267&nbsp;array=( `echo "$1"` )     # Convert passed arg to array.
 268&nbsp;
 269&nbsp;while [ "$i" -lt "$cells" ]
 270&nbsp;do
 271&nbsp;  IsAlive "$1" $i ${array[$i]}   # Is cell alive?
 272&nbsp;  if [ $? -eq "$ALIVE" ]
 273&nbsp;  then                           #  If alive, then
 274&nbsp;    array[$i]=.                  #+ represent the cell as a period.
 275&nbsp;  else  
 276&nbsp;    array[$i]="_"                #  Otherwise underscore
 277&nbsp;   fi                            #+ (which will later be converted to space).  
 278&nbsp;  let "i += 1" 
 279&nbsp;done   
 280&nbsp;
 281&nbsp;
 282&nbsp;# let "generation += 1"   # Increment generation count.
 283&nbsp;# Why was the above line commented out?
 284&nbsp;
 285&nbsp;
 286&nbsp;# Set variable to pass as parameter to "display" function.
 287&nbsp;avar=`echo ${array[@]}`   # Convert array back to string variable.
 288&nbsp;display "$avar"           # Display it.
 289&nbsp;echo; echo
 290&nbsp;echo "Generation $generation  -  $alive alive"
 291&nbsp;
 292&nbsp;if [ "$alive" -eq 0 ]
 293&nbsp;then
 294&nbsp;  echo
 295&nbsp;  echo "Premature exit: no more cells alive!"
 296&nbsp;  exit $NONE_ALIVE        #  No point in continuing
 297&nbsp;fi                        #+ if no live cells.
 298&nbsp;
 299&nbsp;}
 300&nbsp;
 301&nbsp;
 302&nbsp;# =========================================================
 303&nbsp;
 304&nbsp;# main ()
 305&nbsp;
 306&nbsp;# Load initial array with contents of startup file.
 307&nbsp;initial=( `cat "$startfile" | sed -e '/#/d' | tr -d '\n' |\
 308&nbsp;sed -e 's/\./\. /g' -e 's/_/_ /g'` )
 309&nbsp;# Delete lines containing '#' comment character.
 310&nbsp;# Remove linefeeds and insert space between elements.
 311&nbsp;
 312&nbsp;clear          # Clear screen.
 313&nbsp;
 314&nbsp;echo #         Title
 315&nbsp;echo "======================="
 316&nbsp;echo "    $GENERATIONS generations"
 317&nbsp;echo "           of"
 318&nbsp;echo "\"Life in the Slow Lane\""
 319&nbsp;echo "======================="
 320&nbsp;
 321&nbsp;
 322&nbsp;# -------- Display first generation. --------
 323&nbsp;Gen0=`echo ${initial[@]}`
 324&nbsp;display "$Gen0"           # Display only.
 325&nbsp;echo; echo
 326&nbsp;echo "Generation $generation  -  $alive alive"
 327&nbsp;# -------------------------------------------
 328&nbsp;
 329&nbsp;
 330&nbsp;let "generation += 1"     # Increment generation count.
 331&nbsp;echo
 332&nbsp;
 333&nbsp;# ------- Display second generation. -------
 334&nbsp;Cur=`echo ${initial[@]}`
 335&nbsp;next_gen "$Cur"          # Update &#38; display.
 336&nbsp;# ------------------------------------------
 337&nbsp;
 338&nbsp;let "generation += 1"     # Increment generation count.
 339&nbsp;
 340&nbsp;# ------ Main loop for displaying subsequent generations ------
 341&nbsp;while [ "$generation" -le "$GENERATIONS" ]
 342&nbsp;do
 343&nbsp;  Cur="$avar"
 344&nbsp;  next_gen "$Cur"
 345&nbsp;  let "generation += 1"
 346&nbsp;done
 347&nbsp;# ==============================================================
 348&nbsp;
 349&nbsp;echo
 350&nbsp;
 351&nbsp;exit 0   # END
 352&nbsp;
 353&nbsp;
 354&nbsp;
 355&nbsp;# The grid in this script has a "boundary problem."
 356&nbsp;# The the top, bottom, and sides border on a void of dead cells.
 357&nbsp;# Exercise: Change the script to have the grid wrap around,
 358&nbsp;# +         so that the left and right sides will "touch,"      
 359&nbsp;# +         as will the top and bottom.
 360&nbsp;#
 361&nbsp;# Exercise: Create a new "gen0" file to seed this script.
 362&nbsp;#           Use a 12 x 16 grid, instead of the original 10 x 10 one.
 363&nbsp;#           Make the necessary changes to the script,
 364&nbsp;#+          so it will run with the altered file.
 365&nbsp;#
 366&nbsp;# Exercise: Modify this script so that it can determine the grid size
 367&nbsp;#+          from the "gen0" file, and set any variables necessary
 368&nbsp;#+          for the script to run.
 369&nbsp;#           This would make unnecessary any changes to variables
 370&nbsp;#+          in the script for an altered grid size.</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="GEN0DATA"
></A
><P
><B
>Example A-11. Data file for <I
CLASS="FIRSTTERM"
>Game of Life</I
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;# gen0
   2&nbsp;#
   3&nbsp;# This is an example "generation 0" start-up file for "life.sh".
   4&nbsp;# --------------------------------------------------------------
   5&nbsp;#  The "gen0" file is a 10 x 10 grid using a period (.) for live cells,
   6&nbsp;#+ and an underscore (_) for dead ones. We cannot simply use spaces
   7&nbsp;#+ for dead cells in this file because of a peculiarity in Bash arrays.
   8&nbsp;#  [Exercise for the reader: explain this.]
   9&nbsp;#
  10&nbsp;# Lines beginning with a '#' are comments, and the script ignores them.
  11&nbsp;__.__..___
  12&nbsp;___._.____
  13&nbsp;____.___..
  14&nbsp;_._______.
  15&nbsp;____._____
  16&nbsp;..__...___
  17&nbsp;____._____
  18&nbsp;___...____
  19&nbsp;__.._..___
  20&nbsp;_..___..__</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>+++</P
><P
>The following two scripts are by Mark Moraes of the University
    of Toronto. See the file <TT
CLASS="FILENAME"
>Moraes-COPYRIGHT</TT
>
    for permissions and restrictions. This file is included in the
    combined <A
HREF="index.html#WHERE_TARBALL"
>HTML/source tarball</A
>
    of the <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ABS Guide</I
></SPAN
>.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="BEHEAD"
></A
><P
><B
>Example A-12. <I
CLASS="FIRSTTERM"
>behead</I
>: Removing mail and news
      message headers</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#! /bin/sh
   2&nbsp;# Strips off the header from a mail/News message i.e. till the first
   3&nbsp;# empty line
   4&nbsp;# Mark Moraes, University of Toronto
   5&nbsp;
   6&nbsp;# ==&#62; These comments added by author of this document.
   7&nbsp;
   8&nbsp;if [ $# -eq 0 ]; then
   9&nbsp;# ==&#62; If no command line args present, then works on file redirected to stdin.
  10&nbsp;	sed -e '1,/^$/d' -e '/^[ 	]*$/d'
  11&nbsp;	# --&#62; Delete empty lines and all lines until 
  12&nbsp;	# --&#62; first one beginning with white space.
  13&nbsp;else
  14&nbsp;# ==&#62; If command line args present, then work on files named.
  15&nbsp;	for i do
  16&nbsp;		sed -e '1,/^$/d' -e '/^[ 	]*$/d' $i
  17&nbsp;		# --&#62; Ditto, as above.
  18&nbsp;	done
  19&nbsp;fi
  20&nbsp;
  21&nbsp;# ==&#62; Exercise: Add error checking and other options.
  22&nbsp;# ==&#62;
  23&nbsp;# ==&#62; Note that the small sed script repeats, except for the arg passed.
  24&nbsp;# ==&#62; Does it make sense to embed it in a function? Why or why not?</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="FTPGET"
></A
><P
><B
>Example A-13. <I
CLASS="FIRSTTERM"
>ftpget</I
>: Downloading files via ftp</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#! /bin/sh 
   2&nbsp;# $Id: ftpget,v 1.2 91/05/07 21:15:43 moraes Exp $ 
   3&nbsp;# Script to perform batch anonymous ftp. Essentially converts a list of
   4&nbsp;# of command line arguments into input to ftp.
   5&nbsp;# ==&#62; This script is nothing but a shell wrapper around "ftp" . . .
   6&nbsp;# Simple, and quick - written as a companion to ftplist 
   7&nbsp;# -h specifies the remote host (default prep.ai.mit.edu) 
   8&nbsp;# -d specifies the remote directory to cd to - you can provide a sequence 
   9&nbsp;# of -d options - they will be cd'ed to in turn. If the paths are relative, 
  10&nbsp;# make sure you get the sequence right. Be careful with relative paths - 
  11&nbsp;# there are far too many symlinks nowadays.  
  12&nbsp;# (default is the ftp login directory)
  13&nbsp;# -v turns on the verbose option of ftp, and shows all responses from the 
  14&nbsp;# ftp server.  
  15&nbsp;# -f remotefile[:localfile] gets the remote file into localfile 
  16&nbsp;# -m pattern does an mget with the specified pattern. Remember to quote 
  17&nbsp;# shell characters.  
  18&nbsp;# -c does a local cd to the specified directory
  19&nbsp;# For example, 
  20&nbsp;# 	ftpget -h expo.lcs.mit.edu -d contrib -f xplaces.shar:xplaces.sh \
  21&nbsp;#		-d ../pub/R3/fixes -c ~/fixes -m 'fix*' 
  22&nbsp;# will get xplaces.shar from ~ftp/contrib on expo.lcs.mit.edu, and put it
  23&nbsp;# in xplaces.sh in the current working directory, and get all fixes from
  24&nbsp;# ~ftp/pub/R3/fixes and put them in the ~/fixes directory. 
  25&nbsp;# Obviously, the sequence of the options is important, since the equivalent
  26&nbsp;# commands are executed by ftp in corresponding order
  27&nbsp;#
  28&nbsp;# Mark Moraes &#60;moraes@csri.toronto.edu&#62;, Feb 1, 1989 
  29&nbsp;#
  30&nbsp;
  31&nbsp;
  32&nbsp;# ==&#62; These comments added by author of this document.
  33&nbsp;
  34&nbsp;# PATH=/local/bin:/usr/ucb:/usr/bin:/bin
  35&nbsp;# export PATH
  36&nbsp;# ==&#62; Above 2 lines from original script probably superfluous.
  37&nbsp;
  38&nbsp;E_BADARGS=65
  39&nbsp;
  40&nbsp;TMPFILE=/tmp/ftp.$$
  41&nbsp;# ==&#62; Creates temp file, using process id of script ($$)
  42&nbsp;# ==&#62; to construct filename.
  43&nbsp;
  44&nbsp;SITE=`domainname`.toronto.edu
  45&nbsp;# ==&#62; 'domainname' similar to 'hostname'
  46&nbsp;# ==&#62; May rewrite this to parameterize this for general use.
  47&nbsp;
  48&nbsp;usage="Usage: $0 [-h remotehost] [-d remotedirectory]... \ 
  49&nbsp;[-f remfile:localfile]...  [-c localdirectory] [-m filepattern] [-v]"
  50&nbsp;ftpflags="-i -n"
  51&nbsp;verbflag=
  52&nbsp;set -f 		# So we can use globbing in -m
  53&nbsp;set x `getopt vh:d:c:m:f: $*`
  54&nbsp;if [ $? != 0 ]; then
  55&nbsp;	echo $usage
  56&nbsp;	exit $E_BADARGS
  57&nbsp;fi
  58&nbsp;shift
  59&nbsp;trap 'rm -f ${TMPFILE} ; exit' 0   1     2              3        15
  60&nbsp;# ==&#62;                   Signals:   HUP   INT (Ctl-C)    QUIT     TERM
  61&nbsp;# ==&#62; Delete tempfile in case of abnormal exit from script.
  62&nbsp;echo "user anonymous ${USER-gnu}@${SITE} &#62; ${TMPFILE}"
  63&nbsp;# ==&#62; Added quotes (recommended in complex echoes).
  64&nbsp;echo binary &#62;&#62; ${TMPFILE}
  65&nbsp;for i in $*   # ==&#62; Parse command line args.
  66&nbsp;do
  67&nbsp;	case $i in
  68&nbsp;	-v) verbflag=-v; echo hash &#62;&#62; ${TMPFILE}; shift;;
  69&nbsp;	-h) remhost=$2; shift 2;;
  70&nbsp;	-d) echo cd $2 &#62;&#62; ${TMPFILE}; 
  71&nbsp;	    if [ x${verbflag} != x ]; then
  72&nbsp;	        echo pwd &#62;&#62; ${TMPFILE};
  73&nbsp;	    fi;
  74&nbsp;	    shift 2;;
  75&nbsp;	-c) echo lcd $2 &#62;&#62; ${TMPFILE}; shift 2;;
  76&nbsp;	-m) echo mget "$2" &#62;&#62; ${TMPFILE}; shift 2;;
  77&nbsp;	-f) f1=`expr "$2" : "\([^:]*\).*"`; f2=`expr "$2" : "[^:]*:\(.*\)"`;
  78&nbsp;	    echo get ${f1} ${f2} &#62;&#62; ${TMPFILE}; shift 2;;
  79&nbsp;	--) shift; break;;
  80&nbsp;	esac
  81&nbsp;        # ==&#62; 'lcd' and 'mget' are ftp commands. See "man ftp" . . .
  82&nbsp;done
  83&nbsp;if [ $# -ne 0 ]; then
  84&nbsp;	echo $usage
  85&nbsp;	exit $E_BADARGS
  86&nbsp;        # ==&#62; Changed from "exit 2" to conform with style standard.
  87&nbsp;fi
  88&nbsp;if [ x${verbflag} != x ]; then
  89&nbsp;	ftpflags="${ftpflags} -v"
  90&nbsp;fi
  91&nbsp;if [ x${remhost} = x ]; then
  92&nbsp;	remhost=prep.ai.mit.edu
  93&nbsp;	# ==&#62; Change to match appropriate ftp site.
  94&nbsp;fi
  95&nbsp;echo quit &#62;&#62; ${TMPFILE}
  96&nbsp;# ==&#62; All commands saved in tempfile.
  97&nbsp;
  98&nbsp;ftp ${ftpflags} ${remhost} &#60; ${TMPFILE}
  99&nbsp;# ==&#62; Now, tempfile batch processed by ftp.
 100&nbsp;
 101&nbsp;rm -f ${TMPFILE}
 102&nbsp;# ==&#62; Finally, tempfile deleted (you may wish to copy it to a logfile).
 103&nbsp;
 104&nbsp;
 105&nbsp;# ==&#62; Exercises:
 106&nbsp;# ==&#62; ---------
 107&nbsp;# ==&#62; 1) Add error checking.
 108&nbsp;# ==&#62; 2) Add bells &#38; whistles.</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>+</P
><P
>Antek Sawicki contributed the following script, which makes very
      clever use of the parameter substitution operators discussed in
      <A
HREF="parameter-substitution.html"
>Section 9.3</A
>.</P
><P
><A
NAME="PW0"
></A
></P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="PW"
></A
><P
><B
>Example A-14. <I
CLASS="FIRSTTERM"
>password</I
>: Generating random
      8-character passwords</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# May need to be invoked with  #!/bin/bash2  on older machines.
   3&nbsp;#
   4&nbsp;#  Random password generator for Bash 2.x +
   5&nbsp;#+ by Antek Sawicki &#60;tenox@tenox.tc&#62;,
   6&nbsp;#+ who generously gave usage permission to the ABS Guide author.
   7&nbsp;#
   8&nbsp;# ==&#62; Comments added by document author ==&#62;
   9&nbsp;
  10&nbsp;
  11&nbsp;MATRIX="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
  12&nbsp;# ==&#62; Password will consist of alphanumeric characters.
  13&nbsp;LENGTH="8"
  14&nbsp;# ==&#62; May change 'LENGTH' for longer password.
  15&nbsp;
  16&nbsp;
  17&nbsp;while [ "${n:=1}" -le "$LENGTH" ]
  18&nbsp;# ==&#62; Recall that := is "default substitution" operator.
  19&nbsp;# ==&#62; So, if 'n' has not been initialized, set it to 1.
  20&nbsp;do
  21&nbsp;	PASS="$PASS${MATRIX:$(($RANDOM%${#MATRIX})):1}"
  22&nbsp;	# ==&#62; Very clever, but tricky.
  23&nbsp;
  24&nbsp;	# ==&#62; Starting from the innermost nesting...
  25&nbsp;	# ==&#62; ${#MATRIX} returns length of array MATRIX.
  26&nbsp;
  27&nbsp;	# ==&#62; $RANDOM%${#MATRIX} returns random number between 1
  28&nbsp;	# ==&#62; and [length of MATRIX] - 1.
  29&nbsp;
  30&nbsp;	# ==&#62; ${MATRIX:$(($RANDOM%${#MATRIX})):1}
  31&nbsp;	# ==&#62; returns expansion of MATRIX at random position, by length 1. 
  32&nbsp;	# ==&#62; See {var:pos:len} parameter substitution in Chapter 9.
  33&nbsp;	# ==&#62; and the associated examples.
  34&nbsp;
  35&nbsp;	# ==&#62; PASS=... simply pastes this result onto previous PASS (concatenation).
  36&nbsp;
  37&nbsp;	# ==&#62; To visualize this more clearly, uncomment the following line
  38&nbsp;	#                 echo "$PASS"
  39&nbsp;	# ==&#62; to see PASS being built up,
  40&nbsp;	# ==&#62; one character at a time, each iteration of the loop.
  41&nbsp;
  42&nbsp;	let n+=1
  43&nbsp;	# ==&#62; Increment 'n' for next pass.
  44&nbsp;done
  45&nbsp;
  46&nbsp;echo "$PASS"      # ==&#62; Or, redirect to a file, as desired.
  47&nbsp;
  48&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>+</P
><P
><A
NAME="ZFIFO"
></A
>James R. Van Zandt contributed this script
      which uses named pipes and, in his words, <SPAN
CLASS="QUOTE"
>"really exercises
      quoting and escaping."</SPAN
></P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="FIFO"
></A
><P
><B
>Example A-15. <I
CLASS="FIRSTTERM"
>fifo</I
>: Making daily backups, using
      named pipes</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# ==&#62; Script by James R. Van Zandt, and used here with his permission.
   3&nbsp;
   4&nbsp;# ==&#62; Comments added by author of this document.
   5&nbsp;
   6&nbsp;  
   7&nbsp;  HERE=`uname -n`    # ==&#62; hostname
   8&nbsp;  THERE=bilbo
   9&nbsp;  echo "starting remote backup to $THERE at `date +%r`"
  10&nbsp;  # ==&#62; `date +%r` returns time in 12-hour format, i.e. "08:08:34 PM".
  11&nbsp;  
  12&nbsp;  # make sure /pipe really is a pipe and not a plain file
  13&nbsp;  rm -rf /pipe
  14&nbsp;  mkfifo /pipe       # ==&#62; Create a "named pipe", named "/pipe".
  15&nbsp;  
  16&nbsp;  # ==&#62; 'su xyz' runs commands as user "xyz".
  17&nbsp;  # ==&#62; 'ssh' invokes secure shell (remote login client).
  18&nbsp;  su xyz -c "ssh $THERE \"cat &#62; /home/xyz/backup/${HERE}-daily.tar.gz\" &#60; /pipe"&#38;
  19&nbsp;  cd /
  20&nbsp;  tar -czf - bin boot dev etc home info lib man root sbin share usr var &#62; /pipe
  21&nbsp;  # ==&#62; Uses named pipe, /pipe, to communicate between processes:
  22&nbsp;  # ==&#62; 'tar/gzip' writes to /pipe and 'ssh' reads from /pipe.
  23&nbsp;
  24&nbsp;  # ==&#62; The end result is this backs up the main directories, from / on down.
  25&nbsp;
  26&nbsp;  # ==&#62;  What are the advantages of a "named pipe" in this situation,
  27&nbsp;  # ==&#62;+ as opposed to an "anonymous pipe", with |?
  28&nbsp;  # ==&#62;  Will an anonymous pipe even work here?
  29&nbsp;
  30&nbsp;  # ==&#62;  Is it necessary to delete the pipe before exiting the script?
  31&nbsp;  # ==&#62;  How could that be done?
  32&nbsp;
  33&nbsp;
  34&nbsp;  exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>+</P
><P
><A
NAME="PRIMES1"
></A
></P
><P
>Stphane Chazelas used the following script to
      demonstrate generating prime numbers without arrays.</P
><P
><A
NAME="PRIMES00"
></A
></P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="PRIMES"
></A
><P
><B
>Example A-16. Generating prime numbers using the modulo operator</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# primes.sh: Generate prime numbers, without using arrays.
   3&nbsp;# Script contributed by Stephane Chazelas.
   4&nbsp;
   5&nbsp;#  This does *not* use the classic "Sieve of Eratosthenes" algorithm,
   6&nbsp;#+ but instead the more intuitive method of testing each candidate number
   7&nbsp;#+ for factors (divisors), using the "%" modulo operator.
   8&nbsp;
   9&nbsp;
  10&nbsp;LIMIT=1000                    # Primes, 2 ... 1000.
  11&nbsp;
  12&nbsp;Primes()
  13&nbsp;{
  14&nbsp; (( n = $1 + 1 ))             # Bump to next integer.
  15&nbsp; shift                        # Next parameter in list.
  16&nbsp;#  echo "_n=$n i=$i_"
  17&nbsp; 
  18&nbsp; if (( n == LIMIT ))
  19&nbsp; then echo $*
  20&nbsp; return
  21&nbsp; fi
  22&nbsp;
  23&nbsp; for i; do                    # "i" set to "@", previous values of $n.
  24&nbsp;#   echo "-n=$n i=$i-"
  25&nbsp;   (( i * i &#62; n )) &#38;&#38; break   # Optimization.
  26&nbsp;   (( n % i )) &#38;&#38; continue    # Sift out non-primes using modulo operator.
  27&nbsp;   Primes $n $@               # Recursion inside loop.
  28&nbsp;   return
  29&nbsp;   done
  30&nbsp;
  31&nbsp;   Primes $n $@ $n            # Recursion outside loop.
  32&nbsp;                              # Successively accumulate positional parameters.
  33&nbsp;                              # "$@" is the accumulating list of primes.
  34&nbsp;}
  35&nbsp;
  36&nbsp;Primes 1
  37&nbsp;
  38&nbsp;exit $?  # Pipe output of the script to 'fmt' for prettier printing.
  39&nbsp;
  40&nbsp;#  Uncomment lines 16 and 24 to help figure out what is going on.
  41&nbsp;
  42&nbsp;#  Compare the speed of this algorithm for generating primes
  43&nbsp;#+ with the Sieve of Eratosthenes (ex68.sh).
  44&nbsp;
  45&nbsp;
  46&nbsp;#  Exercise: Rewrite this script without recursion, for faster execution.</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>+</P
><P
>Rick Boivie's revision of Jordi Sanfeliu's
      <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>tree</I
></SPAN
> script.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="TREE"
></A
><P
><B
>Example A-17. <I
CLASS="FIRSTTERM"
>tree</I
>: Displaying a directory tree</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# tree.sh
   3&nbsp;
   4&nbsp;#  Written by Rick Boivie.
   5&nbsp;#  Used with permission.
   6&nbsp;#  This is a revised and simplified version of a script
   7&nbsp;#+ by Jordi Sanfeliu (and patched by Ian Kjos).
   8&nbsp;#  This script replaces the earlier version used in
   9&nbsp;#+ previous releases of the Advanced Bash Scripting Guide.
  10&nbsp;
  11&nbsp;# ==&#62; Comments added by the author of this document.
  12&nbsp;
  13&nbsp;
  14&nbsp;search () {
  15&nbsp;for dir in `echo *`
  16&nbsp;#  ==&#62; `echo *` lists all the files in current working directory,
  17&nbsp;#+ ==&#62; without line breaks.
  18&nbsp;#  ==&#62; Similar effect to for dir in *
  19&nbsp;#  ==&#62; but "dir in `echo *`" will not handle filenames with blanks.
  20&nbsp;do
  21&nbsp;  if [ -d "$dir" ] ; then # ==&#62; If it is a directory (-d)...
  22&nbsp;  zz=0                    # ==&#62; Temp variable, keeping track of directory level.
  23&nbsp;  while [ $zz != $1 ]     # Keep track of inner nested loop.
  24&nbsp;    do
  25&nbsp;      echo -n "| "        # ==&#62; Display vertical connector symbol,
  26&nbsp;                          # ==&#62; with 2 spaces &#38; no line feed in order to indent.
  27&nbsp;      zz=`expr $zz + 1`   # ==&#62; Increment zz.
  28&nbsp;    done
  29&nbsp;
  30&nbsp;    if [ -L "$dir" ] ; then # ==&#62; If directory is a symbolic link...
  31&nbsp;      echo "+---$dir" `ls -l $dir | sed 's/^.*'$dir' //'`
  32&nbsp;      # ==&#62; Display horiz. connector and list directory name, but...
  33&nbsp;      # ==&#62; delete date/time part of long listing.
  34&nbsp;    else
  35&nbsp;      echo "+---$dir"       # ==&#62; Display horizontal connector symbol...
  36&nbsp;      # ==&#62; and print directory name.
  37&nbsp;      numdirs=`expr $numdirs + 1` # ==&#62; Increment directory count.
  38&nbsp;      if cd "$dir" ; then         # ==&#62; If can move to subdirectory...
  39&nbsp;        search `expr $1 + 1`      # with recursion ;-)
  40&nbsp;        # ==&#62; Function calls itself.
  41&nbsp;        cd ..
  42&nbsp;      fi
  43&nbsp;    fi
  44&nbsp;  fi
  45&nbsp;done
  46&nbsp;}
  47&nbsp;
  48&nbsp;if [ $# != 0 ] ; then
  49&nbsp;  cd $1 # move to indicated directory.
  50&nbsp;  #else # stay in current directory
  51&nbsp;fi
  52&nbsp;
  53&nbsp;echo "Initial directory = `pwd`"
  54&nbsp;numdirs=0
  55&nbsp;
  56&nbsp;search 0
  57&nbsp;echo "Total directories = $numdirs"
  58&nbsp;
  59&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>Patsie's version of a directory <I
CLASS="FIRSTTERM"
>tree</I
>
      script.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="TREE2"
></A
><P
><B
>Example A-18. <I
CLASS="FIRSTTERM"
>tree2</I
>: Alternate directory tree script</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# tree2.sh
   3&nbsp;
   4&nbsp;# Lightly modified/reformatted by ABS Guide author.
   5&nbsp;# Included in ABS Guide with permission of script author (thanks!).
   6&nbsp;
   7&nbsp;## Recursive file/dirsize checking script, by Patsie
   8&nbsp;##
   9&nbsp;## This script builds a list of files/directories and their size (du -akx)
  10&nbsp;## and processes this list to a human readable tree shape
  11&nbsp;## The 'du -akx' is only as good as the permissions the owner has.
  12&nbsp;## So preferably run as root* to get the best results, or use only on
  13&nbsp;## directories for which you have read permissions. Anything you can't
  14&nbsp;## read is not in the list.
  15&nbsp;
  16&nbsp;#* ABS Guide author advises caution when running scripts as root!
  17&nbsp;
  18&nbsp;
  19&nbsp;##########  THIS IS CONFIGURABLE  ##########
  20&nbsp;
  21&nbsp;TOP=5                   # Top 5 biggest (sub)directories.
  22&nbsp;MAXRECURS=5             # Max 5 subdirectories/recursions deep.
  23&nbsp;E_BL=80                 # Blank line already returned.
  24&nbsp;E_DIR=81                # Directory not specified.
  25&nbsp;
  26&nbsp;
  27&nbsp;##########  DON'T CHANGE ANYTHING BELOW THIS LINE  ##########
  28&nbsp;
  29&nbsp;PID=$$                            # Our own process ID.
  30&nbsp;SELF=`basename $0`                # Our own program name.
  31&nbsp;TMP="/tmp/${SELF}.${PID}.tmp"     # Temporary 'du' result.
  32&nbsp;
  33&nbsp;# Convert number to dotted thousand.
  34&nbsp;function dot { echo "            $*" |
  35&nbsp;               sed -e :a -e 's/\(.*[0-9]\)\([0-9]\{3\}\)/\1,\2/;ta' |
  36&nbsp;               tail -c 12; }
  37&nbsp;
  38&nbsp;# Usage: tree &#60;recursion&#62; &#60;indent prefix&#62; &#60;min size&#62; &#60;directory&#62;
  39&nbsp;function tree {
  40&nbsp;  recurs="$1"           # How deep nested are we?
  41&nbsp;  prefix="$2"           # What do we display before file/dirname?
  42&nbsp;  minsize="$3"          # What is the minumum file/dirsize?
  43&nbsp;  dirname="$4"          # Which directory are we checking?
  44&nbsp;
  45&nbsp;# Get ($TOP) biggest subdirs/subfiles from TMP file.
  46&nbsp;  LIST=`egrep "[[:space:]]${dirname}/[^/]*$" "$TMP" |
  47&nbsp;        awk '{if($1&#62;'$minsize') print;}' | sort -nr | head -$TOP`
  48&nbsp;  [ -z "$LIST" ] &#38;&#38; return        # Empty list, then go back.
  49&nbsp;
  50&nbsp;  cnt=0
  51&nbsp;  num=`echo "$LIST" | wc -l`      # How many entries in the list.
  52&nbsp;
  53&nbsp;  ## Main loop
  54&nbsp;  echo "$LIST" | while read size name; do
  55&nbsp;    ((cnt+=1))		          # Count entry number.
  56&nbsp;    bname=`basename "$name"`      # We only need a basename of the entry.
  57&nbsp;    [ -d "$name" ] &#38;&#38; bname="$bname/"
  58&nbsp;                                  # If it's a directory, append a slash.
  59&nbsp;    echo "`dot $size`$prefix +-$bname"
  60&nbsp;                                  # Display the result.
  61&nbsp;    #  Call ourself recursively if it's a directory
  62&nbsp;    #+ and we're not nested too deep ($MAXRECURS).
  63&nbsp;    #  The recursion goes up: $((recurs+1))
  64&nbsp;    #  The prefix gets a space if it's the last entry,
  65&nbsp;    #+ or a pipe if there are more entries.
  66&nbsp;    #  The minimum file/dirsize becomes
  67&nbsp;    #+ a tenth of his parent: $((size/10)).
  68&nbsp;    # Last argument is the full directory name to check.
  69&nbsp;    if [ -d "$name" -a $recurs -lt $MAXRECURS ]; then
  70&nbsp;      [ $cnt -lt $num ] \
  71&nbsp;        || (tree $((recurs+1)) "$prefix  " $((size/10)) "$name") \
  72&nbsp;        &#38;&#38; (tree $((recurs+1)) "$prefix |" $((size/10)) "$name")
  73&nbsp;    fi
  74&nbsp;  done
  75&nbsp;
  76&nbsp;  [ $? -eq 0 ] &#38;&#38; echo "           $prefix"
  77&nbsp;  # Every time we jump back add a 'blank' line.
  78&nbsp;  return $E_BL
  79&nbsp;  # We return 80 to tell we added a blank line already.
  80&nbsp;}
  81&nbsp;
  82&nbsp;###                ###
  83&nbsp;###  main program  ###
  84&nbsp;###                ###
  85&nbsp;
  86&nbsp;rootdir="$@"
  87&nbsp;[ -d "$rootdir" ] ||
  88&nbsp;  { echo "$SELF: Usage: $SELF &#60;directory&#62;" &#62;&#38;2; exit $E_DIR; }
  89&nbsp;  # We should be called with a directory name.
  90&nbsp;
  91&nbsp;echo "Building inventory list, please wait ..."
  92&nbsp;     # Show "please wait" message.
  93&nbsp;du -akx "$rootdir" 1&#62;"$TMP" 2&#62;/dev/null
  94&nbsp;     # Build a temporary list of all files/dirs and their size.
  95&nbsp;size=`tail -1 "$TMP" | awk '{print $1}'`
  96&nbsp;     # What is our rootdirectory's size?
  97&nbsp;echo "`dot $size` $rootdir"
  98&nbsp;     # Display rootdirectory's entry.
  99&nbsp;tree 0 "" 0 "$rootdir"
 100&nbsp;     # Display the tree below our rootdirectory.
 101&nbsp;
 102&nbsp;rm "$TMP" 2&#62;/dev/null
 103&nbsp;     # Clean up TMP file.
 104&nbsp;
 105&nbsp;exit $?</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>Noah Friedman permitted use of his <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>string
      function</I
></SPAN
> script. It essentially reproduces some
      of the <I
CLASS="FIRSTTERM"
>C</I
>-library string manipulation
      functions.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="STRING"
></A
><P
><B
>Example A-19. <I
CLASS="FIRSTTERM"
>string functions</I
>: C-style string
      functions</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;# string.bash --- bash emulation of string(3) library routines
   4&nbsp;# Author: Noah Friedman &#60;friedman@prep.ai.mit.edu&#62;
   5&nbsp;# ==&#62;     Used with his kind permission in this document.
   6&nbsp;# Created: 1992-07-01
   7&nbsp;# Last modified: 1993-09-29
   8&nbsp;# Public domain
   9&nbsp;
  10&nbsp;# Conversion to bash v2 syntax done by Chet Ramey
  11&nbsp;
  12&nbsp;# Commentary:
  13&nbsp;# Code:
  14&nbsp;
  15&nbsp;#:docstring strcat:
  16&nbsp;# Usage: strcat s1 s2
  17&nbsp;#
  18&nbsp;# Strcat appends the value of variable s2 to variable s1. 
  19&nbsp;#
  20&nbsp;# Example:
  21&nbsp;#    a="foo"
  22&nbsp;#    b="bar"
  23&nbsp;#    strcat a b
  24&nbsp;#    echo $a
  25&nbsp;#    =&#62; foobar
  26&nbsp;#
  27&nbsp;#:end docstring:
  28&nbsp;
  29&nbsp;###;;;autoload   ==&#62; Autoloading of function commented out.
  30&nbsp;function strcat ()
  31&nbsp;{
  32&nbsp;    local s1_val s2_val
  33&nbsp;
  34&nbsp;    s1_val=${!1}                        # indirect variable expansion
  35&nbsp;    s2_val=${!2}
  36&nbsp;    eval "$1"=\'"${s1_val}${s2_val}"\'
  37&nbsp;    # ==&#62; eval $1='${s1_val}${s2_val}' avoids problems,
  38&nbsp;    # ==&#62; if one of the variables contains a single quote.
  39&nbsp;}
  40&nbsp;
  41&nbsp;#:docstring strncat:
  42&nbsp;# Usage: strncat s1 s2 $n
  43&nbsp;# 
  44&nbsp;# Line strcat, but strncat appends a maximum of n characters from the value
  45&nbsp;# of variable s2.  It copies fewer if the value of variabl s2 is shorter
  46&nbsp;# than n characters.  Echoes result on stdout.
  47&nbsp;#
  48&nbsp;# Example:
  49&nbsp;#    a=foo
  50&nbsp;#    b=barbaz
  51&nbsp;#    strncat a b 3
  52&nbsp;#    echo $a
  53&nbsp;#    =&#62; foobar
  54&nbsp;#
  55&nbsp;#:end docstring:
  56&nbsp;
  57&nbsp;###;;;autoload
  58&nbsp;function strncat ()
  59&nbsp;{
  60&nbsp;    local s1="$1"
  61&nbsp;    local s2="$2"
  62&nbsp;    local -i n="$3"
  63&nbsp;    local s1_val s2_val
  64&nbsp;
  65&nbsp;    s1_val=${!s1}                       # ==&#62; indirect variable expansion
  66&nbsp;    s2_val=${!s2}
  67&nbsp;
  68&nbsp;    if [ ${#s2_val} -gt ${n} ]; then
  69&nbsp;       s2_val=${s2_val:0:$n}            # ==&#62; substring extraction
  70&nbsp;    fi
  71&nbsp;
  72&nbsp;    eval "$s1"=\'"${s1_val}${s2_val}"\'
  73&nbsp;    # ==&#62; eval $1='${s1_val}${s2_val}' avoids problems,
  74&nbsp;    # ==&#62; if one of the variables contains a single quote.
  75&nbsp;}
  76&nbsp;
  77&nbsp;#:docstring strcmp:
  78&nbsp;# Usage: strcmp $s1 $s2
  79&nbsp;#
  80&nbsp;# Strcmp compares its arguments and returns an integer less than, equal to,
  81&nbsp;# or greater than zero, depending on whether string s1 is lexicographically
  82&nbsp;# less than, equal to, or greater than string s2.
  83&nbsp;#:end docstring:
  84&nbsp;
  85&nbsp;###;;;autoload
  86&nbsp;function strcmp ()
  87&nbsp;{
  88&nbsp;    [ "$1" = "$2" ] &#38;&#38; return 0
  89&nbsp;
  90&nbsp;    [ "${1}" '&#60;' "${2}" ] &#62; /dev/null &#38;&#38; return -1
  91&nbsp;
  92&nbsp;    return 1
  93&nbsp;}
  94&nbsp;
  95&nbsp;#:docstring strncmp:
  96&nbsp;# Usage: strncmp $s1 $s2 $n
  97&nbsp;# 
  98&nbsp;# Like strcmp, but makes the comparison by examining a maximum of n
  99&nbsp;# characters (n less than or equal to zero yields equality).
 100&nbsp;#:end docstring:
 101&nbsp;
 102&nbsp;###;;;autoload
 103&nbsp;function strncmp ()
 104&nbsp;{
 105&nbsp;    if [ -z "${3}" -o "${3}" -le "0" ]; then
 106&nbsp;       return 0
 107&nbsp;    fi
 108&nbsp;   
 109&nbsp;    if [ ${3} -ge ${#1} -a ${3} -ge ${#2} ]; then
 110&nbsp;       strcmp "$1" "$2"
 111&nbsp;       return $?
 112&nbsp;    else
 113&nbsp;       s1=${1:0:$3}
 114&nbsp;       s2=${2:0:$3}
 115&nbsp;       strcmp $s1 $s2
 116&nbsp;       return $?
 117&nbsp;    fi
 118&nbsp;}
 119&nbsp;
 120&nbsp;#:docstring strlen:
 121&nbsp;# Usage: strlen s
 122&nbsp;#
 123&nbsp;# Strlen returns the number of characters in string literal s.
 124&nbsp;#:end docstring:
 125&nbsp;
 126&nbsp;###;;;autoload
 127&nbsp;function strlen ()
 128&nbsp;{
 129&nbsp;    eval echo "\${#${1}}"
 130&nbsp;    # ==&#62; Returns the length of the value of the variable
 131&nbsp;    # ==&#62; whose name is passed as an argument.
 132&nbsp;}
 133&nbsp;
 134&nbsp;#:docstring strspn:
 135&nbsp;# Usage: strspn $s1 $s2
 136&nbsp;# 
 137&nbsp;# Strspn returns the length of the maximum initial segment of string s1,
 138&nbsp;# which consists entirely of characters from string s2.
 139&nbsp;#:end docstring:
 140&nbsp;
 141&nbsp;###;;;autoload
 142&nbsp;function strspn ()
 143&nbsp;{
 144&nbsp;    # Unsetting IFS allows whitespace to be handled as normal chars. 
 145&nbsp;    local IFS=
 146&nbsp;    local result="${1%%[!${2}]*}"
 147&nbsp; 
 148&nbsp;    echo ${#result}
 149&nbsp;}
 150&nbsp;
 151&nbsp;#:docstring strcspn:
 152&nbsp;# Usage: strcspn $s1 $s2
 153&nbsp;#
 154&nbsp;# Strcspn returns the length of the maximum initial segment of string s1,
 155&nbsp;# which consists entirely of characters not from string s2.
 156&nbsp;#:end docstring:
 157&nbsp;
 158&nbsp;###;;;autoload
 159&nbsp;function strcspn ()
 160&nbsp;{
 161&nbsp;    # Unsetting IFS allows whitspace to be handled as normal chars. 
 162&nbsp;    local IFS=
 163&nbsp;    local result="${1%%[${2}]*}"
 164&nbsp; 
 165&nbsp;    echo ${#result}
 166&nbsp;}
 167&nbsp;
 168&nbsp;#:docstring strstr:
 169&nbsp;# Usage: strstr s1 s2
 170&nbsp;# 
 171&nbsp;# Strstr echoes a substring starting at the first occurrence of string s2 in
 172&nbsp;# string s1, or nothing if s2 does not occur in the string.  If s2 points to
 173&nbsp;# a string of zero length, strstr echoes s1.
 174&nbsp;#:end docstring:
 175&nbsp;
 176&nbsp;###;;;autoload
 177&nbsp;function strstr ()
 178&nbsp;{
 179&nbsp;    # if s2 points to a string of zero length, strstr echoes s1
 180&nbsp;    [ ${#2} -eq 0 ] &#38;&#38; { echo "$1" ; return 0; }
 181&nbsp;
 182&nbsp;    # strstr echoes nothing if s2 does not occur in s1
 183&nbsp;    case "$1" in
 184&nbsp;    *$2*) ;;
 185&nbsp;    *) return 1;;
 186&nbsp;    esac
 187&nbsp;
 188&nbsp;    # use the pattern matching code to strip off the match and everything
 189&nbsp;    # following it
 190&nbsp;    first=${1/$2*/}
 191&nbsp;
 192&nbsp;    # then strip off the first unmatched portion of the string
 193&nbsp;    echo "${1##$first}"
 194&nbsp;}
 195&nbsp;
 196&nbsp;#:docstring strtok:
 197&nbsp;# Usage: strtok s1 s2
 198&nbsp;#
 199&nbsp;# Strtok considers the string s1 to consist of a sequence of zero or more
 200&nbsp;# text tokens separated by spans of one or more characters from the
 201&nbsp;# separator string s2.  The first call (with a non-empty string s1
 202&nbsp;# specified) echoes a string consisting of the first token on stdout. The
 203&nbsp;# function keeps track of its position in the string s1 between separate
 204&nbsp;# calls, so that subsequent calls made with the first argument an empty
 205&nbsp;# string will work through the string immediately following that token.  In
 206&nbsp;# this way subsequent calls will work through the string s1 until no tokens
 207&nbsp;# remain.  The separator string s2 may be different from call to call.
 208&nbsp;# When no token remains in s1, an empty value is echoed on stdout.
 209&nbsp;#:end docstring:
 210&nbsp;
 211&nbsp;###;;;autoload
 212&nbsp;function strtok ()
 213&nbsp;{
 214&nbsp; :
 215&nbsp;}
 216&nbsp;
 217&nbsp;#:docstring strtrunc:
 218&nbsp;# Usage: strtrunc $n $s1 {$s2} {$...}
 219&nbsp;#
 220&nbsp;# Used by many functions like strncmp to truncate arguments for comparison.
 221&nbsp;# Echoes the first n characters of each string s1 s2 ... on stdout. 
 222&nbsp;#:end docstring:
 223&nbsp;
 224&nbsp;###;;;autoload
 225&nbsp;function strtrunc ()
 226&nbsp;{
 227&nbsp;    n=$1 ; shift
 228&nbsp;    for z; do
 229&nbsp;        echo "${z:0:$n}"
 230&nbsp;    done
 231&nbsp;}
 232&nbsp;
 233&nbsp;# provide string
 234&nbsp;
 235&nbsp;# string.bash ends here
 236&nbsp;
 237&nbsp;
 238&nbsp;# ========================================================================== #
 239&nbsp;# ==&#62; Everything below here added by the document author.
 240&nbsp;
 241&nbsp;# ==&#62; Suggested use of this script is to delete everything below here,
 242&nbsp;# ==&#62; and "source" this file into your own scripts.
 243&nbsp;
 244&nbsp;# strcat
 245&nbsp;string0=one
 246&nbsp;string1=two
 247&nbsp;echo
 248&nbsp;echo "Testing \"strcat\" function:"
 249&nbsp;echo "Original \"string0\" = $string0"
 250&nbsp;echo "\"string1\" = $string1"
 251&nbsp;strcat string0 string1
 252&nbsp;echo "New \"string0\" = $string0"
 253&nbsp;echo
 254&nbsp;
 255&nbsp;# strlen
 256&nbsp;echo
 257&nbsp;echo "Testing \"strlen\" function:"
 258&nbsp;str=123456789
 259&nbsp;echo "\"str\" = $str"
 260&nbsp;echo -n "Length of \"str\" = "
 261&nbsp;strlen str
 262&nbsp;echo
 263&nbsp;
 264&nbsp;
 265&nbsp;
 266&nbsp;# Exercise:
 267&nbsp;# --------
 268&nbsp;# Add code to test all the other string functions above.
 269&nbsp;
 270&nbsp;
 271&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>Michael Zick's complex array example uses the <A
HREF="filearchiv.html#MD5SUMREF"
>md5sum</A
> check sum command to encode directory
      information.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="DIRECTORYINFO"
></A
><P
><B
>Example A-20. Directory information</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#! /bin/bash
   2&nbsp;# directory-info.sh
   3&nbsp;# Parses and lists directory information.
   4&nbsp;
   5&nbsp;# NOTE: Change lines 273 and 353 per "README" file.
   6&nbsp;
   7&nbsp;# Michael Zick is the author of this script.
   8&nbsp;# Used here with his permission.
   9&nbsp;
  10&nbsp;# Controls
  11&nbsp;# If overridden by command arguments, they must be in the order:
  12&nbsp;#   Arg1: "Descriptor Directory"
  13&nbsp;#   Arg2: "Exclude Paths"
  14&nbsp;#   Arg3: "Exclude Directories"
  15&nbsp;#
  16&nbsp;# Environment Settings override Defaults.
  17&nbsp;# Command arguments override Environment Settings.
  18&nbsp;
  19&nbsp;# Default location for content addressed file descriptors.
  20&nbsp;MD5UCFS=${1:-${MD5UCFS:-'/tmpfs/ucfs'}}
  21&nbsp;
  22&nbsp;# Directory paths never to list or enter
  23&nbsp;declare -a \
  24&nbsp;  EXCLUDE_PATHS=${2:-${EXCLUDE_PATHS:-'(/proc /dev /devfs /tmpfs)'}}
  25&nbsp;
  26&nbsp;# Directories never to list or enter
  27&nbsp;declare -a \
  28&nbsp;  EXCLUDE_DIRS=${3:-${EXCLUDE_DIRS:-'(ucfs lost+found tmp wtmp)'}}
  29&nbsp;
  30&nbsp;# Files never to list or enter
  31&nbsp;declare -a \
  32&nbsp;  EXCLUDE_FILES=${3:-${EXCLUDE_FILES:-'(core "Name with Spaces")'}}
  33&nbsp;
  34&nbsp;
  35&nbsp;# Here document used as a comment block.
  36&nbsp;: &#60;&#60;LSfieldsDoc
  37&nbsp;# # # # # List Filesystem Directory Information # # # # #
  38&nbsp;#
  39&nbsp;#	ListDirectory "FileGlob" "Field-Array-Name"
  40&nbsp;# or
  41&nbsp;#	ListDirectory -of "FileGlob" "Field-Array-Filename"
  42&nbsp;#	'-of' meaning 'output to filename'
  43&nbsp;# # # # #
  44&nbsp;
  45&nbsp;String format description based on: ls (GNU fileutils) version 4.0.36
  46&nbsp;
  47&nbsp;Produces a line (or more) formatted:
  48&nbsp;inode permissions hard-links owner group ...
  49&nbsp;32736 -rw-------    1 mszick   mszick
  50&nbsp;
  51&nbsp;size    day month date hh:mm:ss year path
  52&nbsp;2756608 Sun Apr 20 08:53:06 2003 /home/mszick/core
  53&nbsp;
  54&nbsp;Unless it is formatted:
  55&nbsp;inode permissions hard-links owner group ...
  56&nbsp;266705 crw-rw----    1    root  uucp
  57&nbsp;
  58&nbsp;major minor day month date hh:mm:ss year path
  59&nbsp;4,  68 Sun Apr 20 09:27:33 2003 /dev/ttyS4
  60&nbsp;NOTE: that pesky comma after the major number
  61&nbsp;
  62&nbsp;NOTE: the 'path' may be multiple fields:
  63&nbsp;/home/mszick/core
  64&nbsp;/proc/982/fd/0 -&#62; /dev/null
  65&nbsp;/proc/982/fd/1 -&#62; /home/mszick/.xsession-errors
  66&nbsp;/proc/982/fd/13 -&#62; /tmp/tmpfZVVOCs (deleted)
  67&nbsp;/proc/982/fd/7 -&#62; /tmp/kde-mszick/ksycoca
  68&nbsp;/proc/982/fd/8 -&#62; socket:[11586]
  69&nbsp;/proc/982/fd/9 -&#62; pipe:[11588]
  70&nbsp;
  71&nbsp;If that isn't enough to keep your parser guessing,
  72&nbsp;either or both of the path components may be relative:
  73&nbsp;../Built-Shared -&#62; Built-Static
  74&nbsp;../linux-2.4.20.tar.bz2 -&#62; ../../../SRCS/linux-2.4.20.tar.bz2
  75&nbsp;
  76&nbsp;The first character of the 11 (10?) character permissions field:
  77&nbsp;'s' Socket
  78&nbsp;'d' Directory
  79&nbsp;'b' Block device
  80&nbsp;'c' Character device
  81&nbsp;'l' Symbolic link
  82&nbsp;NOTE: Hard links not marked - test for identical inode numbers
  83&nbsp;on identical filesystems.
  84&nbsp;All information about hard linked files are shared, except
  85&nbsp;for the names and the name's location in the directory system.
  86&nbsp;NOTE: A "Hard link" is known as a "File Alias" on some systems.
  87&nbsp;'-' An undistingushed file
  88&nbsp;
  89&nbsp;Followed by three groups of letters for: User, Group, Others
  90&nbsp;Character 1: '-' Not readable; 'r' Readable
  91&nbsp;Character 2: '-' Not writable; 'w' Writable
  92&nbsp;Character 3, User and Group: Combined execute and special
  93&nbsp;'-' Not Executable, Not Special
  94&nbsp;'x' Executable, Not Special
  95&nbsp;'s' Executable, Special
  96&nbsp;'S' Not Executable, Special
  97&nbsp;Character 3, Others: Combined execute and sticky (tacky?)
  98&nbsp;'-' Not Executable, Not Tacky
  99&nbsp;'x' Executable, Not Tacky
 100&nbsp;'t' Executable, Tacky
 101&nbsp;'T' Not Executable, Tacky
 102&nbsp;
 103&nbsp;Followed by an access indicator
 104&nbsp;Haven't tested this one, it may be the eleventh character
 105&nbsp;or it may generate another field
 106&nbsp;' ' No alternate access
 107&nbsp;'+' Alternate access
 108&nbsp;LSfieldsDoc
 109&nbsp;
 110&nbsp;
 111&nbsp;ListDirectory()
 112&nbsp;{
 113&nbsp;	local -a T
 114&nbsp;	local -i of=0		# Default return in variable
 115&nbsp;#	OLD_IFS=$IFS		# Using BASH default ' \t\n'
 116&nbsp;
 117&nbsp;	case "$#" in
 118&nbsp;	3)	case "$1" in
 119&nbsp;		-of)	of=1 ; shift ;;
 120&nbsp;		 * )	return 1 ;;
 121&nbsp;		esac ;;
 122&nbsp;	2)	: ;;		# Poor man's "continue"
 123&nbsp;	*)	return 1 ;;
 124&nbsp;	esac
 125&nbsp;
 126&nbsp;	# NOTE: the (ls) command is NOT quoted (")
 127&nbsp;	T=( $(ls --inode --ignore-backups --almost-all --directory \
 128&nbsp;	--full-time --color=none --time=status --sort=none \
 129&nbsp;	--format=long $1) )
 130&nbsp;
 131&nbsp;	case $of in
 132&nbsp;	# Assign T back to the array whose name was passed as $2
 133&nbsp;		0) eval $2=\( \"\$\{T\[@\]\}\" \) ;;
 134&nbsp;	# Write T into filename passed as $2
 135&nbsp;		1) echo "${T[@]}" &#62; "$2" ;;
 136&nbsp;	esac
 137&nbsp;	return 0
 138&nbsp;   }
 139&nbsp;
 140&nbsp;# # # # # Is that string a legal number? # # # # #
 141&nbsp;#
 142&nbsp;#	IsNumber "Var"
 143&nbsp;# # # # # There has to be a better way, sigh...
 144&nbsp;
 145&nbsp;IsNumber()
 146&nbsp;{
 147&nbsp;	local -i int
 148&nbsp;	if [ $# -eq 0 ]
 149&nbsp;	then
 150&nbsp;		return 1
 151&nbsp;	else
 152&nbsp;		(let int=$1)  2&#62;/dev/null
 153&nbsp;		return $?	# Exit status of the let thread
 154&nbsp;	fi
 155&nbsp;}
 156&nbsp;
 157&nbsp;# # # # # Index Filesystem Directory Information # # # # #
 158&nbsp;#
 159&nbsp;#	IndexList "Field-Array-Name" "Index-Array-Name"
 160&nbsp;# or
 161&nbsp;#	IndexList -if Field-Array-Filename Index-Array-Name
 162&nbsp;#	IndexList -of Field-Array-Name Index-Array-Filename
 163&nbsp;#	IndexList -if -of Field-Array-Filename Index-Array-Filename
 164&nbsp;# # # # #
 165&nbsp;
 166&nbsp;: &#60;&#60;IndexListDoc
 167&nbsp;Walk an array of directory fields produced by ListDirectory
 168&nbsp;
 169&nbsp;Having suppressed the line breaks in an otherwise line oriented
 170&nbsp;report, build an index to the array element which starts each line.
 171&nbsp;
 172&nbsp;Each line gets two index entries, the first element of each line
 173&nbsp;(inode) and the element that holds the pathname of the file.
 174&nbsp;
 175&nbsp;The first index entry pair (Line-Number==0) are informational:
 176&nbsp;Index-Array-Name[0] : Number of "Lines" indexed
 177&nbsp;Index-Array-Name[1] : "Current Line" pointer into Index-Array-Name
 178&nbsp;
 179&nbsp;The following index pairs (if any) hold element indexes into
 180&nbsp;the Field-Array-Name per:
 181&nbsp;Index-Array-Name[Line-Number * 2] : The "inode" field element.
 182&nbsp;NOTE: This distance may be either +11 or +12 elements.
 183&nbsp;Index-Array-Name[(Line-Number * 2) + 1] : The "pathname" element.
 184&nbsp;NOTE: This distance may be a variable number of elements.
 185&nbsp;Next line index pair for Line-Number+1.
 186&nbsp;IndexListDoc
 187&nbsp;
 188&nbsp;
 189&nbsp;
 190&nbsp;IndexList()
 191&nbsp;{
 192&nbsp;	local -a LIST			# Local of listname passed
 193&nbsp;	local -a -i INDEX=( 0 0 )	# Local of index to return
 194&nbsp;	local -i Lidx Lcnt
 195&nbsp;	local -i if=0 of=0		# Default to variable names
 196&nbsp;
 197&nbsp;	case "$#" in			# Simplistic option testing
 198&nbsp;		0) return 1 ;;
 199&nbsp;		1) return 1 ;;
 200&nbsp;		2) : ;;			# Poor man's continue
 201&nbsp;		3) case "$1" in
 202&nbsp;			-if) if=1 ;;
 203&nbsp;			-of) of=1 ;;
 204&nbsp;			 * ) return 1 ;;
 205&nbsp;		   esac ; shift ;;
 206&nbsp;		4) if=1 ; of=1 ; shift ; shift ;;
 207&nbsp;		*) return 1
 208&nbsp;	esac
 209&nbsp;
 210&nbsp;	# Make local copy of list
 211&nbsp;	case "$if" in
 212&nbsp;		0) eval LIST=\( \"\$\{$1\[@\]\}\" \) ;;
 213&nbsp;		1) LIST=( $(cat $1) ) ;;
 214&nbsp;	esac
 215&nbsp;
 216&nbsp;	# Grok (grope?) the array
 217&nbsp;	Lcnt=${#LIST[@]}
 218&nbsp;	Lidx=0
 219&nbsp;	until (( Lidx &#62;= Lcnt ))
 220&nbsp;	do
 221&nbsp;	if IsNumber ${LIST[$Lidx]}
 222&nbsp;	then
 223&nbsp;		local -i inode name
 224&nbsp;		local ft
 225&nbsp;		inode=Lidx
 226&nbsp;		local m=${LIST[$Lidx+2]}	# Hard Links field
 227&nbsp;		ft=${LIST[$Lidx+1]:0:1} 	# Fast-Stat
 228&nbsp;		case $ft in
 229&nbsp;		b)	((Lidx+=12)) ;;		# Block device
 230&nbsp;		c)	((Lidx+=12)) ;;		# Character device
 231&nbsp;		*)	((Lidx+=11)) ;;		# Anything else
 232&nbsp;		esac
 233&nbsp;		name=Lidx
 234&nbsp;		case $ft in
 235&nbsp;		-)	((Lidx+=1)) ;;		# The easy one
 236&nbsp;		b)	((Lidx+=1)) ;;		# Block device
 237&nbsp;		c)	((Lidx+=1)) ;;		# Character device
 238&nbsp;		d)	((Lidx+=1)) ;;		# The other easy one
 239&nbsp;		l)	((Lidx+=3)) ;;		# At LEAST two more fields
 240&nbsp;#  A little more elegance here would handle pipes,
 241&nbsp;#+ sockets, deleted files - later.
 242&nbsp;		*)	until IsNumber ${LIST[$Lidx]} || ((Lidx &#62;= Lcnt))
 243&nbsp;			do
 244&nbsp;				((Lidx+=1))
 245&nbsp;			done
 246&nbsp;			;;			# Not required
 247&nbsp;		esac
 248&nbsp;		INDEX[${#INDEX[*]}]=$inode
 249&nbsp;		INDEX[${#INDEX[*]}]=$name
 250&nbsp;		INDEX[0]=${INDEX[0]}+1		# One more "line" found
 251&nbsp;# echo "Line: ${INDEX[0]} Type: $ft Links: $m Inode: \
 252&nbsp;# ${LIST[$inode]} Name: ${LIST[$name]}"
 253&nbsp;
 254&nbsp;	else
 255&nbsp;		((Lidx+=1))
 256&nbsp;	fi
 257&nbsp;	done
 258&nbsp;	case "$of" in
 259&nbsp;		0) eval $2=\( \"\$\{INDEX\[@\]\}\" \) ;;
 260&nbsp;		1) echo "${INDEX[@]}" &#62; "$2" ;;
 261&nbsp;	esac
 262&nbsp;	return 0				# What could go wrong?
 263&nbsp;}
 264&nbsp;
 265&nbsp;# # # # # Content Identify File # # # # #
 266&nbsp;#
 267&nbsp;#	DigestFile Input-Array-Name Digest-Array-Name
 268&nbsp;# or
 269&nbsp;#	DigestFile -if Input-FileName Digest-Array-Name
 270&nbsp;# # # # #
 271&nbsp;
 272&nbsp;# Here document used as a comment block.
 273&nbsp;: &#60;&#60;DigestFilesDoc
 274&nbsp;
 275&nbsp;The key (no pun intended) to a Unified Content File System (UCFS)
 276&nbsp;is to distinguish the files in the system based on their content.
 277&nbsp;Distinguishing files by their name is just, so, 20th Century.
 278&nbsp;
 279&nbsp;The content is distinguished by computing a checksum of that content.
 280&nbsp;This version uses the md5sum program to generate a 128 bit checksum
 281&nbsp;representative of the file's contents.
 282&nbsp;There is a chance that two files having different content might
 283&nbsp;generate the same checksum using md5sum (or any checksum).  Should
 284&nbsp;that become a problem, then the use of md5sum can be replace by a
 285&nbsp;cyrptographic signature.  But until then...
 286&nbsp;
 287&nbsp;The md5sum program is documented as outputting three fields (and it
 288&nbsp;does), but when read it appears as two fields (array elements).  This
 289&nbsp;is caused by the lack of whitespace between the second and third field.
 290&nbsp;So this function gropes the md5sum output and returns:
 291&nbsp;	[0]	32 character checksum in hexidecimal (UCFS filename)
 292&nbsp;	[1]	Single character: ' ' text file, '*' binary file
 293&nbsp;	[2]	Filesystem (20th Century Style) name
 294&nbsp;	Note: That name may be the character '-' indicating STDIN read.
 295&nbsp;
 296&nbsp;DigestFilesDoc
 297&nbsp;
 298&nbsp;
 299&nbsp;
 300&nbsp;DigestFile()
 301&nbsp;{
 302&nbsp;	local if=0		# Default, variable name
 303&nbsp;	local -a T1 T2
 304&nbsp;
 305&nbsp;	case "$#" in
 306&nbsp;	3)	case "$1" in
 307&nbsp;		-if)	if=1 ; shift ;;
 308&nbsp;		 * )	return 1 ;;
 309&nbsp;		esac ;;
 310&nbsp;	2)	: ;;		# Poor man's "continue"
 311&nbsp;	*)	return 1 ;;
 312&nbsp;	esac
 313&nbsp;
 314&nbsp;	case $if in
 315&nbsp;	0) eval T1=\( \"\$\{$1\[@\]\}\" \)
 316&nbsp;	   T2=( $(echo ${T1[@]} | md5sum -) )
 317&nbsp;	   ;;
 318&nbsp;	1) T2=( $(md5sum $1) )
 319&nbsp;	   ;;
 320&nbsp;	esac
 321&nbsp;
 322&nbsp;	case ${#T2[@]} in
 323&nbsp;	0) return 1 ;;
 324&nbsp;	1) return 1 ;;
 325&nbsp;	2) case ${T2[1]:0:1} in		# SanScrit-2.0.5
 326&nbsp;	   \*) T2[${#T2[@]}]=${T2[1]:1}
 327&nbsp;	       T2[1]=\*
 328&nbsp;	       ;;
 329&nbsp;	    *) T2[${#T2[@]}]=${T2[1]}
 330&nbsp;	       T2[1]=" "
 331&nbsp;	       ;;
 332&nbsp;	   esac
 333&nbsp;	   ;;
 334&nbsp;	3) : ;; # Assume it worked
 335&nbsp;	*) return 1 ;;
 336&nbsp;	esac
 337&nbsp;
 338&nbsp;	local -i len=${#T2[0]}
 339&nbsp;	if [ $len -ne 32 ] ; then return 1 ; fi
 340&nbsp;	eval $2=\( \"\$\{T2\[@\]\}\" \)
 341&nbsp;}
 342&nbsp;
 343&nbsp;# # # # # Locate File # # # # #
 344&nbsp;#
 345&nbsp;#	LocateFile [-l] FileName Location-Array-Name
 346&nbsp;# or
 347&nbsp;#	LocateFile [-l] -of FileName Location-Array-FileName
 348&nbsp;# # # # #
 349&nbsp;
 350&nbsp;# A file location is Filesystem-id and inode-number
 351&nbsp;
 352&nbsp;# Here document used as a comment block.
 353&nbsp;: &#60;&#60;StatFieldsDoc
 354&nbsp;	Based on stat, version 2.2
 355&nbsp;	stat -t and stat -lt fields
 356&nbsp;	[0]	name
 357&nbsp;	[1]	Total size
 358&nbsp;		File - number of bytes
 359&nbsp;		Symbolic link - string length of pathname
 360&nbsp;	[2]	Number of (512 byte) blocks allocated
 361&nbsp;	[3]	File type and Access rights (hex)
 362&nbsp;	[4]	User ID of owner
 363&nbsp;	[5]	Group ID of owner
 364&nbsp;	[6]	Device number
 365&nbsp;	[7]	Inode number
 366&nbsp;	[8]	Number of hard links
 367&nbsp;	[9]	Device type (if inode device) Major
 368&nbsp;	[10]	Device type (if inode device) Minor
 369&nbsp;	[11]	Time of last access
 370&nbsp;		May be disabled in 'mount' with noatime
 371&nbsp;		atime of files changed by exec, read, pipe, utime, mknod (mmap?)
 372&nbsp;		atime of directories changed by addition/deletion of files
 373&nbsp;	[12]	Time of last modification
 374&nbsp;		mtime of files changed by write, truncate, utime, mknod
 375&nbsp;		mtime of directories changed by addtition/deletion of files
 376&nbsp;	[13]	Time of last change
 377&nbsp;		ctime reflects time of changed inode information (owner, group
 378&nbsp;		permissions, link count
 379&nbsp;-*-*- Per:
 380&nbsp;	Return code: 0
 381&nbsp;	Size of array: 14
 382&nbsp;	Contents of array
 383&nbsp;	Element 0: /home/mszick
 384&nbsp;	Element 1: 4096
 385&nbsp;	Element 2: 8
 386&nbsp;	Element 3: 41e8
 387&nbsp;	Element 4: 500
 388&nbsp;	Element 5: 500
 389&nbsp;	Element 6: 303
 390&nbsp;	Element 7: 32385
 391&nbsp;	Element 8: 22
 392&nbsp;	Element 9: 0
 393&nbsp;	Element 10: 0
 394&nbsp;	Element 11: 1051221030
 395&nbsp;	Element 12: 1051214068
 396&nbsp;	Element 13: 1051214068
 397&nbsp;
 398&nbsp;	For a link in the form of linkname -&#62; realname
 399&nbsp;	stat -t  linkname returns the linkname (link) information
 400&nbsp;	stat -lt linkname returns the realname information
 401&nbsp;
 402&nbsp;	stat -tf and stat -ltf fields
 403&nbsp;	[0]	name
 404&nbsp;	[1]	ID-0?		# Maybe someday, but Linux stat structure
 405&nbsp;	[2]	ID-0?		# does not have either LABEL nor UUID
 406&nbsp;				# fields, currently information must come
 407&nbsp;				# from file-system specific utilities
 408&nbsp;	These will be munged into:
 409&nbsp;	[1]	UUID if possible
 410&nbsp;	[2]	Volume Label if possible
 411&nbsp;	Note: 'mount -l' does return the label and could return the UUID
 412&nbsp;
 413&nbsp;	[3]	Maximum length of filenames
 414&nbsp;	[4]	Filesystem type
 415&nbsp;	[5]	Total blocks in the filesystem
 416&nbsp;	[6]	Free blocks
 417&nbsp;	[7]	Free blocks for non-root user(s)
 418&nbsp;	[8]	Block size of the filesystem
 419&nbsp;	[9]	Total inodes
 420&nbsp;	[10]	Free inodes
 421&nbsp;
 422&nbsp;-*-*- Per:
 423&nbsp;	Return code: 0
 424&nbsp;	Size of array: 11
 425&nbsp;	Contents of array
 426&nbsp;	Element 0: /home/mszick
 427&nbsp;	Element 1: 0
 428&nbsp;	Element 2: 0
 429&nbsp;	Element 3: 255
 430&nbsp;	Element 4: ef53
 431&nbsp;	Element 5: 2581445
 432&nbsp;	Element 6: 2277180
 433&nbsp;	Element 7: 2146050
 434&nbsp;	Element 8: 4096
 435&nbsp;	Element 9: 1311552
 436&nbsp;	Element 10: 1276425
 437&nbsp;
 438&nbsp;StatFieldsDoc
 439&nbsp;
 440&nbsp;
 441&nbsp;#	LocateFile [-l] FileName Location-Array-Name
 442&nbsp;#	LocateFile [-l] -of FileName Location-Array-FileName
 443&nbsp;
 444&nbsp;LocateFile()
 445&nbsp;{
 446&nbsp;	local -a LOC LOC1 LOC2
 447&nbsp;	local lk="" of=0
 448&nbsp;
 449&nbsp;	case "$#" in
 450&nbsp;	0) return 1 ;;
 451&nbsp;	1) return 1 ;;
 452&nbsp;	2) : ;;
 453&nbsp;	*) while (( "$#" &#62; 2 ))
 454&nbsp;	   do
 455&nbsp;	      case "$1" in
 456&nbsp;	       -l) lk=-1 ;;
 457&nbsp;	      -of) of=1 ;;
 458&nbsp;	        *) return 1 ;;
 459&nbsp;	      esac
 460&nbsp;	   shift
 461&nbsp;           done ;;
 462&nbsp;	esac
 463&nbsp;
 464&nbsp;# More Sanscrit-2.0.5
 465&nbsp;      # LOC1=( $(stat -t $lk $1) )
 466&nbsp;      # LOC2=( $(stat -tf $lk $1) )
 467&nbsp;      # Uncomment above two lines if system has "stat" command installed.
 468&nbsp;	LOC=( ${LOC1[@]:0:1} ${LOC1[@]:3:11}
 469&nbsp;	      ${LOC2[@]:1:2} ${LOC2[@]:4:1} )
 470&nbsp;
 471&nbsp;	case "$of" in
 472&nbsp;		0) eval $2=\( \"\$\{LOC\[@\]\}\" \) ;;
 473&nbsp;		1) echo "${LOC[@]}" &#62; "$2" ;;
 474&nbsp;	esac
 475&nbsp;	return 0
 476&nbsp;# Which yields (if you are lucky, and have "stat" installed)
 477&nbsp;# -*-*- Location Discriptor -*-*-
 478&nbsp;#	Return code: 0
 479&nbsp;#	Size of array: 15
 480&nbsp;#	Contents of array
 481&nbsp;#	Element 0: /home/mszick		20th Century name
 482&nbsp;#	Element 1: 41e8			Type and Permissions
 483&nbsp;#	Element 2: 500			User
 484&nbsp;#	Element 3: 500			Group
 485&nbsp;#	Element 4: 303			Device
 486&nbsp;#	Element 5: 32385		inode
 487&nbsp;#	Element 6: 22			Link count
 488&nbsp;#	Element 7: 0			Device Major
 489&nbsp;#	Element 8: 0			Device Minor
 490&nbsp;#	Element 9: 1051224608		Last Access
 491&nbsp;#	Element 10: 1051214068		Last Modify
 492&nbsp;#	Element 11: 1051214068		Last Status
 493&nbsp;#	Element 12: 0			UUID (to be)
 494&nbsp;#	Element 13: 0			Volume Label (to be)
 495&nbsp;#	Element 14: ef53		Filesystem type
 496&nbsp;}
 497&nbsp;
 498&nbsp;
 499&nbsp;
 500&nbsp;# And then there was some test code
 501&nbsp;
 502&nbsp;ListArray() # ListArray Name
 503&nbsp;{
 504&nbsp;	local -a Ta
 505&nbsp;
 506&nbsp;	eval Ta=\( \"\$\{$1\[@\]\}\" \)
 507&nbsp;	echo
 508&nbsp;	echo "-*-*- List of Array -*-*-"
 509&nbsp;	echo "Size of array $1: ${#Ta[*]}"
 510&nbsp;	echo "Contents of array $1:"
 511&nbsp;	for (( i=0 ; i&#60;${#Ta[*]} ; i++ ))
 512&nbsp;	do
 513&nbsp;	    echo -e "\tElement $i: ${Ta[$i]}"
 514&nbsp;	done
 515&nbsp;	return 0
 516&nbsp;}
 517&nbsp;
 518&nbsp;declare -a CUR_DIR
 519&nbsp;# For small arrays
 520&nbsp;ListDirectory "${PWD}" CUR_DIR
 521&nbsp;ListArray CUR_DIR
 522&nbsp;
 523&nbsp;declare -a DIR_DIG
 524&nbsp;DigestFile CUR_DIR DIR_DIG
 525&nbsp;echo "The new \"name\" (checksum) for ${CUR_DIR[9]} is ${DIR_DIG[0]}"
 526&nbsp;
 527&nbsp;declare -a DIR_ENT
 528&nbsp;# BIG_DIR # For really big arrays - use a temporary file in ramdisk
 529&nbsp;# BIG-DIR # ListDirectory -of "${CUR_DIR[11]}/*" "/tmpfs/junk2"
 530&nbsp;ListDirectory "${CUR_DIR[11]}/*" DIR_ENT
 531&nbsp;
 532&nbsp;declare -a DIR_IDX
 533&nbsp;# BIG-DIR # IndexList -if "/tmpfs/junk2" DIR_IDX
 534&nbsp;IndexList DIR_ENT DIR_IDX
 535&nbsp;
 536&nbsp;declare -a IDX_DIG
 537&nbsp;# BIG-DIR # DIR_ENT=( $(cat /tmpfs/junk2) )
 538&nbsp;# BIG-DIR # DigestFile -if /tmpfs/junk2 IDX_DIG
 539&nbsp;DigestFile DIR_ENT IDX_DIG
 540&nbsp;# Small (should) be able to parallize IndexList &#38; DigestFile
 541&nbsp;# Large (should) be able to parallize IndexList &#38; DigestFile &#38; the assignment
 542&nbsp;echo "The \"name\" (checksum) for the contents of ${PWD} is ${IDX_DIG[0]}"
 543&nbsp;
 544&nbsp;declare -a FILE_LOC
 545&nbsp;LocateFile ${PWD} FILE_LOC
 546&nbsp;ListArray FILE_LOC
 547&nbsp;
 548&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>Stphane Chazelas demonstrates object-oriented programming in a
      Bash script.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="OBJORIENTED"
></A
><P
><B
>Example A-21. Object-oriented database</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# obj-oriented.sh: Object-oriented programming in a shell script.
   3&nbsp;# Script by Stephane Chazelas.
   4&nbsp;
   5&nbsp;#  Important Note:
   6&nbsp;#  --------- ----
   7&nbsp;#  If running this script under version 3 or later of Bash,
   8&nbsp;#+ replace all periods in function names with a "legal" character,
   9&nbsp;#+ for example, an underscore.
  10&nbsp;
  11&nbsp;
  12&nbsp;person.new()        # Looks almost like a class declaration in C++.
  13&nbsp;{
  14&nbsp;  local obj_name=$1 name=$2 firstname=$3 birthdate=$4
  15&nbsp;
  16&nbsp;  eval "$obj_name.set_name() {
  17&nbsp;          eval \"$obj_name.get_name() {
  18&nbsp;                   echo \$1
  19&nbsp;                 }\"
  20&nbsp;        }"
  21&nbsp;
  22&nbsp;  eval "$obj_name.set_firstname() {
  23&nbsp;          eval \"$obj_name.get_firstname() {
  24&nbsp;                   echo \$1
  25&nbsp;                 }\"
  26&nbsp;        }"
  27&nbsp;
  28&nbsp;  eval "$obj_name.set_birthdate() {
  29&nbsp;          eval \"$obj_name.get_birthdate() {
  30&nbsp;            echo \$1
  31&nbsp;          }\"
  32&nbsp;          eval \"$obj_name.show_birthdate() {
  33&nbsp;            echo \$(date -d \"1/1/1970 0:0:\$1 GMT\")
  34&nbsp;          }\"
  35&nbsp;          eval \"$obj_name.get_age() {
  36&nbsp;            echo \$(( (\$(date +%s) - \$1) / 3600 / 24 / 365 ))
  37&nbsp;          }\"
  38&nbsp;        }"
  39&nbsp;
  40&nbsp;  $obj_name.set_name $name
  41&nbsp;  $obj_name.set_firstname $firstname
  42&nbsp;  $obj_name.set_birthdate $birthdate
  43&nbsp;}
  44&nbsp;
  45&nbsp;echo
  46&nbsp;
  47&nbsp;person.new self Bozeman Bozo 101272413
  48&nbsp;# Create an instance of "person.new" (actually passing args to the function).
  49&nbsp;
  50&nbsp;self.get_firstname       #   Bozo
  51&nbsp;self.get_name            #   Bozeman
  52&nbsp;self.get_age             #   28
  53&nbsp;self.get_birthdate       #   101272413
  54&nbsp;self.show_birthdate      #   Sat Mar 17 20:13:33 MST 1973
  55&nbsp;
  56&nbsp;echo
  57&nbsp;
  58&nbsp;#  typeset -f
  59&nbsp;#+ to see the created functions (careful, it scrolls off the page).
  60&nbsp;
  61&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>Mariusz Gniazdowski contributed a <A
HREF="internal.html#HASHREF"
>hash</A
>
      library for use in scripts.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="HASHLIB"
></A
><P
><B
>Example A-22. Library of hash functions</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;# Hash:
   2&nbsp;# Hash function library
   3&nbsp;# Author: Mariusz Gniazdowski &#60;mgniazd-at-gmail.com&#62;
   4&nbsp;# Date: 2005-04-07
   5&nbsp;
   6&nbsp;# Functions making emulating hashes in Bash a little less painful.
   7&nbsp;
   8&nbsp;
   9&nbsp;#    Limitations:
  10&nbsp;#  * Only global variables are supported.
  11&nbsp;#  * Each hash instance generates one global variable per value.
  12&nbsp;#  * Variable names collisions are possible
  13&nbsp;#+   if you define variable like __hash__hashname_key
  14&nbsp;#  * Keys must use chars that can be part of a Bash variable name
  15&nbsp;#+   (no dashes, periods, etc.).
  16&nbsp;#  * The hash is created as a variable:
  17&nbsp;#    ... hashname_keyname
  18&nbsp;#    So if somone will create hashes like:
  19&nbsp;#      myhash_ + mykey = myhash__mykey
  20&nbsp;#      myhash + _mykey = myhash__mykey
  21&nbsp;#    Then there will be a collision.
  22&nbsp;#    (This should not pose a major problem.)
  23&nbsp;
  24&nbsp;
  25&nbsp;Hash_config_varname_prefix=__hash__
  26&nbsp;
  27&nbsp;
  28&nbsp;# Emulates:  hash[key]=value
  29&nbsp;#
  30&nbsp;# Params:
  31&nbsp;# 1 - hash
  32&nbsp;# 2 - key
  33&nbsp;# 3 - value
  34&nbsp;function hash_set {
  35&nbsp;	eval "${Hash_config_varname_prefix}${1}_${2}=\"${3}\""
  36&nbsp;}
  37&nbsp;
  38&nbsp;
  39&nbsp;# Emulates:  value=hash[key]
  40&nbsp;#
  41&nbsp;# Params:
  42&nbsp;# 1 - hash
  43&nbsp;# 2 - key
  44&nbsp;# 3 - value (name of global variable to set)
  45&nbsp;function hash_get_into {
  46&nbsp;	eval "$3=\"\$${Hash_config_varname_prefix}${1}_${2}\""
  47&nbsp;}
  48&nbsp;
  49&nbsp;
  50&nbsp;# Emulates:  echo hash[key]
  51&nbsp;#
  52&nbsp;# Params:
  53&nbsp;# 1 - hash
  54&nbsp;# 2 - key
  55&nbsp;# 3 - echo params (like -n, for example)
  56&nbsp;function hash_echo {
  57&nbsp;	eval "echo $3 \"\$${Hash_config_varname_prefix}${1}_${2}\""
  58&nbsp;}
  59&nbsp;
  60&nbsp;
  61&nbsp;# Emulates:  hash1[key1]=hash2[key2]
  62&nbsp;#
  63&nbsp;# Params:
  64&nbsp;# 1 - hash1
  65&nbsp;# 2 - key1
  66&nbsp;# 3 - hash2
  67&nbsp;# 4 - key2
  68&nbsp;function hash_copy {
  69&nbsp;eval "${Hash_config_varname_prefix}${1}_${2}\
  70&nbsp;=\"\$${Hash_config_varname_prefix}${3}_${4}\""
  71&nbsp;}
  72&nbsp;
  73&nbsp;
  74&nbsp;# Emulates:  hash[keyN-1]=hash[key2]=...hash[key1]
  75&nbsp;#
  76&nbsp;# Copies first key to rest of keys.
  77&nbsp;#
  78&nbsp;# Params:
  79&nbsp;# 1 - hash1
  80&nbsp;# 2 - key1
  81&nbsp;# 3 - key2
  82&nbsp;# . . .
  83&nbsp;# N - keyN
  84&nbsp;function hash_dup {
  85&nbsp;  local hashName="$1" keyName="$2"
  86&nbsp;  shift 2
  87&nbsp;  until [ ${#} -le 0 ]; do
  88&nbsp;    eval "${Hash_config_varname_prefix}${hashName}_${1}\
  89&nbsp;=\"\$${Hash_config_varname_prefix}${hashName}_${keyName}\""
  90&nbsp;  shift;
  91&nbsp;  done;
  92&nbsp;}
  93&nbsp;
  94&nbsp;
  95&nbsp;# Emulates:  unset hash[key]
  96&nbsp;#
  97&nbsp;# Params:
  98&nbsp;# 1 - hash
  99&nbsp;# 2 - key
 100&nbsp;function hash_unset {
 101&nbsp;	eval "unset ${Hash_config_varname_prefix}${1}_${2}"
 102&nbsp;}
 103&nbsp;
 104&nbsp;
 105&nbsp;# Emulates something similar to:  ref=&#38;hash[key]
 106&nbsp;#
 107&nbsp;# The reference is name of the variable in which value is held.
 108&nbsp;#
 109&nbsp;# Params:
 110&nbsp;# 1 - hash
 111&nbsp;# 2 - key
 112&nbsp;# 3 - ref - Name of global variable to set.
 113&nbsp;function hash_get_ref_into {
 114&nbsp;	eval "$3=\"${Hash_config_varname_prefix}${1}_${2}\""
 115&nbsp;}
 116&nbsp;
 117&nbsp;
 118&nbsp;# Emulates something similar to:  echo &#38;hash[key]
 119&nbsp;#
 120&nbsp;# That reference is name of variable in which value is held.
 121&nbsp;#
 122&nbsp;# Params:
 123&nbsp;# 1 - hash
 124&nbsp;# 2 - key
 125&nbsp;# 3 - echo params (like -n for example)
 126&nbsp;function hash_echo_ref {
 127&nbsp;	eval "echo $3 \"${Hash_config_varname_prefix}${1}_${2}\""
 128&nbsp;}
 129&nbsp;
 130&nbsp;
 131&nbsp;
 132&nbsp;# Emulates something similar to:  $$hash[key](param1, param2, ...)
 133&nbsp;#
 134&nbsp;# Params:
 135&nbsp;# 1 - hash
 136&nbsp;# 2 - key
 137&nbsp;# 3,4, ... - Function parameters
 138&nbsp;function hash_call {
 139&nbsp;  local hash key
 140&nbsp;  hash=$1
 141&nbsp;  key=$2
 142&nbsp;  shift 2
 143&nbsp;  eval "eval \"\$${Hash_config_varname_prefix}${hash}_${key} \\\"\\\$@\\\"\""
 144&nbsp;}
 145&nbsp;
 146&nbsp;
 147&nbsp;# Emulates something similar to:  isset(hash[key]) or hash[key]==NULL
 148&nbsp;#
 149&nbsp;# Params:
 150&nbsp;# 1 - hash
 151&nbsp;# 2 - key
 152&nbsp;# Returns:
 153&nbsp;# 0 - there is such key
 154&nbsp;# 1 - there is no such key
 155&nbsp;function hash_is_set {
 156&nbsp;  eval "if [[ \"\${${Hash_config_varname_prefix}${1}_${2}-a}\" = \"a\" &#38;&#38; 
 157&nbsp;  \"\${${Hash_config_varname_prefix}${1}_${2}-b}\" = \"b\" ]]
 158&nbsp;    then return 1; else return 0; fi"
 159&nbsp;}
 160&nbsp;
 161&nbsp;
 162&nbsp;# Emulates something similar to:
 163&nbsp;#   foreach($hash as $key =&#62; $value) { fun($key,$value); }
 164&nbsp;#
 165&nbsp;# It is possible to write different variations of this function.
 166&nbsp;# Here we use a function call to make it as "generic" as possible.
 167&nbsp;#
 168&nbsp;# Params:
 169&nbsp;# 1 - hash
 170&nbsp;# 2 - function name
 171&nbsp;function hash_foreach {
 172&nbsp;  local keyname oldIFS="$IFS"
 173&nbsp;  IFS=' '
 174&nbsp;  for i in $(eval "echo \${!${Hash_config_varname_prefix}${1}_*}"); do
 175&nbsp;    keyname=$(eval "echo \${i##${Hash_config_varname_prefix}${1}_}")
 176&nbsp;    eval "$2 $keyname \"\$$i\""
 177&nbsp;  done
 178&nbsp;IFS="$oldIFS"
 179&nbsp;}
 180&nbsp;
 181&nbsp;#  NOTE: In lines 103 and 116, ampersand changed.
 182&nbsp;#  But, it doesn't matter, because these are comment lines anyhow.</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>Here is an example script using the foregoing hash library.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="HASHEXAMPLE"
></A
><P
><B
>Example A-23. Colorizing text using hash functions</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# hash-example.sh: Colorizing text.
   3&nbsp;# Author: Mariusz Gniazdowski &#60;mgniazd-at-gmail.com&#62;
   4&nbsp;
   5&nbsp;. Hash.lib      # Load the library of functions.
   6&nbsp;
   7&nbsp;hash_set colors red          "\033[0;31m"
   8&nbsp;hash_set colors blue         "\033[0;34m"
   9&nbsp;hash_set colors light_blue   "\033[1;34m"
  10&nbsp;hash_set colors light_red    "\033[1;31m"
  11&nbsp;hash_set colors cyan         "\033[0;36m"
  12&nbsp;hash_set colors light_green  "\033[1;32m"
  13&nbsp;hash_set colors light_gray   "\033[0;37m"
  14&nbsp;hash_set colors green        "\033[0;32m"
  15&nbsp;hash_set colors yellow       "\033[1;33m"
  16&nbsp;hash_set colors light_purple "\033[1;35m"
  17&nbsp;hash_set colors purple       "\033[0;35m"
  18&nbsp;hash_set colors reset_color  "\033[0;00m"
  19&nbsp;
  20&nbsp;
  21&nbsp;# $1 - keyname
  22&nbsp;# $2 - value
  23&nbsp;try_colors() {
  24&nbsp;	echo -en "$2"
  25&nbsp;	echo "This line is $1."
  26&nbsp;}
  27&nbsp;hash_foreach colors try_colors
  28&nbsp;hash_echo colors reset_color -en
  29&nbsp;
  30&nbsp;echo -e '\nLet us overwrite some colors with yellow.\n'
  31&nbsp;# It's hard to read yellow text on some terminals.
  32&nbsp;hash_dup colors yellow   red light_green blue green light_gray cyan
  33&nbsp;hash_foreach colors try_colors
  34&nbsp;hash_echo colors reset_color -en
  35&nbsp;
  36&nbsp;echo -e '\nLet us delete them and try colors once more . . .\n'
  37&nbsp;
  38&nbsp;for i in red light_green blue green light_gray cyan; do
  39&nbsp;	hash_unset colors $i
  40&nbsp;done
  41&nbsp;hash_foreach colors try_colors
  42&nbsp;hash_echo colors reset_color -en
  43&nbsp;
  44&nbsp;hash_set other txt "Other examples . . ."
  45&nbsp;hash_echo other txt
  46&nbsp;hash_get_into other txt text
  47&nbsp;echo $text
  48&nbsp;
  49&nbsp;hash_set other my_fun try_colors
  50&nbsp;hash_call other my_fun   purple "`hash_echo colors purple`"
  51&nbsp;hash_echo colors reset_color -en
  52&nbsp;
  53&nbsp;echo; echo "Back to normal?"; echo
  54&nbsp;
  55&nbsp;exit $?
  56&nbsp;
  57&nbsp;#  On some terminals, the "light" colors print in bold,
  58&nbsp;#  and end up looking darker than the normal ones.
  59&nbsp;#  Why is this?
  60&nbsp;</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
><A
NAME="HASHEX2_0"
></A
>An example illustrating the mechanics
      of hashing, but from a different point of view.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="HASHEX2"
></A
><P
><B
>Example A-24. More on hash functions</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# $Id: ha.sh,v 1.2 2005/04/21 23:24:26 oliver Exp $
   3&nbsp;# Copyright 2005 Oliver Beckstein
   4&nbsp;# Released under the GNU Public License
   5&nbsp;# Author of script granted permission for inclusion in ABS Guide.
   6&nbsp;# (Thank you!)
   7&nbsp;
   8&nbsp;#----------------------------------------------------------------
   9&nbsp;# pseudo hash based on indirect parameter expansion
  10&nbsp;# API: access through functions:
  11&nbsp;# 
  12&nbsp;# create the hash:
  13&nbsp;#  
  14&nbsp;#      newhash Lovers
  15&nbsp;#
  16&nbsp;# add entries (note single quotes for spaces)
  17&nbsp;#    
  18&nbsp;#      addhash Lovers Tristan Isolde
  19&nbsp;#      addhash Lovers 'Romeo Montague' 'Juliet Capulet'
  20&nbsp;#
  21&nbsp;# access value by key
  22&nbsp;#
  23&nbsp;#      gethash Lovers Tristan   ----&#62;  Isolde
  24&nbsp;#
  25&nbsp;# show all keys
  26&nbsp;#
  27&nbsp;#      keyshash Lovers         ----&#62; 'Tristan'  'Romeo Montague'
  28&nbsp;#
  29&nbsp;#
  30&nbsp;# Convention: instead of perls' foo{bar} = boing' syntax,
  31&nbsp;# use
  32&nbsp;#       '_foo_bar=boing' (two underscores, no spaces)
  33&nbsp;#
  34&nbsp;# 1) store key   in _NAME_keys[]
  35&nbsp;# 2) store value in _NAME_values[] using the same integer index
  36&nbsp;# The integer index for the last entry is _NAME_ptr
  37&nbsp;#
  38&nbsp;# NOTE: No error or sanity checks, just bare bones.
  39&nbsp;
  40&nbsp;
  41&nbsp;function _inihash () {
  42&nbsp;    # private function
  43&nbsp;    # call at the beginning of each procedure
  44&nbsp;    # defines: _keys _values _ptr
  45&nbsp;    #
  46&nbsp;    # Usage: _inihash NAME
  47&nbsp;    local name=$1
  48&nbsp;    _keys=_${name}_keys
  49&nbsp;    _values=_${name}_values
  50&nbsp;    _ptr=_${name}_ptr
  51&nbsp;}
  52&nbsp;
  53&nbsp;function newhash () {
  54&nbsp;    # Usage: newhash NAME
  55&nbsp;    #        NAME should not contain spaces or dots.
  56&nbsp;    #        Actually: it must be a legal name for a Bash variable.
  57&nbsp;    # We rely on Bash automatically recognising arrays.
  58&nbsp;    local name=$1 
  59&nbsp;    local _keys _values _ptr
  60&nbsp;    _inihash ${name}
  61&nbsp;    eval ${_ptr}=0
  62&nbsp;}
  63&nbsp;
  64&nbsp;
  65&nbsp;function addhash () {
  66&nbsp;    # Usage: addhash NAME KEY 'VALUE with spaces'
  67&nbsp;    #        arguments with spaces need to be quoted with single quotes ''
  68&nbsp;    local name=$1 k="$2" v="$3" 
  69&nbsp;    local _keys _values _ptr
  70&nbsp;    _inihash ${name}
  71&nbsp;
  72&nbsp;    #echo "DEBUG(addhash): ${_ptr}=${!_ptr}"
  73&nbsp;
  74&nbsp;    eval let ${_ptr}=${_ptr}+1
  75&nbsp;    eval "$_keys[${!_ptr}]=\"${k}\""
  76&nbsp;    eval "$_values[${!_ptr}]=\"${v}\""
  77&nbsp;}
  78&nbsp;
  79&nbsp;function gethash () {
  80&nbsp;    #  Usage: gethash NAME KEY
  81&nbsp;    #         Returns boing
  82&nbsp;    #         ERR=0 if entry found, 1 otherwise
  83&nbsp;    #  That's not a proper hash --
  84&nbsp;    #+ we simply linearly search through the keys.
  85&nbsp;    local name=$1 key="$2" 
  86&nbsp;    local _keys _values _ptr 
  87&nbsp;    local k v i found h
  88&nbsp;    _inihash ${name}
  89&nbsp;    
  90&nbsp;    # _ptr holds the highest index in the hash
  91&nbsp;    found=0
  92&nbsp;
  93&nbsp;    for i in $(seq 1 ${!_ptr}); do
  94&nbsp;	h="\${${_keys}[${i}]}"  #  Safer to do it in two steps,
  95&nbsp;	eval k=${h}             #+ especially when quoting for spaces.
  96&nbsp;	if [ "${k}" = "${key}" ]; then found=1; break; fi
  97&nbsp;    done;
  98&nbsp;
  99&nbsp;    [ ${found} = 0 ] &#38;&#38; return 1;
 100&nbsp;    # else: i is the index that matches the key
 101&nbsp;    h="\${${_values}[${i}]}"
 102&nbsp;    eval echo "${h}"
 103&nbsp;    return 0;	
 104&nbsp;}
 105&nbsp;
 106&nbsp;function keyshash () {
 107&nbsp;    # Usage: keyshash NAME
 108&nbsp;    # Returns list of all keys defined for hash name.
 109&nbsp;    local name=$1 key="$2" 
 110&nbsp;    local _keys _values _ptr 
 111&nbsp;    local k i h
 112&nbsp;    _inihash ${name}
 113&nbsp;    
 114&nbsp;    # _ptr holds the highest index in the hash
 115&nbsp;    for i in $(seq 1 ${!_ptr}); do
 116&nbsp;	h="\${${_keys}[${i}]}"   #  Safer to do it in two steps,
 117&nbsp;	eval k=${h}              #+ especially when quoting for spaces.
 118&nbsp;	echo -n "'${k}' "
 119&nbsp;    done;
 120&nbsp;}
 121&nbsp;
 122&nbsp;
 123&nbsp;# -----------------------------------------------------------------------
 124&nbsp;
 125&nbsp;# Now, let's test it.
 126&nbsp;# (Per comments at the beginning of the script.)
 127&nbsp;newhash Lovers
 128&nbsp;addhash Lovers Tristan Isolde
 129&nbsp;addhash Lovers 'Romeo Montague' 'Juliet Capulet'
 130&nbsp;
 131&nbsp;# Output results.
 132&nbsp;echo
 133&nbsp;gethash Lovers Tristan      # Isolde
 134&nbsp;echo
 135&nbsp;keyshash Lovers             # 'Tristan' 'Romeo Montague'
 136&nbsp;echo; echo
 137&nbsp;
 138&nbsp;
 139&nbsp;exit 0
 140&nbsp;
 141&nbsp;# Exercise:
 142&nbsp;# --------
 143&nbsp;
 144&nbsp;# Add error checks to the functions.</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>Now for a script that installs and mounts
      those cute USB keychain solid-state <SPAN
CLASS="QUOTE"
>"hard drives."</SPAN
></P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="USBINST"
></A
><P
><B
>Example A-25. Mounting USB keychain storage devices</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# ==&#62; usb.sh
   3&nbsp;# ==&#62; Script for mounting and installing pen/keychain USB storage devices.
   4&nbsp;# ==&#62; Runs as root at system startup (see below).
   5&nbsp;# ==&#62;
   6&nbsp;# ==&#62; Newer Linux distros (2004 or later) autodetect
   7&nbsp;# ==&#62; and install USB pen drives, and therefore don't need this script.
   8&nbsp;# ==&#62; But, it's still instructive.
   9&nbsp; 
  10&nbsp;#  This code is free software covered by GNU GPL license version 2 or above.
  11&nbsp;#  Please refer to http://www.gnu.org/ for the full license text.
  12&nbsp;#
  13&nbsp;#  Some code lifted from usb-mount by Michael Hamilton's usb-mount (LGPL)
  14&nbsp;#+ see http://users.actrix.co.nz/michael/usbmount.html
  15&nbsp;#
  16&nbsp;#  INSTALL
  17&nbsp;#  -------
  18&nbsp;#  Put this in /etc/hotplug/usb/diskonkey.
  19&nbsp;#  Then look in /etc/hotplug/usb.distmap, and copy all usb-storage entries
  20&nbsp;#+ into /etc/hotplug/usb.usermap, substituting "usb-storage" for "diskonkey".
  21&nbsp;#  Otherwise this code is only run during the kernel module invocation/removal
  22&nbsp;#+ (at least in my tests), which defeats the purpose.
  23&nbsp;#
  24&nbsp;#  TODO
  25&nbsp;#  ----
  26&nbsp;#  Handle more than one diskonkey device at one time (e.g. /dev/diskonkey1
  27&nbsp;#+ and /mnt/diskonkey1), etc. The biggest problem here is the handling in
  28&nbsp;#+ devlabel, which I haven't yet tried.
  29&nbsp;#
  30&nbsp;#  AUTHOR and SUPPORT
  31&nbsp;#  ------------------
  32&nbsp;#  Konstantin Riabitsev, &#60;icon linux duke edu&#62;.
  33&nbsp;#  Send any problem reports to my email address at the moment.
  34&nbsp;#
  35&nbsp;# ==&#62; Comments added by ABS Guide author.
  36&nbsp;
  37&nbsp;
  38&nbsp;
  39&nbsp;SYMLINKDEV=/dev/diskonkey
  40&nbsp;MOUNTPOINT=/mnt/diskonkey
  41&nbsp;DEVLABEL=/sbin/devlabel
  42&nbsp;DEVLABELCONFIG=/etc/sysconfig/devlabel
  43&nbsp;IAM=$0
  44&nbsp;
  45&nbsp;##
  46&nbsp;# Functions lifted near-verbatim from usb-mount code.
  47&nbsp;#
  48&nbsp;function allAttachedScsiUsb {
  49&nbsp;  find /proc/scsi/ -path '/proc/scsi/usb-storage*' -type f |
  50&nbsp;  xargs grep -l 'Attached: Yes'
  51&nbsp;}
  52&nbsp;function scsiDevFromScsiUsb {
  53&nbsp;  echo $1 | awk -F"[-/]" '{ n=$(NF-1);
  54&nbsp;  print "/dev/sd" substr("abcdefghijklmnopqrstuvwxyz", n+1, 1) }'
  55&nbsp;}
  56&nbsp;
  57&nbsp;if [ "${ACTION}" = "add" ] &#38;&#38; [ -f "${DEVICE}" ]; then
  58&nbsp;    ##
  59&nbsp;    # lifted from usbcam code.
  60&nbsp;    #
  61&nbsp;    if [ -f /var/run/console.lock ]; then
  62&nbsp;        CONSOLEOWNER=`cat /var/run/console.lock`
  63&nbsp;    elif [ -f /var/lock/console.lock ]; then
  64&nbsp;        CONSOLEOWNER=`cat /var/lock/console.lock`
  65&nbsp;    else
  66&nbsp;        CONSOLEOWNER=
  67&nbsp;    fi
  68&nbsp;    for procEntry in $(allAttachedScsiUsb); do
  69&nbsp;        scsiDev=$(scsiDevFromScsiUsb $procEntry)
  70&nbsp;        #  Some bug with usb-storage?
  71&nbsp;        #  Partitions are not in /proc/partitions until they are accessed
  72&nbsp;        #+ somehow.
  73&nbsp;        /sbin/fdisk -l $scsiDev &#62;/dev/null
  74&nbsp;        ##
  75&nbsp;        #  Most devices have partitioning info, so the data would be on
  76&nbsp;        #+ /dev/sd?1. However, some stupider ones don't have any partitioning
  77&nbsp;        #+ and use the entire device for data storage. This tries to
  78&nbsp;        #+ guess semi-intelligently if we have a /dev/sd?1 and if not, then
  79&nbsp;        #+ it uses the entire device and hopes for the better.
  80&nbsp;        #
  81&nbsp;        if grep -q `basename $scsiDev`1 /proc/partitions; then
  82&nbsp;            part="$scsiDev""1"
  83&nbsp;        else
  84&nbsp;            part=$scsiDev
  85&nbsp;        fi
  86&nbsp;        ##
  87&nbsp;        #  Change ownership of the partition to the console user so they can
  88&nbsp;        #+ mount it.
  89&nbsp;        #
  90&nbsp;        if [ ! -z "$CONSOLEOWNER" ]; then
  91&nbsp;            chown $CONSOLEOWNER:disk $part
  92&nbsp;        fi
  93&nbsp;        ##
  94&nbsp;        # This checks if we already have this UUID defined with devlabel.
  95&nbsp;        # If not, it then adds the device to the list.
  96&nbsp;        #
  97&nbsp;        prodid=`$DEVLABEL printid -d $part`
  98&nbsp;        if ! grep -q $prodid $DEVLABELCONFIG; then
  99&nbsp;            # cross our fingers and hope it works
 100&nbsp;            $DEVLABEL add -d $part -s $SYMLINKDEV 2&#62;/dev/null
 101&nbsp;        fi
 102&nbsp;        ##
 103&nbsp;        # Check if the mount point exists and create if it doesn't.
 104&nbsp;        #
 105&nbsp;        if [ ! -e $MOUNTPOINT ]; then
 106&nbsp;            mkdir -p $MOUNTPOINT
 107&nbsp;        fi
 108&nbsp;        ##
 109&nbsp;        # Take care of /etc/fstab so mounting is easy.
 110&nbsp;        #
 111&nbsp;        if ! grep -q "^$SYMLINKDEV" /etc/fstab; then
 112&nbsp;            # Add an fstab entry
 113&nbsp;            echo -e \
 114&nbsp;                "$SYMLINKDEV\t\t$MOUNTPOINT\t\tauto\tnoauto,owner,kudzu 0 0" \
 115&nbsp;                &#62;&#62; /etc/fstab
 116&nbsp;        fi
 117&nbsp;    done
 118&nbsp;    if [ ! -z "$REMOVER" ]; then
 119&nbsp;        ##
 120&nbsp;        # Make sure this script is triggered on device removal.
 121&nbsp;        #
 122&nbsp;        mkdir -p `dirname $REMOVER`
 123&nbsp;        ln -s $IAM $REMOVER
 124&nbsp;    fi
 125&nbsp;elif [ "${ACTION}" = "remove" ]; then
 126&nbsp;    ##
 127&nbsp;    # If the device is mounted, unmount it cleanly.
 128&nbsp;    #
 129&nbsp;    if grep -q "$MOUNTPOINT" /etc/mtab; then
 130&nbsp;        # unmount cleanly
 131&nbsp;        umount -l $MOUNTPOINT
 132&nbsp;    fi
 133&nbsp;    ##
 134&nbsp;    # Remove it from /etc/fstab if it's there.
 135&nbsp;    #
 136&nbsp;    if grep -q "^$SYMLINKDEV" /etc/fstab; then
 137&nbsp;        grep -v "^$SYMLINKDEV" /etc/fstab &#62; /etc/.fstab.new
 138&nbsp;        mv -f /etc/.fstab.new /etc/fstab
 139&nbsp;    fi
 140&nbsp;fi
 141&nbsp;
 142&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>Converting a text file to HTML format.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="TOHTML"
></A
><P
><B
>Example A-26. Converting to HTML</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# tohtml.sh
   3&nbsp;
   4&nbsp;# Convert a text file to HTML format.
   5&nbsp;# Author: Mendel Cooper
   6&nbsp;# License: GPL3
   7&nbsp;# Usage: sh tohtml.sh &#60; textfile &#62; htmlfile
   8&nbsp;# Script can easily be modified to accept source and target filenames.
   9&nbsp;
  10&nbsp;#    Assumptions:
  11&nbsp;# 1) Paragraphs in (target) text file are separated by a blank line.
  12&nbsp;# 2) Jpeg images (*.jpg) are located in "images" subdirectory.
  13&nbsp;#    In the target file, the image names are enclosed in square brackets,
  14&nbsp;#    for example, [image01.jpg].
  15&nbsp;# 3) Emphasized (italic) phrases begin with a space+underscore
  16&nbsp;#+   or the first character on the line is an underscore,
  17&nbsp;#+   and end with an underscore+space or underscore+end-of-line.
  18&nbsp;
  19&nbsp;
  20&nbsp;# Settings
  21&nbsp;FNTSIZE=2        # Small-medium font size
  22&nbsp;IMGDIR="images"  # Image directory
  23&nbsp;# Headers
  24&nbsp;HDR01='&#60;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&#62;'
  25&nbsp;HDR02='&#60;!-- Converted to HTML by ***tohtml.sh*** script --&#62;'
  26&nbsp;HDR03='&#60;!-- script author: M. Leo Cooper &#60;thegrendel@theriver.com&#62; --&#62;'
  27&nbsp;HDR10='&#60;html&#62;'
  28&nbsp;HDR11='&#60;head&#62;'
  29&nbsp;HDR11a='&#60;/head&#62;'
  30&nbsp;HDR12a='&#60;title&#62;'
  31&nbsp;HDR12b='&#60;/title&#62;'
  32&nbsp;HDR121='&#60;META NAME="GENERATOR" CONTENT="tohtml.sh script"&#62;'
  33&nbsp;HDR13='&#60;body bgcolor="#dddddd"&#62;'   # Change background color to suit.
  34&nbsp;HDR14a='&#60;font size='
  35&nbsp;HDR14b='&#62;'
  36&nbsp;# Footers
  37&nbsp;FTR10='&#60;/body&#62;'
  38&nbsp;FTR11='&#60;/html&#62;'
  39&nbsp;# Tags
  40&nbsp;BOLD="&#60;b&#62;"
  41&nbsp;CENTER="&#60;center&#62;"
  42&nbsp;END_CENTER="&#60;/center&#62;"
  43&nbsp;LF="&#60;br&#62;"
  44&nbsp;
  45&nbsp;
  46&nbsp;write_headers ()
  47&nbsp;  {
  48&nbsp;  echo "$HDR01"
  49&nbsp;  echo
  50&nbsp;  echo "$HDR02"
  51&nbsp;  echo "$HDR03"
  52&nbsp;  echo
  53&nbsp;  echo
  54&nbsp;  echo "$HDR10"
  55&nbsp;  echo "$HDR11"
  56&nbsp;  echo "$HDR121"
  57&nbsp;  echo "$HDR11a"
  58&nbsp;  echo "$HDR13"
  59&nbsp;  echo
  60&nbsp;  echo -n "$HDR14a"
  61&nbsp;  echo -n "$FNTSIZE"
  62&nbsp;  echo "$HDR14b"
  63&nbsp;  echo
  64&nbsp;  echo "$BOLD"        # Everything in bold (more easily readable).
  65&nbsp;  }
  66&nbsp;
  67&nbsp;
  68&nbsp;process_text ()
  69&nbsp;  {
  70&nbsp;  while read line     # Read one line at a time.
  71&nbsp;  do
  72&nbsp;    {
  73&nbsp;    if [ ! "$line" ]  # Blank line?
  74&nbsp;    then              # Then new paragraph must follow.
  75&nbsp;      echo
  76&nbsp;      echo "$LF"      # Insert two &#60;br&#62; tags.
  77&nbsp;      echo "$LF"
  78&nbsp;      echo
  79&nbsp;      continue        # Skip the underscore test.
  80&nbsp;    else              # Otherwise . . .
  81&nbsp;
  82&nbsp;      if [[ "$line" =~ "\[*jpg\]" ]]  # Is a graphic?
  83&nbsp;      then                            # Strip away brackets.
  84&nbsp;        temp=$( echo "$line" | sed -e 's/\[//' -e 's/\]//' )
  85&nbsp;        line=""$CENTER" &#60;img src="\"$IMGDIR"/$temp\"&#62; "$END_CENTER" "
  86&nbsp;                                      # Add image tag.
  87&nbsp;                                      # And, center it.
  88&nbsp;      fi
  89&nbsp;
  90&nbsp;    fi
  91&nbsp;
  92&nbsp;
  93&nbsp;    echo "$line" | grep -q _
  94&nbsp;    if [ "$?" -eq 0 ]    # If line contains underscore ...
  95&nbsp;    then
  96&nbsp;      # ===================================================
  97&nbsp;      # Convert underscored phrase to italics.
  98&nbsp;      temp=$( echo "$line" |
  99&nbsp;              sed -e 's/ _/ &#60;i&#62;/' -e 's/_ /&#60;\/i&#62; /' |
 100&nbsp;              sed -e 's/^_/&#60;i&#62;/'  -e 's/_$/&#60;\/i&#62;/' )
 101&nbsp;      #  Process only underscores prefixed by space,
 102&nbsp;      #+ followed by space, or at beginning or end of line.
 103&nbsp;      #  Do not convert underscores embedded within a word!
 104&nbsp;      line="$temp"
 105&nbsp;      # Slows script execution. Can be optimized?
 106&nbsp;      # ===================================================
 107&nbsp;    fi
 108&nbsp;
 109&nbsp;
 110&nbsp;   
 111&nbsp;    echo
 112&nbsp;    echo "$line"
 113&nbsp;    echo
 114&nbsp;    } # End while
 115&nbsp;  done
 116&nbsp;  }   # End process_text ()
 117&nbsp;
 118&nbsp;
 119&nbsp;write_footers ()  # Termination tags.
 120&nbsp;  {
 121&nbsp;  echo "$FTR10"
 122&nbsp;  echo "$FTR11"
 123&nbsp;  }
 124&nbsp;
 125&nbsp;
 126&nbsp;# main () {
 127&nbsp;# =========
 128&nbsp;write_headers
 129&nbsp;process_text
 130&nbsp;write_footers
 131&nbsp;# =========
 132&nbsp;#         }
 133&nbsp;
 134&nbsp;exit $?
 135&nbsp;
 136&nbsp;#  Exercises:
 137&nbsp;#  ---------
 138&nbsp;#  1) Fixup: Check for closing underscore before a comma or period.
 139&nbsp;#  2) Add a test for the presence of a closing underscore
 140&nbsp;#+    in phrases to be italicized.</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>Here is something to warm the hearts of webmasters and mistresses:
      a script that saves weblogs.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="ARCHIVWEBLOGS"
></A
><P
><B
>Example A-27. Preserving weblogs</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# archiveweblogs.sh v1.0
   3&nbsp;
   4&nbsp;# Troy Engel &#60;tengel@fluid.com&#62;
   5&nbsp;# Slightly modified by document author.
   6&nbsp;# Used with permission.
   7&nbsp;#
   8&nbsp;#  This script will preserve the normally rotated and
   9&nbsp;#+ thrown away weblogs from a default RedHat/Apache installation.
  10&nbsp;#  It will save the files with a date/time stamp in the filename,
  11&nbsp;#+ bzipped, to a given directory.
  12&nbsp;#
  13&nbsp;#  Run this from crontab nightly at an off hour,
  14&nbsp;#+ as bzip2 can suck up some serious CPU on huge logs:
  15&nbsp;#  0 2 * * * /opt/sbin/archiveweblogs.sh
  16&nbsp;
  17&nbsp;
  18&nbsp;PROBLEM=66
  19&nbsp;
  20&nbsp;# Set this to your backup dir.
  21&nbsp;BKP_DIR=/opt/backups/weblogs
  22&nbsp;
  23&nbsp;# Default Apache/RedHat stuff
  24&nbsp;LOG_DAYS="4 3 2 1"
  25&nbsp;LOG_DIR=/var/log/httpd
  26&nbsp;LOG_FILES="access_log error_log"
  27&nbsp;
  28&nbsp;# Default RedHat program locations
  29&nbsp;LS=/bin/ls
  30&nbsp;MV=/bin/mv
  31&nbsp;ID=/usr/bin/id
  32&nbsp;CUT=/bin/cut
  33&nbsp;COL=/usr/bin/column
  34&nbsp;BZ2=/usr/bin/bzip2
  35&nbsp;
  36&nbsp;# Are we root?
  37&nbsp;USER=`$ID -u`
  38&nbsp;if [ "X$USER" != "X0" ]; then
  39&nbsp;  echo "PANIC: Only root can run this script!"
  40&nbsp;  exit $PROBLEM
  41&nbsp;fi
  42&nbsp;
  43&nbsp;# Backup dir exists/writable?
  44&nbsp;if [ ! -x $BKP_DIR ]; then
  45&nbsp;  echo "PANIC: $BKP_DIR doesn't exist or isn't writable!"
  46&nbsp;  exit $PROBLEM
  47&nbsp;fi
  48&nbsp;
  49&nbsp;# Move, rename and bzip2 the logs
  50&nbsp;for logday in $LOG_DAYS; do
  51&nbsp;  for logfile in $LOG_FILES; do
  52&nbsp;    MYFILE="$LOG_DIR/$logfile.$logday"
  53&nbsp;    if [ -w $MYFILE ]; then
  54&nbsp;      DTS=`$LS -lgo --time-style=+%Y%m%d $MYFILE | $COL -t | $CUT -d ' ' -f7`
  55&nbsp;      $MV $MYFILE $BKP_DIR/$logfile.$DTS
  56&nbsp;      $BZ2 $BKP_DIR/$logfile.$DTS
  57&nbsp;    else
  58&nbsp;      # Only spew an error if the file exits (ergo non-writable).
  59&nbsp;      if [ -f $MYFILE ]; then
  60&nbsp;        echo "ERROR: $MYFILE not writable. Skipping."
  61&nbsp;      fi
  62&nbsp;    fi
  63&nbsp;  done
  64&nbsp;done
  65&nbsp;
  66&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
><A
NAME="PROTECTLITERAL0"
></A
>How to keep the shell from
      expanding and reinterpreting text strings.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="PROTECTLITERAL"
></A
><P
><B
>Example A-28. Protecting literal strings</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#! /bin/bash
   2&nbsp;# protect_literal.sh
   3&nbsp;
   4&nbsp;# set -vx
   5&nbsp;
   6&nbsp;:&#60;&#60;-'_Protect_Literal_String_Doc'
   7&nbsp;
   8&nbsp;    Copyright (c) Michael S. Zick, 2003; All Rights Reserved
   9&nbsp;    License: Unrestricted reuse in any form, for any purpose.
  10&nbsp;    Warranty: None
  11&nbsp;    Revision: $ID$
  12&nbsp;
  13&nbsp;    Documentation redirected to the Bash no-operation.
  14&nbsp;    Bash will '/dev/null' this block when the script is first read.
  15&nbsp;    (Uncomment the above set command to see this action.)
  16&nbsp;
  17&nbsp;    Remove the first (Sha-Bang) line when sourcing this as a library
  18&nbsp;    procedure.  Also comment out the example use code in the two
  19&nbsp;    places where shown.
  20&nbsp;
  21&nbsp;
  22&nbsp;    Usage:
  23&nbsp;        _protect_literal_str 'Whatever string meets your ${fancy}'
  24&nbsp;        Just echos the argument to standard out, hard quotes
  25&nbsp;        restored.
  26&nbsp;
  27&nbsp;        $(_protect_literal_str 'Whatever string meets your ${fancy}')
  28&nbsp;        as the right-hand-side of an assignment statement.
  29&nbsp;
  30&nbsp;    Does:
  31&nbsp;        As the right-hand-side of an assignment, preserves the
  32&nbsp;        hard quotes protecting the contents of the literal during
  33&nbsp;        assignment.
  34&nbsp;
  35&nbsp;    Notes:
  36&nbsp;        The strange names (_*) are used to avoid trampling on
  37&nbsp;        the user's chosen names when this is sourced as a
  38&nbsp;        library.
  39&nbsp;
  40&nbsp;_Protect_Literal_String_Doc
  41&nbsp;
  42&nbsp;# The 'for illustration' function form
  43&nbsp;
  44&nbsp;_protect_literal_str() {
  45&nbsp;
  46&nbsp;# Pick an un-used, non-printing character as local IFS.
  47&nbsp;# Not required, but shows that we are ignoring it.
  48&nbsp;    local IFS=$'\x1B'               # \ESC character
  49&nbsp;
  50&nbsp;# Enclose the All-Elements-Of in hard quotes during assignment.
  51&nbsp;    local tmp=$'\x27'$@$'\x27'
  52&nbsp;#    local tmp=$'\''$@$'\''         # Even uglier.
  53&nbsp;
  54&nbsp;    local len=${#tmp}               # Info only.
  55&nbsp;    echo $tmp is $len long.         # Output AND information.
  56&nbsp;}
  57&nbsp;
  58&nbsp;# This is the short-named version.
  59&nbsp;_pls() {
  60&nbsp;    local IFS=$'x1B'                # \ESC character (not required)
  61&nbsp;    echo $'\x27'$@$'\x27'           # Hard quoted parameter glob
  62&nbsp;}
  63&nbsp;
  64&nbsp;# :&#60;&#60;-'_Protect_Literal_String_Test'
  65&nbsp;# # # Remove the above "# " to disable this code. # # #
  66&nbsp;
  67&nbsp;# See how that looks when printed.
  68&nbsp;echo
  69&nbsp;echo "- - Test One - -"
  70&nbsp;_protect_literal_str 'Hello $user'
  71&nbsp;_protect_literal_str 'Hello "${username}"'
  72&nbsp;echo
  73&nbsp;
  74&nbsp;# Which yields:
  75&nbsp;# - - Test One - -
  76&nbsp;# 'Hello $user' is 13 long.
  77&nbsp;# 'Hello "${username}"' is 21 long.
  78&nbsp;
  79&nbsp;#  Looks as expected, but why all of the trouble?
  80&nbsp;#  The difference is hidden inside the Bash internal order
  81&nbsp;#+ of operations.
  82&nbsp;#  Which shows when you use it on the RHS of an assignment.
  83&nbsp;
  84&nbsp;# Declare an array for test values.
  85&nbsp;declare -a arrayZ
  86&nbsp;
  87&nbsp;# Assign elements with various types of quotes and escapes.
  88&nbsp;arrayZ=( zero "$(_pls 'Hello ${Me}')" 'Hello ${You}' "\'Pass: ${pw}\'" )
  89&nbsp;
  90&nbsp;# Now list that array and see what is there.
  91&nbsp;echo "- - Test Two - -"
  92&nbsp;for (( i=0 ; i&#60;${#arrayZ[*]} ; i++ ))
  93&nbsp;do
  94&nbsp;    echo  Element $i: ${arrayZ[$i]} is: ${#arrayZ[$i]} long.
  95&nbsp;done
  96&nbsp;echo
  97&nbsp;
  98&nbsp;# Which yields:
  99&nbsp;# - - Test Two - -
 100&nbsp;# Element 0: zero is: 4 long.           # Our marker element
 101&nbsp;# Element 1: 'Hello ${Me}' is: 13 long. # Our "$(_pls '...' )"
 102&nbsp;# Element 2: Hello ${You} is: 12 long.  # Quotes are missing
 103&nbsp;# Element 3: \'Pass: \' is: 10 long.    # ${pw} expanded to nothing
 104&nbsp;
 105&nbsp;# Now make an assignment with that result.
 106&nbsp;declare -a array2=( ${arrayZ[@]} )
 107&nbsp;
 108&nbsp;# And print what happened.
 109&nbsp;echo "- - Test Three - -"
 110&nbsp;for (( i=0 ; i&#60;${#array2[*]} ; i++ ))
 111&nbsp;do
 112&nbsp;    echo  Element $i: ${array2[$i]} is: ${#array2[$i]} long.
 113&nbsp;done
 114&nbsp;echo
 115&nbsp;
 116&nbsp;# Which yields:
 117&nbsp;# - - Test Three - -
 118&nbsp;# Element 0: zero is: 4 long.           # Our marker element.
 119&nbsp;# Element 1: Hello ${Me} is: 11 long.   # Intended result.
 120&nbsp;# Element 2: Hello is: 5 long.          # ${You} expanded to nothing.
 121&nbsp;# Element 3: 'Pass: is: 6 long.         # Split on the whitespace.
 122&nbsp;# Element 4: ' is: 1 long.              # The end quote is here now.
 123&nbsp;
 124&nbsp;#  Our Element 1 has had its leading and trailing hard quotes stripped.
 125&nbsp;#  Although not shown, leading and trailing whitespace is also stripped.
 126&nbsp;#  Now that the string contents are set, Bash will always, internally,
 127&nbsp;#+ hard quote the contents as required during its operations.
 128&nbsp;
 129&nbsp;#  Why?
 130&nbsp;#  Considering our "$(_pls 'Hello ${Me}')" construction:
 131&nbsp;#  " ... " -&#62; Expansion required, strip the quotes.
 132&nbsp;#  $( ... ) -&#62; Replace with the result of..., strip this.
 133&nbsp;#  _pls ' ... ' -&#62; called with literal arguments, strip the quotes.
 134&nbsp;#  The result returned includes hard quotes; BUT the above processing
 135&nbsp;#+ has already been done, so they become part of the value assigned.
 136&nbsp;#
 137&nbsp;#  Similarly, during further usage of the string variable, the ${Me}
 138&nbsp;#+ is part of the contents (result) and survives any operations
 139&nbsp;#  (Until explicitly told to evaluate the string).
 140&nbsp;
 141&nbsp;#  Hint: See what happens when the hard quotes ($'\x27') are replaced
 142&nbsp;#+ with soft quotes ($'\x22') in the above procedures.
 143&nbsp;#  Interesting also is to remove the addition of any quoting.
 144&nbsp;
 145&nbsp;# _Protect_Literal_String_Test
 146&nbsp;# # # Remove the above "# " to disable this code. # # #
 147&nbsp;
 148&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
><A
NAME="UNPROTECTLITERAL0"
></A
>But, what if you
      <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>want</I
></SPAN
> the shell to expand
      and reinterpret strings?</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="UNPROTECTLITERAL"
></A
><P
><B
>Example A-29. Unprotecting literal strings</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#! /bin/bash
   2&nbsp;# unprotect_literal.sh
   3&nbsp;
   4&nbsp;# set -vx
   5&nbsp;
   6&nbsp;:&#60;&#60;-'_UnProtect_Literal_String_Doc'
   7&nbsp;
   8&nbsp;    Copyright (c) Michael S. Zick, 2003; All Rights Reserved
   9&nbsp;    License: Unrestricted reuse in any form, for any purpose.
  10&nbsp;    Warranty: None
  11&nbsp;    Revision: $ID$
  12&nbsp;
  13&nbsp;    Documentation redirected to the Bash no-operation. Bash will
  14&nbsp;    '/dev/null' this block when the script is first read.
  15&nbsp;    (Uncomment the above set command to see this action.)
  16&nbsp;
  17&nbsp;    Remove the first (Sha-Bang) line when sourcing this as a library
  18&nbsp;    procedure.  Also comment out the example use code in the two
  19&nbsp;    places where shown.
  20&nbsp;
  21&nbsp;
  22&nbsp;    Usage:
  23&nbsp;        Complement of the "$(_pls 'Literal String')" function.
  24&nbsp;        (See the protect_literal.sh example.)
  25&nbsp;
  26&nbsp;        StringVar=$(_upls ProtectedSringVariable)
  27&nbsp;
  28&nbsp;    Does:
  29&nbsp;        When used on the right-hand-side of an assignment statement;
  30&nbsp;        makes the substitions embedded in the protected string.
  31&nbsp;
  32&nbsp;    Notes:
  33&nbsp;        The strange names (_*) are used to avoid trampling on
  34&nbsp;        the user's chosen names when this is sourced as a
  35&nbsp;        library.
  36&nbsp;
  37&nbsp;
  38&nbsp;_UnProtect_Literal_String_Doc
  39&nbsp;
  40&nbsp;_upls() {
  41&nbsp;    local IFS=$'x1B'                # \ESC character (not required)
  42&nbsp;    eval echo $@                    # Substitution on the glob.
  43&nbsp;}
  44&nbsp;
  45&nbsp;# :&#60;&#60;-'_UnProtect_Literal_String_Test'
  46&nbsp;# # # Remove the above "# " to disable this code. # # #
  47&nbsp;
  48&nbsp;
  49&nbsp;_pls() {
  50&nbsp;    local IFS=$'x1B'                # \ESC character (not required)
  51&nbsp;    echo $'\x27'$@$'\x27'           # Hard quoted parameter glob
  52&nbsp;}
  53&nbsp;
  54&nbsp;# Declare an array for test values.
  55&nbsp;declare -a arrayZ
  56&nbsp;
  57&nbsp;# Assign elements with various types of quotes and escapes.
  58&nbsp;arrayZ=( zero "$(_pls 'Hello ${Me}')" 'Hello ${You}' "\'Pass: ${pw}\'" )
  59&nbsp;
  60&nbsp;# Now make an assignment with that result.
  61&nbsp;declare -a array2=( ${arrayZ[@]} )
  62&nbsp;
  63&nbsp;# Which yielded:
  64&nbsp;# - - Test Three - -
  65&nbsp;# Element 0: zero is: 4 long            # Our marker element.
  66&nbsp;# Element 1: Hello ${Me} is: 11 long    # Intended result.
  67&nbsp;# Element 2: Hello is: 5 long           # ${You} expanded to nothing.
  68&nbsp;# Element 3: 'Pass: is: 6 long          # Split on the whitespace.
  69&nbsp;# Element 4: ' is: 1 long               # The end quote is here now.
  70&nbsp;
  71&nbsp;# set -vx
  72&nbsp;
  73&nbsp;#  Initialize 'Me' to something for the embedded ${Me} substitution.
  74&nbsp;#  This needs to be done ONLY just prior to evaluating the
  75&nbsp;#+ protected string.
  76&nbsp;#  (This is why it was protected to begin with.)
  77&nbsp;
  78&nbsp;Me="to the array guy."
  79&nbsp;
  80&nbsp;# Set a string variable destination to the result.
  81&nbsp;newVar=$(_upls ${array2[1]})
  82&nbsp;
  83&nbsp;# Show what the contents are.
  84&nbsp;echo $newVar
  85&nbsp;
  86&nbsp;# Do we really need a function to do this?
  87&nbsp;newerVar=$(eval echo ${array2[1]})
  88&nbsp;echo $newerVar
  89&nbsp;
  90&nbsp;#  I guess not, but the _upls function gives us a place to hang
  91&nbsp;#+ the documentation on.
  92&nbsp;#  This helps when we forget what a # construction like:
  93&nbsp;#+ $(eval echo ... ) means.
  94&nbsp;
  95&nbsp;# What if Me isn't set when the protected string is evaluated?
  96&nbsp;unset Me
  97&nbsp;newestVar=$(_upls ${array2[1]})
  98&nbsp;echo $newestVar
  99&nbsp;
 100&nbsp;# Just gone, no hints, no runs, no errors.
 101&nbsp;
 102&nbsp;#  Why in the world?
 103&nbsp;#  Setting the contents of a string variable containing character
 104&nbsp;#+ sequences that have a meaning in Bash is a general problem in
 105&nbsp;#+ script programming.
 106&nbsp;#
 107&nbsp;#  This problem is now solved in eight lines of code
 108&nbsp;#+ (and four pages of description).
 109&nbsp;
 110&nbsp;#  Where is all this going?
 111&nbsp;#  Dynamic content Web pages as an array of Bash strings.
 112&nbsp;#  Content set per request by a Bash 'eval' command
 113&nbsp;#+ on the stored page template.
 114&nbsp;#  Not intended to replace PHP, just an interesting thing to do.
 115&nbsp;###
 116&nbsp;#  Don't have a webserver application?
 117&nbsp;#  No problem, check the example directory of the Bash source;
 118&nbsp;#+ there is a Bash script for that also.
 119&nbsp;
 120&nbsp;# _UnProtect_Literal_String_Test
 121&nbsp;# # # Remove the above "# " to disable this code. # # #
 122&nbsp;
 123&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>This interesting script helps hunt down spammers.</P
><P
><A
NAME="ISSPAMMER2_0"
></A
></P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="ISSPAMMER2"
></A
><P
><B
>Example A-30. Spammer Identification</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;# $Id: is_spammer.bash,v 1.12.2.11 2004/10/01 21:42:33 mszick Exp $
   4&nbsp;# Above line is RCS info.
   5&nbsp;
   6&nbsp;# The latest version of this script is available from http://www.morethan.org.
   7&nbsp;#
   8&nbsp;# Spammer-identification
   9&nbsp;# by Michael S. Zick
  10&nbsp;# Used in the ABS Guide with permission.
  11&nbsp;
  12&nbsp;
  13&nbsp;
  14&nbsp;#######################################################
  15&nbsp;# Documentation
  16&nbsp;# See also "Quickstart" at end of script.
  17&nbsp;#######################################################
  18&nbsp;
  19&nbsp;:&#60;&#60;-'__is_spammer_Doc_'
  20&nbsp;
  21&nbsp;    Copyright (c) Michael S. Zick, 2004
  22&nbsp;    License: Unrestricted reuse in any form, for any purpose.
  23&nbsp;    Warranty: None -{Its a script; the user is on their own.}-
  24&nbsp;
  25&nbsp;Impatient?
  26&nbsp;    Application code: goto "# # # Hunt the Spammer' program code # # #"
  27&nbsp;    Example output: ":&#60;&#60;-'_is_spammer_outputs_'"
  28&nbsp;    How to use: Enter script name without arguments.
  29&nbsp;                Or goto "Quickstart" at end of script.
  30&nbsp;
  31&nbsp;Provides
  32&nbsp;    Given a domain name or IP(v4) address as input:
  33&nbsp;
  34&nbsp;    Does an exhaustive set of queries to find the associated
  35&nbsp;    network resources (short of recursing into TLDs).
  36&nbsp;
  37&nbsp;    Checks the IP(v4) addresses found against Blacklist
  38&nbsp;    nameservers.
  39&nbsp;
  40&nbsp;    If found to be a blacklisted IP(v4) address,
  41&nbsp;    reports the blacklist text records.
  42&nbsp;    (Usually hyper-links to the specific report.)
  43&nbsp;
  44&nbsp;Requires
  45&nbsp;    A working Internet connection.
  46&nbsp;    (Exercise: Add check and/or abort if not on-line when running script.)
  47&nbsp;    Bash with arrays (2.05b+).
  48&nbsp;
  49&nbsp;    The external program 'dig' --
  50&nbsp;    a utility program provided with the 'bind' set of programs.
  51&nbsp;    Specifically, the version which is part of Bind series 9.x
  52&nbsp;    See: http://www.isc.org
  53&nbsp;
  54&nbsp;    All usages of 'dig' are limited to wrapper functions,
  55&nbsp;    which may be rewritten as required.
  56&nbsp;    See: dig_wrappers.bash for details.
  57&nbsp;         ("Additional documentation" -- below)
  58&nbsp;
  59&nbsp;Usage
  60&nbsp;    Script requires a single argument, which may be:
  61&nbsp;    1) A domain name;
  62&nbsp;    2) An IP(v4) address;
  63&nbsp;    3) A filename, with one name or address per line.
  64&nbsp;
  65&nbsp;    Script accepts an optional second argument, which may be:
  66&nbsp;    1) A Blacklist server name;
  67&nbsp;    2) A filename, with one Blacklist server name per line.
  68&nbsp;
  69&nbsp;    If the second argument is not provided, the script uses
  70&nbsp;    a built-in set of (free) Blacklist servers.
  71&nbsp;
  72&nbsp;    See also, the Quickstart at the end of this script (after 'exit').
  73&nbsp;
  74&nbsp;Return Codes
  75&nbsp;    0 - All OK
  76&nbsp;    1 - Script failure
  77&nbsp;    2 - Something is Blacklisted
  78&nbsp;
  79&nbsp;Optional environment variables
  80&nbsp;    SPAMMER_TRACE
  81&nbsp;        If set to a writable file,
  82&nbsp;        script will log an execution flow trace.
  83&nbsp;
  84&nbsp;    SPAMMER_DATA
  85&nbsp;        If set to a writable file, script will dump its
  86&nbsp;        discovered data in the form of GraphViz file.
  87&nbsp;        See: http://www.research.att.com/sw/tools/graphviz
  88&nbsp;
  89&nbsp;    SPAMMER_LIMIT
  90&nbsp;        Limits the depth of resource tracing.
  91&nbsp;
  92&nbsp;        Default is 2 levels.
  93&nbsp;
  94&nbsp;        A setting of 0 (zero) means 'unlimited' . . .
  95&nbsp;          Caution: script might recurse the whole Internet!
  96&nbsp;
  97&nbsp;        A limit of 1 or 2 is most useful when processing
  98&nbsp;        a file of domain names and addresses.
  99&nbsp;        A higher limit can be useful when hunting spam gangs.
 100&nbsp;
 101&nbsp;
 102&nbsp;Additional documentation
 103&nbsp;    Download the archived set of scripts
 104&nbsp;    explaining and illustrating the function contained within this script.
 105&nbsp;    http://personal.riverusers.com/mszick_clf.tar.bz2
 106&nbsp;
 107&nbsp;
 108&nbsp;Study notes
 109&nbsp;    This script uses a large number of functions.
 110&nbsp;    Nearly all general functions have their own example script.
 111&nbsp;    Each of the example scripts have tutorial level comments.
 112&nbsp;
 113&nbsp;Scripting project
 114&nbsp;    Add support for IP(v6) addresses.
 115&nbsp;    IP(v6) addresses are recognized but not processed.
 116&nbsp;
 117&nbsp;Advanced project
 118&nbsp;    Add the reverse lookup detail to the discovered information.
 119&nbsp;
 120&nbsp;    Report the delegation chain and abuse contacts.
 121&nbsp;
 122&nbsp;    Modify the GraphViz file output to include the
 123&nbsp;    newly discovered information.
 124&nbsp;
 125&nbsp;__is_spammer_Doc_
 126&nbsp;
 127&nbsp;#######################################################
 128&nbsp;
 129&nbsp;
 130&nbsp;
 131&nbsp;
 132&nbsp;#### Special IFS settings used for string parsing. ####
 133&nbsp;
 134&nbsp;# Whitespace == :Space:Tab:Line Feed:Carriage Return:
 135&nbsp;WSP_IFS=$'\x20'$'\x09'$'\x0A'$'\x0D'
 136&nbsp;
 137&nbsp;# No Whitespace == Line Feed:Carriage Return
 138&nbsp;NO_WSP=$'\x0A'$'\x0D'
 139&nbsp;
 140&nbsp;# Field separator for dotted decimal IP addresses
 141&nbsp;ADR_IFS=${NO_WSP}'.'
 142&nbsp;
 143&nbsp;# Array to dotted string conversions
 144&nbsp;DOT_IFS='.'${WSP_IFS}
 145&nbsp;
 146&nbsp;# # # Pending operations stack machine # # #
 147&nbsp;# This set of functions described in func_stack.bash.
 148&nbsp;# (See "Additional documentation" above.)
 149&nbsp;# # #
 150&nbsp;
 151&nbsp;# Global stack of pending operations.
 152&nbsp;declare -f -a _pending_
 153&nbsp;# Global sentinel for stack runners
 154&nbsp;declare -i _p_ctrl_
 155&nbsp;# Global holder for currently executing function
 156&nbsp;declare -f _pend_current_
 157&nbsp;
 158&nbsp;# # # Debug version only - remove for regular use # # #
 159&nbsp;#
 160&nbsp;# The function stored in _pend_hook_ is called
 161&nbsp;# immediately before each pending function is
 162&nbsp;# evaluated.  Stack clean, _pend_current_ set.
 163&nbsp;#
 164&nbsp;# This thingy demonstrated in pend_hook.bash.
 165&nbsp;declare -f _pend_hook_
 166&nbsp;# # #
 167&nbsp;
 168&nbsp;# The do nothing function
 169&nbsp;pend_dummy() { : ; }
 170&nbsp;
 171&nbsp;# Clear and initialize the function stack.
 172&nbsp;pend_init() {
 173&nbsp;    unset _pending_[@]
 174&nbsp;    pend_func pend_stop_mark
 175&nbsp;    _pend_hook_='pend_dummy'  # Debug only.
 176&nbsp;}
 177&nbsp;
 178&nbsp;# Discard the top function on the stack.
 179&nbsp;pend_pop() {
 180&nbsp;    if [ ${#_pending_[@]} -gt 0 ]
 181&nbsp;    then
 182&nbsp;        local -i _top_
 183&nbsp;        _top_=${#_pending_[@]}-1
 184&nbsp;        unset _pending_[$_top_]
 185&nbsp;    fi
 186&nbsp;}
 187&nbsp;
 188&nbsp;# pend_func function_name [$(printf '%q\n' arguments)]
 189&nbsp;pend_func() {
 190&nbsp;    local IFS=${NO_WSP}
 191&nbsp;    set -f
 192&nbsp;    _pending_[${#_pending_[@]}]=$@
 193&nbsp;    set +f
 194&nbsp;}
 195&nbsp;
 196&nbsp;# The function which stops the release:
 197&nbsp;pend_stop_mark() {
 198&nbsp;    _p_ctrl_=0
 199&nbsp;}
 200&nbsp;
 201&nbsp;pend_mark() {
 202&nbsp;    pend_func pend_stop_mark
 203&nbsp;}
 204&nbsp;
 205&nbsp;# Execute functions until 'pend_stop_mark' . . .
 206&nbsp;pend_release() {
 207&nbsp;    local -i _top_             # Declare _top_ as integer.
 208&nbsp;    _p_ctrl_=${#_pending_[@]}
 209&nbsp;    while [ ${_p_ctrl_} -gt 0 ]
 210&nbsp;    do
 211&nbsp;       _top_=${#_pending_[@]}-1
 212&nbsp;       _pend_current_=${_pending_[$_top_]}
 213&nbsp;       unset _pending_[$_top_]
 214&nbsp;       $_pend_hook_            # Debug only.
 215&nbsp;       eval $_pend_current_
 216&nbsp;    done
 217&nbsp;}
 218&nbsp;
 219&nbsp;# Drop functions until 'pend_stop_mark' . . .
 220&nbsp;pend_drop() {
 221&nbsp;    local -i _top_
 222&nbsp;    local _pd_ctrl_=${#_pending_[@]}
 223&nbsp;    while [ ${_pd_ctrl_} -gt 0 ]
 224&nbsp;    do
 225&nbsp;       _top_=$_pd_ctrl_-1
 226&nbsp;       if [ "${_pending_[$_top_]}" == 'pend_stop_mark' ]
 227&nbsp;       then
 228&nbsp;           unset _pending_[$_top_]
 229&nbsp;           break
 230&nbsp;       else
 231&nbsp;           unset _pending_[$_top_]
 232&nbsp;           _pd_ctrl_=$_top_
 233&nbsp;       fi
 234&nbsp;    done
 235&nbsp;    if [ ${#_pending_[@]} -eq 0 ]
 236&nbsp;    then
 237&nbsp;        pend_func pend_stop_mark
 238&nbsp;    fi
 239&nbsp;}
 240&nbsp;
 241&nbsp;#### Array editors ####
 242&nbsp;
 243&nbsp;# This function described in edit_exact.bash.
 244&nbsp;# (See "Additional documentation," above.)
 245&nbsp;# edit_exact &#60;excludes_array_name&#62; &#60;target_array_name&#62;
 246&nbsp;edit_exact() {
 247&nbsp;    [ $# -eq 2 ] ||
 248&nbsp;    [ $# -eq 3 ] || return 1
 249&nbsp;    local -a _ee_Excludes
 250&nbsp;    local -a _ee_Target
 251&nbsp;    local _ee_x
 252&nbsp;    local _ee_t
 253&nbsp;    local IFS=${NO_WSP}
 254&nbsp;    set -f
 255&nbsp;    eval _ee_Excludes=\( \$\{$1\[@\]\} \)
 256&nbsp;    eval _ee_Target=\( \$\{$2\[@\]\} \)
 257&nbsp;    local _ee_len=${#_ee_Target[@]}     # Original length.
 258&nbsp;    local _ee_cnt=${#_ee_Excludes[@]}   # Exclude list length.
 259&nbsp;    [ ${_ee_len} -ne 0 ] || return 0    # Can't edit zero length.
 260&nbsp;    [ ${_ee_cnt} -ne 0 ] || return 0    # Can't edit zero length.
 261&nbsp;    for (( x = 0; x &#60; ${_ee_cnt} ; x++ ))
 262&nbsp;    do
 263&nbsp;        _ee_x=${_ee_Excludes[$x]}
 264&nbsp;        for (( n = 0 ; n &#60; ${_ee_len} ; n++ ))
 265&nbsp;        do
 266&nbsp;            _ee_t=${_ee_Target[$n]}
 267&nbsp;            if [ x"${_ee_t}" == x"${_ee_x}" ]
 268&nbsp;            then
 269&nbsp;                unset _ee_Target[$n]     # Discard match.
 270&nbsp;                [ $# -eq 2 ] &#38;&#38; break    # If 2 arguments, then done.
 271&nbsp;            fi
 272&nbsp;        done
 273&nbsp;    done
 274&nbsp;    eval $2=\( \$\{_ee_Target\[@\]\} \)
 275&nbsp;    set +f
 276&nbsp;    return 0
 277&nbsp;}
 278&nbsp;
 279&nbsp;# This function described in edit_by_glob.bash.
 280&nbsp;# edit_by_glob &#60;excludes_array_name&#62; &#60;target_array_name&#62;
 281&nbsp;edit_by_glob() {
 282&nbsp;    [ $# -eq 2 ] ||
 283&nbsp;    [ $# -eq 3 ] || return 1
 284&nbsp;    local -a _ebg_Excludes
 285&nbsp;    local -a _ebg_Target
 286&nbsp;    local _ebg_x
 287&nbsp;    local _ebg_t
 288&nbsp;    local IFS=${NO_WSP}
 289&nbsp;    set -f
 290&nbsp;    eval _ebg_Excludes=\( \$\{$1\[@\]\} \)
 291&nbsp;    eval _ebg_Target=\( \$\{$2\[@\]\} \)
 292&nbsp;    local _ebg_len=${#_ebg_Target[@]}
 293&nbsp;    local _ebg_cnt=${#_ebg_Excludes[@]}
 294&nbsp;    [ ${_ebg_len} -ne 0 ] || return 0
 295&nbsp;    [ ${_ebg_cnt} -ne 0 ] || return 0
 296&nbsp;    for (( x = 0; x &#60; ${_ebg_cnt} ; x++ ))
 297&nbsp;    do
 298&nbsp;        _ebg_x=${_ebg_Excludes[$x]}
 299&nbsp;        for (( n = 0 ; n &#60; ${_ebg_len} ; n++ ))
 300&nbsp;        do
 301&nbsp;            [ $# -eq 3 ] &#38;&#38; _ebg_x=${_ebg_x}'*'  #  Do prefix edit
 302&nbsp;            if [ ${_ebg_Target[$n]:=} ]          #+ if defined &#38; set.
 303&nbsp;            then
 304&nbsp;                _ebg_t=${_ebg_Target[$n]/#${_ebg_x}/}
 305&nbsp;                [ ${#_ebg_t} -eq 0 ] &#38;&#38; unset _ebg_Target[$n]
 306&nbsp;            fi
 307&nbsp;        done
 308&nbsp;    done
 309&nbsp;    eval $2=\( \$\{_ebg_Target\[@\]\} \)
 310&nbsp;    set +f
 311&nbsp;    return 0
 312&nbsp;}
 313&nbsp;
 314&nbsp;# This function described in unique_lines.bash.
 315&nbsp;# unique_lines &#60;in_name&#62; &#60;out_name&#62;
 316&nbsp;unique_lines() {
 317&nbsp;    [ $# -eq 2 ] || return 1
 318&nbsp;    local -a _ul_in
 319&nbsp;    local -a _ul_out
 320&nbsp;    local -i _ul_cnt
 321&nbsp;    local -i _ul_pos
 322&nbsp;    local _ul_tmp
 323&nbsp;    local IFS=${NO_WSP}
 324&nbsp;    set -f
 325&nbsp;    eval _ul_in=\( \$\{$1\[@\]\} \)
 326&nbsp;    _ul_cnt=${#_ul_in[@]}
 327&nbsp;    for (( _ul_pos = 0 ; _ul_pos &#60; ${_ul_cnt} ; _ul_pos++ ))
 328&nbsp;    do
 329&nbsp;        if [ ${_ul_in[${_ul_pos}]:=} ]      # If defined &#38; not empty
 330&nbsp;        then
 331&nbsp;            _ul_tmp=${_ul_in[${_ul_pos}]}
 332&nbsp;            _ul_out[${#_ul_out[@]}]=${_ul_tmp}
 333&nbsp;            for (( zap = _ul_pos ; zap &#60; ${_ul_cnt} ; zap++ ))
 334&nbsp;            do
 335&nbsp;                [ ${_ul_in[${zap}]:=} ] &#38;&#38;
 336&nbsp;                [ 'x'${_ul_in[${zap}]} == 'x'${_ul_tmp} ] &#38;&#38;
 337&nbsp;                    unset _ul_in[${zap}]
 338&nbsp;            done
 339&nbsp;        fi
 340&nbsp;    done
 341&nbsp;    eval $2=\( \$\{_ul_out\[@\]\} \)
 342&nbsp;    set +f
 343&nbsp;    return 0
 344&nbsp;}
 345&nbsp;
 346&nbsp;# This function described in char_convert.bash.
 347&nbsp;# to_lower &#60;string&#62;
 348&nbsp;to_lower() {
 349&nbsp;    [ $# -eq 1 ] || return 1
 350&nbsp;    local _tl_out
 351&nbsp;    _tl_out=${1//A/a}
 352&nbsp;    _tl_out=${_tl_out//B/b}
 353&nbsp;    _tl_out=${_tl_out//C/c}
 354&nbsp;    _tl_out=${_tl_out//D/d}
 355&nbsp;    _tl_out=${_tl_out//E/e}
 356&nbsp;    _tl_out=${_tl_out//F/f}
 357&nbsp;    _tl_out=${_tl_out//G/g}
 358&nbsp;    _tl_out=${_tl_out//H/h}
 359&nbsp;    _tl_out=${_tl_out//I/i}
 360&nbsp;    _tl_out=${_tl_out//J/j}
 361&nbsp;    _tl_out=${_tl_out//K/k}
 362&nbsp;    _tl_out=${_tl_out//L/l}
 363&nbsp;    _tl_out=${_tl_out//M/m}
 364&nbsp;    _tl_out=${_tl_out//N/n}
 365&nbsp;    _tl_out=${_tl_out//O/o}
 366&nbsp;    _tl_out=${_tl_out//P/p}
 367&nbsp;    _tl_out=${_tl_out//Q/q}
 368&nbsp;    _tl_out=${_tl_out//R/r}
 369&nbsp;    _tl_out=${_tl_out//S/s}
 370&nbsp;    _tl_out=${_tl_out//T/t}
 371&nbsp;    _tl_out=${_tl_out//U/u}
 372&nbsp;    _tl_out=${_tl_out//V/v}
 373&nbsp;    _tl_out=${_tl_out//W/w}
 374&nbsp;    _tl_out=${_tl_out//X/x}
 375&nbsp;    _tl_out=${_tl_out//Y/y}
 376&nbsp;    _tl_out=${_tl_out//Z/z}
 377&nbsp;    echo ${_tl_out}
 378&nbsp;    return 0
 379&nbsp;}
 380&nbsp;
 381&nbsp;#### Application helper functions ####
 382&nbsp;
 383&nbsp;# Not everybody uses dots as separators (APNIC, for example).
 384&nbsp;# This function described in to_dot.bash
 385&nbsp;# to_dot &#60;string&#62;
 386&nbsp;to_dot() {
 387&nbsp;    [ $# -eq 1 ] || return 1
 388&nbsp;    echo ${1//[#|@|%]/.}
 389&nbsp;    return 0
 390&nbsp;}
 391&nbsp;
 392&nbsp;# This function described in is_number.bash.
 393&nbsp;# is_number &#60;input&#62;
 394&nbsp;is_number() {
 395&nbsp;    [ "$#" -eq 1 ]    || return 1  # is blank?
 396&nbsp;    [ x"$1" == 'x0' ] &#38;&#38; return 0  # is zero?
 397&nbsp;    local -i tst
 398&nbsp;    let tst=$1 2&#62;/dev/null         # else is numeric!
 399&nbsp;    return $?
 400&nbsp;}
 401&nbsp;
 402&nbsp;# This function described in is_address.bash.
 403&nbsp;# is_address &#60;input&#62;
 404&nbsp;is_address() {
 405&nbsp;    [ $# -eq 1 ] || return 1    # Blank ==&#62; false
 406&nbsp;    local -a _ia_input
 407&nbsp;    local IFS=${ADR_IFS}
 408&nbsp;    _ia_input=( $1 )
 409&nbsp;    if  [ ${#_ia_input[@]} -eq 4 ]  &#38;&#38;
 410&nbsp;        is_number ${_ia_input[0]}   &#38;&#38;
 411&nbsp;        is_number ${_ia_input[1]}   &#38;&#38;
 412&nbsp;        is_number ${_ia_input[2]}   &#38;&#38;
 413&nbsp;        is_number ${_ia_input[3]}   &#38;&#38;
 414&nbsp;        [ ${_ia_input[0]} -lt 256 ] &#38;&#38;
 415&nbsp;        [ ${_ia_input[1]} -lt 256 ] &#38;&#38;
 416&nbsp;        [ ${_ia_input[2]} -lt 256 ] &#38;&#38;
 417&nbsp;        [ ${_ia_input[3]} -lt 256 ]
 418&nbsp;    then
 419&nbsp;        return 0
 420&nbsp;    else
 421&nbsp;        return 1
 422&nbsp;    fi
 423&nbsp;}
 424&nbsp;
 425&nbsp;#  This function described in split_ip.bash.
 426&nbsp;#  split_ip &#60;IP_address&#62;
 427&nbsp;#+ &#60;array_name_norm&#62; [&#60;array_name_rev&#62;]
 428&nbsp;split_ip() {
 429&nbsp;    [ $# -eq 3 ] ||              #  Either three
 430&nbsp;    [ $# -eq 2 ] || return 1     #+ or two arguments
 431&nbsp;    local -a _si_input
 432&nbsp;    local IFS=${ADR_IFS}
 433&nbsp;    _si_input=( $1 )
 434&nbsp;    IFS=${WSP_IFS}
 435&nbsp;    eval $2=\(\ \$\{_si_input\[@\]\}\ \)
 436&nbsp;    if [ $# -eq 3 ]
 437&nbsp;    then
 438&nbsp;        # Build query order array.
 439&nbsp;        local -a _dns_ip
 440&nbsp;        _dns_ip[0]=${_si_input[3]}
 441&nbsp;        _dns_ip[1]=${_si_input[2]}
 442&nbsp;        _dns_ip[2]=${_si_input[1]}
 443&nbsp;        _dns_ip[3]=${_si_input[0]}
 444&nbsp;        eval $3=\(\ \$\{_dns_ip\[@\]\}\ \)
 445&nbsp;    fi
 446&nbsp;    return 0
 447&nbsp;}
 448&nbsp;
 449&nbsp;# This function described in dot_array.bash.
 450&nbsp;# dot_array &#60;array_name&#62;
 451&nbsp;dot_array() {
 452&nbsp;    [ $# -eq 1 ] || return 1     # Single argument required.
 453&nbsp;    local -a _da_input
 454&nbsp;    eval _da_input=\(\ \$\{$1\[@\]\}\ \)
 455&nbsp;    local IFS=${DOT_IFS}
 456&nbsp;    local _da_output=${_da_input[@]}
 457&nbsp;    IFS=${WSP_IFS}
 458&nbsp;    echo ${_da_output}
 459&nbsp;    return 0
 460&nbsp;}
 461&nbsp;
 462&nbsp;# This function described in file_to_array.bash
 463&nbsp;# file_to_array &#60;file_name&#62; &#60;line_array_name&#62;
 464&nbsp;file_to_array() {
 465&nbsp;    [ $# -eq 2 ] || return 1  # Two arguments required.
 466&nbsp;    local IFS=${NO_WSP}
 467&nbsp;    local -a _fta_tmp_
 468&nbsp;    _fta_tmp_=( $(cat $1) )
 469&nbsp;    eval $2=\( \$\{_fta_tmp_\[@\]\} \)
 470&nbsp;    return 0
 471&nbsp;}
 472&nbsp;
 473&nbsp;#  Columnized print of an array of multi-field strings.
 474&nbsp;#  col_print &#60;array_name&#62; &#60;min_space&#62; &#60;
 475&nbsp;#+ tab_stop [tab_stops]&#62;
 476&nbsp;col_print() {
 477&nbsp;    [ $# -gt 2 ] || return 0
 478&nbsp;    local -a _cp_inp
 479&nbsp;    local -a _cp_spc
 480&nbsp;    local -a _cp_line
 481&nbsp;    local _cp_min
 482&nbsp;    local _cp_mcnt
 483&nbsp;    local _cp_pos
 484&nbsp;    local _cp_cnt
 485&nbsp;    local _cp_tab
 486&nbsp;    local -i _cp
 487&nbsp;    local -i _cpf
 488&nbsp;    local _cp_fld
 489&nbsp;    # WARNING: FOLLOWING LINE NOT BLANK -- IT IS QUOTED SPACES.
 490&nbsp;    local _cp_max='                                                            '
 491&nbsp;    set -f
 492&nbsp;    local IFS=${NO_WSP}
 493&nbsp;    eval _cp_inp=\(\ \$\{$1\[@\]\}\ \)
 494&nbsp;    [ ${#_cp_inp[@]} -gt 0 ] || return 0 # Empty is easy.
 495&nbsp;    _cp_mcnt=$2
 496&nbsp;    _cp_min=${_cp_max:1:${_cp_mcnt}}
 497&nbsp;    shift
 498&nbsp;    shift
 499&nbsp;    _cp_cnt=$#
 500&nbsp;    for (( _cp = 0 ; _cp &#60; _cp_cnt ; _cp++ ))
 501&nbsp;    do
 502&nbsp;        _cp_spc[${#_cp_spc[@]}]="${_cp_max:2:$1}" #"
 503&nbsp;        shift
 504&nbsp;    done
 505&nbsp;    _cp_cnt=${#_cp_inp[@]}
 506&nbsp;    for (( _cp = 0 ; _cp &#60; _cp_cnt ; _cp++ ))
 507&nbsp;    do
 508&nbsp;        _cp_pos=1
 509&nbsp;        IFS=${NO_WSP}$'\x20'
 510&nbsp;        _cp_line=( ${_cp_inp[${_cp}]} )
 511&nbsp;        IFS=${NO_WSP}
 512&nbsp;        for (( _cpf = 0 ; _cpf &#60; ${#_cp_line[@]} ; _cpf++ ))
 513&nbsp;        do
 514&nbsp;            _cp_tab=${_cp_spc[${_cpf}]:${_cp_pos}}
 515&nbsp;            if [ ${#_cp_tab} -lt ${_cp_mcnt} ]
 516&nbsp;            then
 517&nbsp;                _cp_tab="${_cp_min}"
 518&nbsp;            fi
 519&nbsp;            echo -n "${_cp_tab}"
 520&nbsp;            (( _cp_pos = ${_cp_pos} + ${#_cp_tab} ))
 521&nbsp;            _cp_fld="${_cp_line[${_cpf}]}"
 522&nbsp;            echo -n ${_cp_fld}
 523&nbsp;            (( _cp_pos = ${_cp_pos} + ${#_cp_fld} ))
 524&nbsp;        done
 525&nbsp;        echo
 526&nbsp;    done
 527&nbsp;    set +f
 528&nbsp;    return 0
 529&nbsp;}
 530&nbsp;
 531&nbsp;# # # # 'Hunt the Spammer' data flow # # # #
 532&nbsp;
 533&nbsp;# Application return code
 534&nbsp;declare -i _hs_RC
 535&nbsp;
 536&nbsp;# Original input, from which IP addresses are removed
 537&nbsp;# After which, domain names to check
 538&nbsp;declare -a uc_name
 539&nbsp;
 540&nbsp;# Original input IP addresses are moved here
 541&nbsp;# After which, IP addresses to check
 542&nbsp;declare -a uc_address
 543&nbsp;
 544&nbsp;# Names against which address expansion run
 545&nbsp;# Ready for name detail lookup
 546&nbsp;declare -a chk_name
 547&nbsp;
 548&nbsp;# Addresses against which name expansion run
 549&nbsp;# Ready for address detail lookup
 550&nbsp;declare -a chk_address
 551&nbsp;
 552&nbsp;#  Recursion is depth-first-by-name.
 553&nbsp;#  The expand_input_address maintains this list
 554&nbsp;#+ to prohibit looking up addresses twice during
 555&nbsp;#+ domain name recursion.
 556&nbsp;declare -a been_there_addr
 557&nbsp;been_there_addr=( '127.0.0.1' ) # Whitelist localhost
 558&nbsp;
 559&nbsp;# Names which we have checked (or given up on)
 560&nbsp;declare -a known_name
 561&nbsp;
 562&nbsp;# Addresses which we have checked (or given up on)
 563&nbsp;declare -a known_address
 564&nbsp;
 565&nbsp;#  List of zero or more Blacklist servers to check.
 566&nbsp;#  Each 'known_address' will be checked against each server,
 567&nbsp;#+ with negative replies and failures suppressed.
 568&nbsp;declare -a list_server
 569&nbsp;
 570&nbsp;# Indirection limit - set to zero == no limit
 571&nbsp;indirect=${SPAMMER_LIMIT:=2}
 572&nbsp;
 573&nbsp;# # # # 'Hunt the Spammer' information output data # # # #
 574&nbsp;
 575&nbsp;# Any domain name may have multiple IP addresses.
 576&nbsp;# Any IP address may have multiple domain names.
 577&nbsp;# Therefore, track unique address-name pairs.
 578&nbsp;declare -a known_pair
 579&nbsp;declare -a reverse_pair
 580&nbsp;
 581&nbsp;#  In addition to the data flow variables; known_address
 582&nbsp;#+ known_name and list_server, the following are output to the
 583&nbsp;#+ external graphics interface file.
 584&nbsp;
 585&nbsp;# Authority chain, parent -&#62; SOA fields.
 586&nbsp;declare -a auth_chain
 587&nbsp;
 588&nbsp;# Reference chain, parent name -&#62; child name
 589&nbsp;declare -a ref_chain
 590&nbsp;
 591&nbsp;# DNS chain - domain name -&#62; address
 592&nbsp;declare -a name_address
 593&nbsp;
 594&nbsp;# Name and service pairs - domain name -&#62; service
 595&nbsp;declare -a name_srvc
 596&nbsp;
 597&nbsp;# Name and resource pairs - domain name -&#62; Resource Record
 598&nbsp;declare -a name_resource
 599&nbsp;
 600&nbsp;# Parent and Child pairs - parent name -&#62; child name
 601&nbsp;# This MAY NOT be the same as the ref_chain followed!
 602&nbsp;declare -a parent_child
 603&nbsp;
 604&nbsp;# Address and Blacklist hit pairs - address-&#62;server
 605&nbsp;declare -a address_hits
 606&nbsp;
 607&nbsp;# Dump interface file data
 608&nbsp;declare -f _dot_dump
 609&nbsp;_dot_dump=pend_dummy   # Initially a no-op
 610&nbsp;
 611&nbsp;#  Data dump is enabled by setting the environment variable SPAMMER_DATA
 612&nbsp;#+ to the name of a writable file.
 613&nbsp;declare _dot_file
 614&nbsp;
 615&nbsp;# Helper function for the dump-to-dot-file function
 616&nbsp;# dump_to_dot &#60;array_name&#62; &#60;prefix&#62;
 617&nbsp;dump_to_dot() {
 618&nbsp;    local -a _dda_tmp
 619&nbsp;    local -i _dda_cnt
 620&nbsp;    local _dda_form='    '${2}'%04u %s\n'
 621&nbsp;    local IFS=${NO_WSP}
 622&nbsp;    eval _dda_tmp=\(\ \$\{$1\[@\]\}\ \)
 623&nbsp;    _dda_cnt=${#_dda_tmp[@]}
 624&nbsp;    if [ ${_dda_cnt} -gt 0 ]
 625&nbsp;    then
 626&nbsp;        for (( _dda = 0 ; _dda &#60; _dda_cnt ; _dda++ ))
 627&nbsp;        do
 628&nbsp;            printf "${_dda_form}" \
 629&nbsp;                   "${_dda}" "${_dda_tmp[${_dda}]}" &#62;&#62;${_dot_file}
 630&nbsp;        done
 631&nbsp;    fi
 632&nbsp;}
 633&nbsp;
 634&nbsp;# Which will also set _dot_dump to this function . . .
 635&nbsp;dump_dot() {
 636&nbsp;    local -i _dd_cnt
 637&nbsp;    echo '# Data vintage: '$(date -R) &#62;${_dot_file}
 638&nbsp;    echo '# ABS Guide: is_spammer.bash; v2, 2004-msz' &#62;&#62;${_dot_file}
 639&nbsp;    echo &#62;&#62;${_dot_file}
 640&nbsp;    echo 'digraph G {' &#62;&#62;${_dot_file}
 641&nbsp;
 642&nbsp;    if [ ${#known_name[@]} -gt 0 ]
 643&nbsp;    then
 644&nbsp;        echo &#62;&#62;${_dot_file}
 645&nbsp;        echo '# Known domain name nodes' &#62;&#62;${_dot_file}
 646&nbsp;        _dd_cnt=${#known_name[@]}
 647&nbsp;        for (( _dd = 0 ; _dd &#60; _dd_cnt ; _dd++ ))
 648&nbsp;        do
 649&nbsp;            printf '    N%04u [label="%s"] ;\n' \
 650&nbsp;                   "${_dd}" "${known_name[${_dd}]}" &#62;&#62;${_dot_file}
 651&nbsp;        done
 652&nbsp;    fi
 653&nbsp;
 654&nbsp;    if [ ${#known_address[@]} -gt 0 ]
 655&nbsp;    then
 656&nbsp;        echo &#62;&#62;${_dot_file}
 657&nbsp;        echo '# Known address nodes' &#62;&#62;${_dot_file}
 658&nbsp;        _dd_cnt=${#known_address[@]}
 659&nbsp;        for (( _dd = 0 ; _dd &#60; _dd_cnt ; _dd++ ))
 660&nbsp;        do
 661&nbsp;            printf '    A%04u [label="%s"] ;\n' \
 662&nbsp;                   "${_dd}" "${known_address[${_dd}]}" &#62;&#62;${_dot_file}
 663&nbsp;        done
 664&nbsp;    fi
 665&nbsp;
 666&nbsp;    echo                                   &#62;&#62;${_dot_file}
 667&nbsp;    echo '/*'                              &#62;&#62;${_dot_file}
 668&nbsp;    echo ' * Known relationships :: User conversion to'  &#62;&#62;${_dot_file}
 669&nbsp;    echo ' * graphic form by hand or program required.'  &#62;&#62;${_dot_file}
 670&nbsp;    echo ' *'                              &#62;&#62;${_dot_file}
 671&nbsp;
 672&nbsp;    if [ ${#auth_chain[@]} -gt 0 ]
 673&nbsp;    then
 674&nbsp;      echo &#62;&#62;${_dot_file}
 675&nbsp;      echo '# Authority ref. edges followed &#38; field source.' &#62;&#62;${_dot_file}
 676&nbsp;        dump_to_dot auth_chain AC
 677&nbsp;    fi
 678&nbsp;
 679&nbsp;    if [ ${#ref_chain[@]} -gt 0 ]
 680&nbsp;    then
 681&nbsp;        echo &#62;&#62;${_dot_file}
 682&nbsp;        echo '# Name ref. edges followed and field source.' &#62;&#62;${_dot_file}
 683&nbsp;        dump_to_dot ref_chain RC
 684&nbsp;    fi
 685&nbsp;
 686&nbsp;    if [ ${#name_address[@]} -gt 0 ]
 687&nbsp;    then
 688&nbsp;        echo &#62;&#62;${_dot_file}
 689&nbsp;        echo '# Known name-&#62;address edges' &#62;&#62;${_dot_file}
 690&nbsp;        dump_to_dot name_address NA
 691&nbsp;    fi
 692&nbsp;
 693&nbsp;    if [ ${#name_srvc[@]} -gt 0 ]
 694&nbsp;    then
 695&nbsp;        echo &#62;&#62;${_dot_file}
 696&nbsp;        echo '# Known name-&#62;service edges' &#62;&#62;${_dot_file}
 697&nbsp;        dump_to_dot name_srvc NS
 698&nbsp;    fi
 699&nbsp;
 700&nbsp;    if [ ${#name_resource[@]} -gt 0 ]
 701&nbsp;    then
 702&nbsp;        echo &#62;&#62;${_dot_file}
 703&nbsp;        echo '# Known name-&#62;resource edges' &#62;&#62;${_dot_file}
 704&nbsp;        dump_to_dot name_resource NR
 705&nbsp;    fi
 706&nbsp;
 707&nbsp;    if [ ${#parent_child[@]} -gt 0 ]
 708&nbsp;    then
 709&nbsp;        echo &#62;&#62;${_dot_file}
 710&nbsp;        echo '# Known parent-&#62;child edges' &#62;&#62;${_dot_file}
 711&nbsp;        dump_to_dot parent_child PC
 712&nbsp;    fi
 713&nbsp;
 714&nbsp;    if [ ${#list_server[@]} -gt 0 ]
 715&nbsp;    then
 716&nbsp;        echo &#62;&#62;${_dot_file}
 717&nbsp;        echo '# Known Blacklist nodes' &#62;&#62;${_dot_file}
 718&nbsp;        _dd_cnt=${#list_server[@]}
 719&nbsp;        for (( _dd = 0 ; _dd &#60; _dd_cnt ; _dd++ ))
 720&nbsp;        do
 721&nbsp;            printf '    LS%04u [label="%s"] ;\n' \
 722&nbsp;                   "${_dd}" "${list_server[${_dd}]}" &#62;&#62;${_dot_file}
 723&nbsp;        done
 724&nbsp;    fi
 725&nbsp;
 726&nbsp;    unique_lines address_hits address_hits
 727&nbsp;    if [ ${#address_hits[@]} -gt 0 ]
 728&nbsp;    then
 729&nbsp;      echo &#62;&#62;${_dot_file}
 730&nbsp;      echo '# Known address-&#62;Blacklist_hit edges' &#62;&#62;${_dot_file}
 731&nbsp;      echo '# CAUTION: dig warnings can trigger false hits.' &#62;&#62;${_dot_file}
 732&nbsp;       dump_to_dot address_hits AH
 733&nbsp;    fi
 734&nbsp;    echo          &#62;&#62;${_dot_file}
 735&nbsp;    echo ' *'     &#62;&#62;${_dot_file}
 736&nbsp;    echo ' * That is a lot of relationships. Happy graphing.' &#62;&#62;${_dot_file}
 737&nbsp;    echo ' */'    &#62;&#62;${_dot_file}
 738&nbsp;    echo '}'      &#62;&#62;${_dot_file}
 739&nbsp;    return 0
 740&nbsp;}
 741&nbsp;
 742&nbsp;# # # # 'Hunt the Spammer' execution flow # # # #
 743&nbsp;
 744&nbsp;#  Execution trace is enabled by setting the
 745&nbsp;#+ environment variable SPAMMER_TRACE to the name of a writable file.
 746&nbsp;declare -a _trace_log
 747&nbsp;declare _log_file
 748&nbsp;
 749&nbsp;# Function to fill the trace log
 750&nbsp;trace_logger() {
 751&nbsp;    _trace_log[${#_trace_log[@]}]=${_pend_current_}
 752&nbsp;}
 753&nbsp;
 754&nbsp;# Dump trace log to file function variable.
 755&nbsp;declare -f _log_dump
 756&nbsp;_log_dump=pend_dummy   # Initially a no-op.
 757&nbsp;
 758&nbsp;# Dump the trace log to a file.
 759&nbsp;dump_log() {
 760&nbsp;    local -i _dl_cnt
 761&nbsp;    _dl_cnt=${#_trace_log[@]}
 762&nbsp;    for (( _dl = 0 ; _dl &#60; _dl_cnt ; _dl++ ))
 763&nbsp;    do
 764&nbsp;        echo ${_trace_log[${_dl}]} &#62;&#62; ${_log_file}
 765&nbsp;    done
 766&nbsp;    _dl_cnt=${#_pending_[@]}
 767&nbsp;    if [ ${_dl_cnt} -gt 0 ]
 768&nbsp;    then
 769&nbsp;        _dl_cnt=${_dl_cnt}-1
 770&nbsp;        echo '# # # Operations stack not empty # # #' &#62;&#62; ${_log_file}
 771&nbsp;        for (( _dl = ${_dl_cnt} ; _dl &#62;= 0 ; _dl-- ))
 772&nbsp;        do
 773&nbsp;            echo ${_pending_[${_dl}]} &#62;&#62; ${_log_file}
 774&nbsp;        done
 775&nbsp;    fi
 776&nbsp;}
 777&nbsp;
 778&nbsp;# # # Utility program 'dig' wrappers # # #
 779&nbsp;#
 780&nbsp;#  These wrappers are derived from the
 781&nbsp;#+ examples shown in dig_wrappers.bash.
 782&nbsp;#
 783&nbsp;#  The major difference is these return
 784&nbsp;#+ their results as a list in an array.
 785&nbsp;#
 786&nbsp;#  See dig_wrappers.bash for details and
 787&nbsp;#+ use that script to develop any changes.
 788&nbsp;#
 789&nbsp;# # #
 790&nbsp;
 791&nbsp;# Short form answer: 'dig' parses answer.
 792&nbsp;
 793&nbsp;# Forward lookup :: Name -&#62; Address
 794&nbsp;# short_fwd &#60;domain_name&#62; &#60;array_name&#62;
 795&nbsp;short_fwd() {
 796&nbsp;    local -a _sf_reply
 797&nbsp;    local -i _sf_rc
 798&nbsp;    local -i _sf_cnt
 799&nbsp;    IFS=${NO_WSP}
 800&nbsp;echo -n '.'
 801&nbsp;# echo 'sfwd: '${1}
 802&nbsp;  _sf_reply=( $(dig +short ${1} -c in -t a 2&#62;/dev/null) )
 803&nbsp;  _sf_rc=$?
 804&nbsp;  if [ ${_sf_rc} -ne 0 ]
 805&nbsp;  then
 806&nbsp;    _trace_log[${#_trace_log[@]}]='## Lookup error '${_sf_rc}' on '${1}' ##'
 807&nbsp;# [ ${_sf_rc} -ne 9 ] &#38;&#38; pend_drop
 808&nbsp;        return ${_sf_rc}
 809&nbsp;    else
 810&nbsp;        # Some versions of 'dig' return warnings on stdout.
 811&nbsp;        _sf_cnt=${#_sf_reply[@]}
 812&nbsp;        for (( _sf = 0 ; _sf &#60; ${_sf_cnt} ; _sf++ ))
 813&nbsp;        do
 814&nbsp;            [ 'x'${_sf_reply[${_sf}]:0:2} == 'x;;' ] &#38;&#38;
 815&nbsp;                unset _sf_reply[${_sf}]
 816&nbsp;        done
 817&nbsp;        eval $2=\( \$\{_sf_reply\[@\]\} \)
 818&nbsp;    fi
 819&nbsp;    return 0
 820&nbsp;}
 821&nbsp;
 822&nbsp;# Reverse lookup :: Address -&#62; Name
 823&nbsp;# short_rev &#60;ip_address&#62; &#60;array_name&#62;
 824&nbsp;short_rev() {
 825&nbsp;    local -a _sr_reply
 826&nbsp;    local -i _sr_rc
 827&nbsp;    local -i _sr_cnt
 828&nbsp;    IFS=${NO_WSP}
 829&nbsp;echo -n '.'
 830&nbsp;# echo 'srev: '${1}
 831&nbsp;  _sr_reply=( $(dig +short -x ${1} 2&#62;/dev/null) )
 832&nbsp;  _sr_rc=$?
 833&nbsp;  if [ ${_sr_rc} -ne 0 ]
 834&nbsp;  then
 835&nbsp;    _trace_log[${#_trace_log[@]}]='## Lookup error '${_sr_rc}' on '${1}' ##'
 836&nbsp;# [ ${_sr_rc} -ne 9 ] &#38;&#38; pend_drop
 837&nbsp;        return ${_sr_rc}
 838&nbsp;    else
 839&nbsp;        # Some versions of 'dig' return warnings on stdout.
 840&nbsp;        _sr_cnt=${#_sr_reply[@]}
 841&nbsp;        for (( _sr = 0 ; _sr &#60; ${_sr_cnt} ; _sr++ ))
 842&nbsp;        do
 843&nbsp;            [ 'x'${_sr_reply[${_sr}]:0:2} == 'x;;' ] &#38;&#38;
 844&nbsp;                unset _sr_reply[${_sr}]
 845&nbsp;        done
 846&nbsp;        eval $2=\( \$\{_sr_reply\[@\]\} \)
 847&nbsp;    fi
 848&nbsp;    return 0
 849&nbsp;}
 850&nbsp;
 851&nbsp;# Special format lookup used to query blacklist servers.
 852&nbsp;# short_text &#60;ip_address&#62; &#60;array_name&#62;
 853&nbsp;short_text() {
 854&nbsp;    local -a _st_reply
 855&nbsp;    local -i _st_rc
 856&nbsp;    local -i _st_cnt
 857&nbsp;    IFS=${NO_WSP}
 858&nbsp;# echo 'stxt: '${1}
 859&nbsp;  _st_reply=( $(dig +short ${1} -c in -t txt 2&#62;/dev/null) )
 860&nbsp;  _st_rc=$?
 861&nbsp;  if [ ${_st_rc} -ne 0 ]
 862&nbsp;  then
 863&nbsp;    _trace_log[${#_trace_log[@]}]='##Text lookup error '${_st_rc}' on '${1}'##'
 864&nbsp;# [ ${_st_rc} -ne 9 ] &#38;&#38; pend_drop
 865&nbsp;        return ${_st_rc}
 866&nbsp;    else
 867&nbsp;        # Some versions of 'dig' return warnings on stdout.
 868&nbsp;        _st_cnt=${#_st_reply[@]}
 869&nbsp;        for (( _st = 0 ; _st &#60; ${#_st_cnt} ; _st++ ))
 870&nbsp;        do
 871&nbsp;            [ 'x'${_st_reply[${_st}]:0:2} == 'x;;' ] &#38;&#38;
 872&nbsp;                unset _st_reply[${_st}]
 873&nbsp;        done
 874&nbsp;        eval $2=\( \$\{_st_reply\[@\]\} \)
 875&nbsp;    fi
 876&nbsp;    return 0
 877&nbsp;}
 878&nbsp;
 879&nbsp;# The long forms, a.k.a., the parse it yourself versions
 880&nbsp;
 881&nbsp;# RFC 2782   Service lookups
 882&nbsp;# dig +noall +nofail +answer _ldap._tcp.openldap.org -t srv
 883&nbsp;# _&#60;service&#62;._&#60;protocol&#62;.&#60;domain_name&#62;
 884&nbsp;# _ldap._tcp.openldap.org. 3600   IN     SRV    0 0 389 ldap.openldap.org.
 885&nbsp;# domain TTL Class SRV Priority Weight Port Target
 886&nbsp;
 887&nbsp;# Forward lookup :: Name -&#62; poor man's zone transfer
 888&nbsp;# long_fwd &#60;domain_name&#62; &#60;array_name&#62;
 889&nbsp;long_fwd() {
 890&nbsp;    local -a _lf_reply
 891&nbsp;    local -i _lf_rc
 892&nbsp;    local -i _lf_cnt
 893&nbsp;    IFS=${NO_WSP}
 894&nbsp;echo -n ':'
 895&nbsp;# echo 'lfwd: '${1}
 896&nbsp;  _lf_reply=( $(
 897&nbsp;     dig +noall +nofail +answer +authority +additional \
 898&nbsp;         ${1} -t soa ${1} -t mx ${1} -t any 2&#62;/dev/null) )
 899&nbsp;  _lf_rc=$?
 900&nbsp;  if [ ${_lf_rc} -ne 0 ]
 901&nbsp;  then
 902&nbsp;    _trace_log[${#_trace_log[@]}]='# Zone lookup err '${_lf_rc}' on '${1}' #'
 903&nbsp;# [ ${_lf_rc} -ne 9 ] &#38;&#38; pend_drop
 904&nbsp;        return ${_lf_rc}
 905&nbsp;    else
 906&nbsp;        # Some versions of 'dig' return warnings on stdout.
 907&nbsp;        _lf_cnt=${#_lf_reply[@]}
 908&nbsp;        for (( _lf = 0 ; _lf &#60; ${_lf_cnt} ; _lf++ ))
 909&nbsp;        do
 910&nbsp;            [ 'x'${_lf_reply[${_lf}]:0:2} == 'x;;' ] &#38;&#38;
 911&nbsp;                unset _lf_reply[${_lf}]
 912&nbsp;        done
 913&nbsp;        eval $2=\( \$\{_lf_reply\[@\]\} \)
 914&nbsp;    fi
 915&nbsp;    return 0
 916&nbsp;}
 917&nbsp;#  The reverse lookup domain name corresponding to the IPv6 address:
 918&nbsp;#      4321:0:1:2:3:4:567:89ab
 919&nbsp;#  would be (nibble, I.E: Hexdigit) reversed:
 920&nbsp;#  b.a.9.8.7.6.5.0.4.0.0.0.3.0.0.0.2.0.0.0.1.0.0.0.0.0.0.0.1.2.3.4.IP6.ARPA.
 921&nbsp;
 922&nbsp;# Reverse lookup :: Address -&#62; poor man's delegation chain
 923&nbsp;# long_rev &#60;rev_ip_address&#62; &#60;array_name&#62;
 924&nbsp;long_rev() {
 925&nbsp;    local -a _lr_reply
 926&nbsp;    local -i _lr_rc
 927&nbsp;    local -i _lr_cnt
 928&nbsp;    local _lr_dns
 929&nbsp;    _lr_dns=${1}'.in-addr.arpa.'
 930&nbsp;    IFS=${NO_WSP}
 931&nbsp;echo -n ':'
 932&nbsp;# echo 'lrev: '${1}
 933&nbsp;  _lr_reply=( $(
 934&nbsp;       dig +noall +nofail +answer +authority +additional \
 935&nbsp;           ${_lr_dns} -t soa ${_lr_dns} -t any 2&#62;/dev/null) )
 936&nbsp;  _lr_rc=$?
 937&nbsp;  if [ ${_lr_rc} -ne 0 ]
 938&nbsp;  then
 939&nbsp;    _trace_log[${#_trace_log[@]}]='# Deleg lkp error '${_lr_rc}' on '${1}' #'
 940&nbsp;# [ ${_lr_rc} -ne 9 ] &#38;&#38; pend_drop
 941&nbsp;        return ${_lr_rc}
 942&nbsp;    else
 943&nbsp;        # Some versions of 'dig' return warnings on stdout.
 944&nbsp;        _lr_cnt=${#_lr_reply[@]}
 945&nbsp;        for (( _lr = 0 ; _lr &#60; ${_lr_cnt} ; _lr++ ))
 946&nbsp;        do
 947&nbsp;            [ 'x'${_lr_reply[${_lr}]:0:2} == 'x;;' ] &#38;&#38;
 948&nbsp;                unset _lr_reply[${_lr}]
 949&nbsp;        done
 950&nbsp;        eval $2=\( \$\{_lr_reply\[@\]\} \)
 951&nbsp;    fi
 952&nbsp;    return 0
 953&nbsp;}
 954&nbsp;
 955&nbsp;# # # Application specific functions # # #
 956&nbsp;
 957&nbsp;# Mung a possible name; suppresses root and TLDs.
 958&nbsp;# name_fixup &#60;string&#62;
 959&nbsp;name_fixup(){
 960&nbsp;    local -a _nf_tmp
 961&nbsp;    local -i _nf_end
 962&nbsp;    local _nf_str
 963&nbsp;    local IFS
 964&nbsp;    _nf_str=$(to_lower ${1})
 965&nbsp;    _nf_str=$(to_dot ${_nf_str})
 966&nbsp;    _nf_end=${#_nf_str}-1
 967&nbsp;    [ ${_nf_str:${_nf_end}} != '.' ] &#38;&#38;
 968&nbsp;        _nf_str=${_nf_str}'.'
 969&nbsp;    IFS=${ADR_IFS}
 970&nbsp;    _nf_tmp=( ${_nf_str} )
 971&nbsp;    IFS=${WSP_IFS}
 972&nbsp;    _nf_end=${#_nf_tmp[@]}
 973&nbsp;    case ${_nf_end} in
 974&nbsp;    0) # No dots, only dots.
 975&nbsp;        echo
 976&nbsp;        return 1
 977&nbsp;    ;;
 978&nbsp;    1) # Only a TLD.
 979&nbsp;        echo
 980&nbsp;        return 1
 981&nbsp;    ;;
 982&nbsp;    2) # Maybe okay.
 983&nbsp;       echo ${_nf_str}
 984&nbsp;       return 0
 985&nbsp;       # Needs a lookup table?
 986&nbsp;       if [ ${#_nf_tmp[1]} -eq 2 ]
 987&nbsp;       then # Country coded TLD.
 988&nbsp;           echo
 989&nbsp;           return 1
 990&nbsp;       else
 991&nbsp;           echo ${_nf_str}
 992&nbsp;           return 0
 993&nbsp;       fi
 994&nbsp;    ;;
 995&nbsp;    esac
 996&nbsp;    echo ${_nf_str}
 997&nbsp;    return 0
 998&nbsp;}
 999&nbsp;
 1000&nbsp;# Grope and mung original input(s).
 1001&nbsp;split_input() {
 1002&nbsp;    [ ${#uc_name[@]} -gt 0 ] || return 0
 1003&nbsp;    local -i _si_cnt
 1004&nbsp;    local -i _si_len
 1005&nbsp;    local _si_str
 1006&nbsp;    unique_lines uc_name uc_name
 1007&nbsp;    _si_cnt=${#uc_name[@]}
 1008&nbsp;    for (( _si = 0 ; _si &#60; _si_cnt ; _si++ ))
 1009&nbsp;    do
 1010&nbsp;        _si_str=${uc_name[$_si]}
 1011&nbsp;        if is_address ${_si_str}
 1012&nbsp;        then
 1013&nbsp;            uc_address[${#uc_address[@]}]=${_si_str}
 1014&nbsp;            unset uc_name[$_si]
 1015&nbsp;        else
 1016&nbsp;            if ! uc_name[$_si]=$(name_fixup ${_si_str})
 1017&nbsp;            then
 1018&nbsp;                unset ucname[$_si]
 1019&nbsp;            fi
 1020&nbsp;        fi
 1021&nbsp;    done
 1022&nbsp;  uc_name=( ${uc_name[@]} )
 1023&nbsp;  _si_cnt=${#uc_name[@]}
 1024&nbsp;  _trace_log[${#_trace_log[@]}]='#Input '${_si_cnt}' unchkd name input(s).#'
 1025&nbsp;  _si_cnt=${#uc_address[@]}
 1026&nbsp;  _trace_log[${#_trace_log[@]}]='#Input '${_si_cnt}' unchkd addr input(s).#'
 1027&nbsp;    return 0
 1028&nbsp;}
 1029&nbsp;
 1030&nbsp;# # # Discovery functions -- recursively interlocked by external data # # #
 1031&nbsp;# # # The leading 'if list is empty; return 0' in each is required. # # #
 1032&nbsp;
 1033&nbsp;# Recursion limiter
 1034&nbsp;# limit_chk() &#60;next_level&#62;
 1035&nbsp;limit_chk() {
 1036&nbsp;    local -i _lc_lmt
 1037&nbsp;    # Check indirection limit.
 1038&nbsp;    if [ ${indirect} -eq 0 ] || [ $# -eq 0 ]
 1039&nbsp;    then
 1040&nbsp;        # The 'do-forever' choice
 1041&nbsp;        echo 1                 # Any value will do.
 1042&nbsp;        return 0               # OK to continue.
 1043&nbsp;    else
 1044&nbsp;        # Limiting is in effect.
 1045&nbsp;        if [ ${indirect} -lt ${1} ]
 1046&nbsp;        then
 1047&nbsp;            echo ${1}          # Whatever.
 1048&nbsp;            return 1           # Stop here.
 1049&nbsp;        else
 1050&nbsp;            _lc_lmt=${1}+1     # Bump the given limit.
 1051&nbsp;            echo ${_lc_lmt}    # Echo it.
 1052&nbsp;            return 0           # OK to continue.
 1053&nbsp;        fi
 1054&nbsp;    fi
 1055&nbsp;}
 1056&nbsp;
 1057&nbsp;# For each name in uc_name:
 1058&nbsp;#     Move name to chk_name.
 1059&nbsp;#     Add addresses to uc_address.
 1060&nbsp;#     Pend expand_input_address.
 1061&nbsp;#     Repeat until nothing new found.
 1062&nbsp;# expand_input_name &#60;indirection_limit&#62;
 1063&nbsp;expand_input_name() {
 1064&nbsp;    [ ${#uc_name[@]} -gt 0 ] || return 0
 1065&nbsp;    local -a _ein_addr
 1066&nbsp;    local -a _ein_new
 1067&nbsp;    local -i _ucn_cnt
 1068&nbsp;    local -i _ein_cnt
 1069&nbsp;    local _ein_tst
 1070&nbsp;    _ucn_cnt=${#uc_name[@]}
 1071&nbsp;
 1072&nbsp;    if  ! _ein_cnt=$(limit_chk ${1})
 1073&nbsp;    then
 1074&nbsp;        return 0
 1075&nbsp;    fi
 1076&nbsp;
 1077&nbsp;    for (( _ein = 0 ; _ein &#60; _ucn_cnt ; _ein++ ))
 1078&nbsp;    do
 1079&nbsp;        if short_fwd ${uc_name[${_ein}]} _ein_new
 1080&nbsp;        then
 1081&nbsp;          for (( _ein_cnt = 0 ; _ein_cnt &#60; ${#_ein_new[@]}; _ein_cnt++ ))
 1082&nbsp;          do
 1083&nbsp;              _ein_tst=${_ein_new[${_ein_cnt}]}
 1084&nbsp;              if is_address ${_ein_tst}
 1085&nbsp;              then
 1086&nbsp;                  _ein_addr[${#_ein_addr[@]}]=${_ein_tst}
 1087&nbsp;              fi
 1088&nbsp;    done
 1089&nbsp;        fi
 1090&nbsp;    done
 1091&nbsp;    unique_lines _ein_addr _ein_addr     # Scrub duplicates.
 1092&nbsp;    edit_exact chk_address _ein_addr     # Scrub pending detail.
 1093&nbsp;    edit_exact known_address _ein_addr   # Scrub already detailed.
 1094&nbsp; if [ ${#_ein_addr[@]} -gt 0 ]        # Anything new?
 1095&nbsp; then
 1096&nbsp;   uc_address=( ${uc_address[@]} ${_ein_addr[@]} )
 1097&nbsp;   pend_func expand_input_address ${1}
 1098&nbsp;   _trace_log[${#_trace_log[@]}]='#Add '${#_ein_addr[@]}' unchkd addr inp.#'
 1099&nbsp;    fi
 1100&nbsp;    edit_exact chk_name uc_name          # Scrub pending detail.
 1101&nbsp;    edit_exact known_name uc_name        # Scrub already detailed.
 1102&nbsp;    if [ ${#uc_name[@]} -gt 0 ]
 1103&nbsp;    then
 1104&nbsp;        chk_name=( ${chk_name[@]} ${uc_name[@]}  )
 1105&nbsp;        pend_func detail_each_name ${1}
 1106&nbsp;    fi
 1107&nbsp;    unset uc_name[@]
 1108&nbsp;    return 0
 1109&nbsp;}
 1110&nbsp;
 1111&nbsp;# For each address in uc_address:
 1112&nbsp;#     Move address to chk_address.
 1113&nbsp;#     Add names to uc_name.
 1114&nbsp;#     Pend expand_input_name.
 1115&nbsp;#     Repeat until nothing new found.
 1116&nbsp;# expand_input_address &#60;indirection_limit&#62;
 1117&nbsp;expand_input_address() {
 1118&nbsp;    [ ${#uc_address[@]} -gt 0 ] || return 0
 1119&nbsp;    local -a _eia_addr
 1120&nbsp;    local -a _eia_name
 1121&nbsp;    local -a _eia_new
 1122&nbsp;    local -i _uca_cnt
 1123&nbsp;    local -i _eia_cnt
 1124&nbsp;    local _eia_tst
 1125&nbsp;    unique_lines uc_address _eia_addr
 1126&nbsp;    unset uc_address[@]
 1127&nbsp;    edit_exact been_there_addr _eia_addr
 1128&nbsp;    _uca_cnt=${#_eia_addr[@]}
 1129&nbsp;    [ ${_uca_cnt} -gt 0 ] &#38;&#38;
 1130&nbsp;        been_there_addr=( ${been_there_addr[@]} ${_eia_addr[@]} )
 1131&nbsp;
 1132&nbsp;    for (( _eia = 0 ; _eia &#60; _uca_cnt ; _eia++ ))
 1133&nbsp;     do
 1134&nbsp;       if short_rev ${_eia_addr[${_eia}]} _eia_new
 1135&nbsp;       then
 1136&nbsp;         for (( _eia_cnt = 0 ; _eia_cnt &#60; ${#_eia_new[@]} ; _eia_cnt++ ))
 1137&nbsp;         do
 1138&nbsp;           _eia_tst=${_eia_new[${_eia_cnt}]}
 1139&nbsp;           if _eia_tst=$(name_fixup ${_eia_tst})
 1140&nbsp;           then
 1141&nbsp;             _eia_name[${#_eia_name[@]}]=${_eia_tst}
 1142&nbsp;       fi
 1143&nbsp;     done
 1144&nbsp;           fi
 1145&nbsp;    done
 1146&nbsp;    unique_lines _eia_name _eia_name     # Scrub duplicates.
 1147&nbsp;    edit_exact chk_name _eia_name        # Scrub pending detail.
 1148&nbsp;    edit_exact known_name _eia_name      # Scrub already detailed.
 1149&nbsp; if [ ${#_eia_name[@]} -gt 0 ]        # Anything new?
 1150&nbsp; then
 1151&nbsp;   uc_name=( ${uc_name[@]} ${_eia_name[@]} )
 1152&nbsp;   pend_func expand_input_name ${1}
 1153&nbsp;   _trace_log[${#_trace_log[@]}]='#Add '${#_eia_name[@]}' unchkd name inp.#'
 1154&nbsp;    fi
 1155&nbsp;    edit_exact chk_address _eia_addr     # Scrub pending detail.
 1156&nbsp;    edit_exact known_address _eia_addr   # Scrub already detailed.
 1157&nbsp;    if [ ${#_eia_addr[@]} -gt 0 ]        # Anything new?
 1158&nbsp;    then
 1159&nbsp;        chk_address=( ${chk_address[@]} ${_eia_addr[@]} )
 1160&nbsp;        pend_func detail_each_address ${1}
 1161&nbsp;    fi
 1162&nbsp;    return 0
 1163&nbsp;}
 1164&nbsp;
 1165&nbsp;# The parse-it-yourself zone reply.
 1166&nbsp;# The input is the chk_name list.
 1167&nbsp;# detail_each_name &#60;indirection_limit&#62;
 1168&nbsp;detail_each_name() {
 1169&nbsp;    [ ${#chk_name[@]} -gt 0 ] || return 0
 1170&nbsp;    local -a _den_chk       # Names to check
 1171&nbsp;    local -a _den_name      # Names found here
 1172&nbsp;    local -a _den_address   # Addresses found here
 1173&nbsp;    local -a _den_pair      # Pairs found here
 1174&nbsp;    local -a _den_rev       # Reverse pairs found here
 1175&nbsp;    local -a _den_tmp       # Line being parsed
 1176&nbsp;    local -a _den_auth      # SOA contact being parsed
 1177&nbsp;    local -a _den_new       # The zone reply
 1178&nbsp;    local -a _den_pc        # Parent-Child gets big fast
 1179&nbsp;    local -a _den_ref       # So does reference chain
 1180&nbsp;    local -a _den_nr        # Name-Resource can be big
 1181&nbsp;    local -a _den_na        # Name-Address
 1182&nbsp;    local -a _den_ns        # Name-Service
 1183&nbsp;    local -a _den_achn      # Chain of Authority
 1184&nbsp;    local -i _den_cnt       # Count of names to detail
 1185&nbsp;    local -i _den_lmt       # Indirection limit
 1186&nbsp;    local _den_who          # Named being processed
 1187&nbsp;    local _den_rec          # Record type being processed
 1188&nbsp;    local _den_cont         # Contact domain
 1189&nbsp;    local _den_str          # Fixed up name string
 1190&nbsp;    local _den_str2         # Fixed up reverse
 1191&nbsp;    local IFS=${WSP_IFS}
 1192&nbsp;
 1193&nbsp;    # Local, unique copy of names to check
 1194&nbsp;    unique_lines chk_name _den_chk
 1195&nbsp;    unset chk_name[@]       # Done with globals.
 1196&nbsp;
 1197&nbsp;    # Less any names already known
 1198&nbsp;    edit_exact known_name _den_chk
 1199&nbsp;    _den_cnt=${#_den_chk[@]}
 1200&nbsp;
 1201&nbsp;    # If anything left, add to known_name.
 1202&nbsp;    [ ${_den_cnt} -gt 0 ] &#38;&#38;
 1203&nbsp;        known_name=( ${known_name[@]} ${_den_chk[@]} )
 1204&nbsp;
 1205&nbsp;    # for the list of (previously) unknown names . . .
 1206&nbsp;    for (( _den = 0 ; _den &#60; _den_cnt ; _den++ ))
 1207&nbsp;    do
 1208&nbsp;        _den_who=${_den_chk[${_den}]}
 1209&nbsp;        if long_fwd ${_den_who} _den_new
 1210&nbsp;        then
 1211&nbsp;            unique_lines _den_new _den_new
 1212&nbsp;            if [ ${#_den_new[@]} -eq 0 ]
 1213&nbsp;            then
 1214&nbsp;                _den_pair[${#_den_pair[@]}]='0.0.0.0 '${_den_who}
 1215&nbsp;            fi
 1216&nbsp;
 1217&nbsp;            # Parse each line in the reply.
 1218&nbsp;            for (( _line = 0 ; _line &#60; ${#_den_new[@]} ; _line++ ))
 1219&nbsp;            do
 1220&nbsp;                IFS=${NO_WSP}$'\x09'$'\x20'
 1221&nbsp;                _den_tmp=( ${_den_new[${_line}]} )
 1222&nbsp;                IFS=${WSP_IFS}
 1223&nbsp;              # If usable record and not a warning message . . .
 1224&nbsp;              if [ ${#_den_tmp[@]} -gt 4 ] &#38;&#38; [ 'x'${_den_tmp[0]} != 'x;;' ]
 1225&nbsp;              then
 1226&nbsp;                    _den_rec=${_den_tmp[3]}
 1227&nbsp;                    _den_nr[${#_den_nr[@]}]=${_den_who}' '${_den_rec}
 1228&nbsp;                    # Begin at RFC1033 (+++)
 1229&nbsp;                    case ${_den_rec} in
 1230&nbsp;
 1231&nbsp;#&#60;name&#62; [&#60;ttl&#62;]  [&#60;class&#62;] SOA &#60;origin&#62; &#60;person&#62;
 1232&nbsp;                    SOA) # Start Of Authority
 1233&nbsp;    if _den_str=$(name_fixup ${_den_tmp[0]})
 1234&nbsp;    then
 1235&nbsp;      _den_name[${#_den_name[@]}]=${_den_str}
 1236&nbsp;      _den_achn[${#_den_achn[@]}]=${_den_who}' '${_den_str}' SOA'
 1237&nbsp;      # SOA origin -- domain name of master zone record
 1238&nbsp;      if _den_str2=$(name_fixup ${_den_tmp[4]})
 1239&nbsp;      then
 1240&nbsp;        _den_name[${#_den_name[@]}]=${_den_str2}
 1241&nbsp;        _den_achn[${#_den_achn[@]}]=${_den_who}' '${_den_str2}' SOA.O'
 1242&nbsp;      fi
 1243&nbsp;      # Responsible party e-mail address (possibly bogus).
 1244&nbsp;      # Possibility of first.last@domain.name ignored.
 1245&nbsp;      set -f
 1246&nbsp;      if _den_str2=$(name_fixup ${_den_tmp[5]})
 1247&nbsp;      then
 1248&nbsp;        IFS=${ADR_IFS}
 1249&nbsp;        _den_auth=( ${_den_str2} )
 1250&nbsp;        IFS=${WSP_IFS}
 1251&nbsp;        if [ ${#_den_auth[@]} -gt 2 ]
 1252&nbsp;        then
 1253&nbsp;          _den_cont=${_den_auth[1]}
 1254&nbsp;          for (( _auth = 2 ; _auth &#60; ${#_den_auth[@]} ; _auth++ ))
 1255&nbsp;          do
 1256&nbsp;            _den_cont=${_den_cont}'.'${_den_auth[${_auth}]}
 1257&nbsp;          done
 1258&nbsp;          _den_name[${#_den_name[@]}]=${_den_cont}'.'
 1259&nbsp;          _den_achn[${#_den_achn[@]}]=${_den_who}' '${_den_cont}'. SOA.C'
 1260&nbsp;                                fi
 1261&nbsp;        fi
 1262&nbsp;        set +f
 1263&nbsp;                        fi
 1264&nbsp;                    ;;
 1265&nbsp;
 1266&nbsp;
 1267&nbsp;      A) # IP(v4) Address Record
 1268&nbsp;      if _den_str=$(name_fixup ${_den_tmp[0]})
 1269&nbsp;      then
 1270&nbsp;        _den_name[${#_den_name[@]}]=${_den_str}
 1271&nbsp;        _den_pair[${#_den_pair[@]}]=${_den_tmp[4]}' '${_den_str}
 1272&nbsp;        _den_na[${#_den_na[@]}]=${_den_str}' '${_den_tmp[4]}
 1273&nbsp;        _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' A'
 1274&nbsp;      else
 1275&nbsp;        _den_pair[${#_den_pair[@]}]=${_den_tmp[4]}' unknown.domain'
 1276&nbsp;        _den_na[${#_den_na[@]}]='unknown.domain '${_den_tmp[4]}
 1277&nbsp;        _den_ref[${#_den_ref[@]}]=${_den_who}' unknown.domain A'
 1278&nbsp;      fi
 1279&nbsp;      _den_address[${#_den_address[@]}]=${_den_tmp[4]}
 1280&nbsp;      _den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_tmp[4]}
 1281&nbsp;             ;;
 1282&nbsp;
 1283&nbsp;             NS) # Name Server Record
 1284&nbsp;             # Domain name being serviced (may be other than current)
 1285&nbsp;               if _den_str=$(name_fixup ${_den_tmp[0]})
 1286&nbsp;                 then
 1287&nbsp;                   _den_name[${#_den_name[@]}]=${_den_str}
 1288&nbsp;                   _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' NS'
 1289&nbsp;
 1290&nbsp;             # Domain name of service provider
 1291&nbsp;             if _den_str2=$(name_fixup ${_den_tmp[4]})
 1292&nbsp;             then
 1293&nbsp;               _den_name[${#_den_name[@]}]=${_den_str2}
 1294&nbsp;               _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str2}' NSH'
 1295&nbsp;               _den_ns[${#_den_ns[@]}]=${_den_str2}' NS'
 1296&nbsp;               _den_pc[${#_den_pc[@]}]=${_den_str}' '${_den_str2}
 1297&nbsp;              fi
 1298&nbsp;               fi
 1299&nbsp;                    ;;
 1300&nbsp;
 1301&nbsp;             MX) # Mail Server Record
 1302&nbsp;                 # Domain name being serviced (wildcards not handled here)
 1303&nbsp;             if _den_str=$(name_fixup ${_den_tmp[0]})
 1304&nbsp;             then
 1305&nbsp;               _den_name[${#_den_name[@]}]=${_den_str}
 1306&nbsp;               _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' MX'
 1307&nbsp;             fi
 1308&nbsp;             # Domain name of service provider
 1309&nbsp;             if _den_str=$(name_fixup ${_den_tmp[5]})
 1310&nbsp;             then
 1311&nbsp;               _den_name[${#_den_name[@]}]=${_den_str}
 1312&nbsp;               _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' MXH'
 1313&nbsp;               _den_ns[${#_den_ns[@]}]=${_den_str}' MX'
 1314&nbsp;               _den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_str}
 1315&nbsp;             fi
 1316&nbsp;                    ;;
 1317&nbsp;
 1318&nbsp;             PTR) # Reverse address record
 1319&nbsp;                  # Special name
 1320&nbsp;             if _den_str=$(name_fixup ${_den_tmp[0]})
 1321&nbsp;             then
 1322&nbsp;               _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' PTR'
 1323&nbsp;               # Host name (not a CNAME)
 1324&nbsp;               if _den_str2=$(name_fixup ${_den_tmp[4]})
 1325&nbsp;               then
 1326&nbsp;                 _den_rev[${#_den_rev[@]}]=${_den_str}' '${_den_str2}
 1327&nbsp;                 _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str2}' PTRH'
 1328&nbsp;                 _den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_str}
 1329&nbsp;               fi
 1330&nbsp;             fi
 1331&nbsp;                    ;;
 1332&nbsp;
 1333&nbsp;             AAAA) # IP(v6) Address Record
 1334&nbsp;             if _den_str=$(name_fixup ${_den_tmp[0]})
 1335&nbsp;             then
 1336&nbsp;               _den_name[${#_den_name[@]}]=${_den_str}
 1337&nbsp;               _den_pair[${#_den_pair[@]}]=${_den_tmp[4]}' '${_den_str}
 1338&nbsp;               _den_na[${#_den_na[@]}]=${_den_str}' '${_den_tmp[4]}
 1339&nbsp;               _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' AAAA'
 1340&nbsp;               else
 1341&nbsp;                 _den_pair[${#_den_pair[@]}]=${_den_tmp[4]}' unknown.domain'
 1342&nbsp;                 _den_na[${#_den_na[@]}]='unknown.domain '${_den_tmp[4]}
 1343&nbsp;                 _den_ref[${#_den_ref[@]}]=${_den_who}' unknown.domain'
 1344&nbsp;               fi
 1345&nbsp;               # No processing for IPv6 addresses
 1346&nbsp;               _den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_tmp[4]}
 1347&nbsp;                    ;;
 1348&nbsp;
 1349&nbsp;             CNAME) # Alias name record
 1350&nbsp;                    # Nickname
 1351&nbsp;             if _den_str=$(name_fixup ${_den_tmp[0]})
 1352&nbsp;             then
 1353&nbsp;               _den_name[${#_den_name[@]}]=${_den_str}
 1354&nbsp;               _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' CNAME'
 1355&nbsp;               _den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_str}
 1356&nbsp;             fi
 1357&nbsp;                    # Hostname
 1358&nbsp;             if _den_str=$(name_fixup ${_den_tmp[4]})
 1359&nbsp;             then
 1360&nbsp;               _den_name[${#_den_name[@]}]=${_den_str}
 1361&nbsp;               _den_ref[${#_den_ref[@]}]=${_den_who}' '${_den_str}' CHOST'
 1362&nbsp;               _den_pc[${#_den_pc[@]}]=${_den_who}' '${_den_str}
 1363&nbsp;             fi
 1364&nbsp;                    ;;
 1365&nbsp;#            TXT)
 1366&nbsp;#            ;;
 1367&nbsp;                    esac
 1368&nbsp;                fi
 1369&nbsp;            done
 1370&nbsp;        else # Lookup error == 'A' record 'unknown address'
 1371&nbsp;            _den_pair[${#_den_pair[@]}]='0.0.0.0 '${_den_who}
 1372&nbsp;        fi
 1373&nbsp;    done
 1374&nbsp;
 1375&nbsp;    # Control dot array growth.
 1376&nbsp;    unique_lines _den_achn _den_achn      # Works best, all the same.
 1377&nbsp;    edit_exact auth_chain _den_achn       # Works best, unique items.
 1378&nbsp;    if [ ${#_den_achn[@]} -gt 0 ]
 1379&nbsp;    then
 1380&nbsp;        IFS=${NO_WSP}
 1381&nbsp;        auth_chain=( ${auth_chain[@]} ${_den_achn[@]} )
 1382&nbsp;        IFS=${WSP_IFS}
 1383&nbsp;    fi
 1384&nbsp;
 1385&nbsp;    unique_lines _den_ref _den_ref      # Works best, all the same.
 1386&nbsp;    edit_exact ref_chain _den_ref       # Works best, unique items.
 1387&nbsp;    if [ ${#_den_ref[@]} -gt 0 ]
 1388&nbsp;    then
 1389&nbsp;        IFS=${NO_WSP}
 1390&nbsp;        ref_chain=( ${ref_chain[@]} ${_den_ref[@]} )
 1391&nbsp;        IFS=${WSP_IFS}
 1392&nbsp;    fi
 1393&nbsp;
 1394&nbsp;    unique_lines _den_na _den_na
 1395&nbsp;    edit_exact name_address _den_na
 1396&nbsp;    if [ ${#_den_na[@]} -gt 0 ]
 1397&nbsp;    then
 1398&nbsp;        IFS=${NO_WSP}
 1399&nbsp;        name_address=( ${name_address[@]} ${_den_na[@]} )
 1400&nbsp;        IFS=${WSP_IFS}
 1401&nbsp;    fi
 1402&nbsp;
 1403&nbsp;    unique_lines _den_ns _den_ns
 1404&nbsp;    edit_exact name_srvc _den_ns
 1405&nbsp;    if [ ${#_den_ns[@]} -gt 0 ]
 1406&nbsp;    then
 1407&nbsp;        IFS=${NO_WSP}
 1408&nbsp;        name_srvc=( ${name_srvc[@]} ${_den_ns[@]} )
 1409&nbsp;        IFS=${WSP_IFS}
 1410&nbsp;    fi
 1411&nbsp;
 1412&nbsp;    unique_lines _den_nr _den_nr
 1413&nbsp;    edit_exact name_resource _den_nr
 1414&nbsp;    if [ ${#_den_nr[@]} -gt 0 ]
 1415&nbsp;    then
 1416&nbsp;        IFS=${NO_WSP}
 1417&nbsp;        name_resource=( ${name_resource[@]} ${_den_nr[@]} )
 1418&nbsp;        IFS=${WSP_IFS}
 1419&nbsp;    fi
 1420&nbsp;
 1421&nbsp;    unique_lines _den_pc _den_pc
 1422&nbsp;    edit_exact parent_child _den_pc
 1423&nbsp;    if [ ${#_den_pc[@]} -gt 0 ]
 1424&nbsp;    then
 1425&nbsp;        IFS=${NO_WSP}
 1426&nbsp;        parent_child=( ${parent_child[@]} ${_den_pc[@]} )
 1427&nbsp;        IFS=${WSP_IFS}
 1428&nbsp;    fi
 1429&nbsp;
 1430&nbsp;    # Update list known_pair (Address and Name).
 1431&nbsp;    unique_lines _den_pair _den_pair
 1432&nbsp;    edit_exact known_pair _den_pair
 1433&nbsp;    if [ ${#_den_pair[@]} -gt 0 ]  # Anything new?
 1434&nbsp;    then
 1435&nbsp;        IFS=${NO_WSP}
 1436&nbsp;        known_pair=( ${known_pair[@]} ${_den_pair[@]} )
 1437&nbsp;        IFS=${WSP_IFS}
 1438&nbsp;    fi
 1439&nbsp;
 1440&nbsp;    # Update list of reverse pairs.
 1441&nbsp;    unique_lines _den_rev _den_rev
 1442&nbsp;    edit_exact reverse_pair _den_rev
 1443&nbsp;    if [ ${#_den_rev[@]} -gt 0 ]   # Anything new?
 1444&nbsp;    then
 1445&nbsp;        IFS=${NO_WSP}
 1446&nbsp;        reverse_pair=( ${reverse_pair[@]} ${_den_rev[@]} )
 1447&nbsp;        IFS=${WSP_IFS}
 1448&nbsp;    fi
 1449&nbsp;
 1450&nbsp;    # Check indirection limit -- give up if reached.
 1451&nbsp;    if ! _den_lmt=$(limit_chk ${1})
 1452&nbsp;    then
 1453&nbsp;        return 0
 1454&nbsp;    fi
 1455&nbsp;
 1456&nbsp;# Execution engine is LIFO. Order of pend operations is important.
 1457&nbsp;# Did we define any new addresses?
 1458&nbsp;unique_lines _den_address _den_address    # Scrub duplicates.
 1459&nbsp;edit_exact known_address _den_address     # Scrub already processed.
 1460&nbsp;edit_exact un_address _den_address        # Scrub already waiting.
 1461&nbsp;if [ ${#_den_address[@]} -gt 0 ]          # Anything new?
 1462&nbsp;then
 1463&nbsp;  uc_address=( ${uc_address[@]} ${_den_address[@]} )
 1464&nbsp;  pend_func expand_input_address ${_den_lmt}
 1465&nbsp;  _trace_log[${#_trace_log[@]}]='# Add '${#_den_address[@]}' unchkd addr. #'
 1466&nbsp;    fi
 1467&nbsp;
 1468&nbsp;# Did we find any new names?
 1469&nbsp;unique_lines _den_name _den_name          # Scrub duplicates.
 1470&nbsp;edit_exact known_name _den_name           # Scrub already processed.
 1471&nbsp;edit_exact uc_name _den_name              # Scrub already waiting.
 1472&nbsp;if [ ${#_den_name[@]} -gt 0 ]             # Anything new?
 1473&nbsp;then
 1474&nbsp;  uc_name=( ${uc_name[@]} ${_den_name[@]} )
 1475&nbsp;  pend_func expand_input_name ${_den_lmt}
 1476&nbsp;  _trace_log[${#_trace_log[@]}]='#Added '${#_den_name[@]}' unchkd name#'
 1477&nbsp;    fi
 1478&nbsp;    return 0
 1479&nbsp;}
 1480&nbsp;
 1481&nbsp;# The parse-it-yourself delegation reply
 1482&nbsp;# Input is the chk_address list.
 1483&nbsp;# detail_each_address &#60;indirection_limit&#62;
 1484&nbsp;detail_each_address() {
 1485&nbsp;    [ ${#chk_address[@]} -gt 0 ] || return 0
 1486&nbsp;    unique_lines chk_address chk_address
 1487&nbsp;    edit_exact known_address chk_address
 1488&nbsp;    if [ ${#chk_address[@]} -gt 0 ]
 1489&nbsp;    then
 1490&nbsp;        known_address=( ${known_address[@]} ${chk_address[@]} )
 1491&nbsp;        unset chk_address[@]
 1492&nbsp;    fi
 1493&nbsp;    return 0
 1494&nbsp;}
 1495&nbsp;
 1496&nbsp;# # # Application specific output functions # # #
 1497&nbsp;
 1498&nbsp;# Pretty print the known pairs.
 1499&nbsp;report_pairs() {
 1500&nbsp;    echo
 1501&nbsp;    echo 'Known network pairs.'
 1502&nbsp;    col_print known_pair 2 5 30
 1503&nbsp;
 1504&nbsp;    if [ ${#auth_chain[@]} -gt 0 ]
 1505&nbsp;    then
 1506&nbsp;        echo
 1507&nbsp;        echo 'Known chain of authority.'
 1508&nbsp;        col_print auth_chain 2 5 30 55
 1509&nbsp;    fi
 1510&nbsp;
 1511&nbsp;    if [ ${#reverse_pair[@]} -gt 0 ]
 1512&nbsp;    then
 1513&nbsp;        echo
 1514&nbsp;        echo 'Known reverse pairs.'
 1515&nbsp;        col_print reverse_pair 2 5 55
 1516&nbsp;    fi
 1517&nbsp;    return 0
 1518&nbsp;}
 1519&nbsp;
 1520&nbsp;# Check an address against the list of blacklist servers.
 1521&nbsp;# A good place to capture for GraphViz: address-&#62;status(server(reports))
 1522&nbsp;# check_lists &#60;ip_address&#62;
 1523&nbsp;check_lists() {
 1524&nbsp;    [ $# -eq 1 ] || return 1
 1525&nbsp;    local -a _cl_fwd_addr
 1526&nbsp;    local -a _cl_rev_addr
 1527&nbsp;    local -a _cl_reply
 1528&nbsp;    local -i _cl_rc
 1529&nbsp;    local -i _ls_cnt
 1530&nbsp;    local _cl_dns_addr
 1531&nbsp;    local _cl_lkup
 1532&nbsp;
 1533&nbsp;    split_ip ${1} _cl_fwd_addr _cl_rev_addr
 1534&nbsp;    _cl_dns_addr=$(dot_array _cl_rev_addr)'.'
 1535&nbsp;    _ls_cnt=${#list_server[@]}
 1536&nbsp;    echo '    Checking address '${1}
 1537&nbsp;    for (( _cl = 0 ; _cl &#60; _ls_cnt ; _cl++ ))
 1538&nbsp;    do
 1539&nbsp;      _cl_lkup=${_cl_dns_addr}${list_server[${_cl}]}
 1540&nbsp;      if short_text ${_cl_lkup} _cl_reply
 1541&nbsp;      then
 1542&nbsp;        if [ ${#_cl_reply[@]} -gt 0 ]
 1543&nbsp;        then
 1544&nbsp;          echo '        Records from '${list_server[${_cl}]}
 1545&nbsp;          address_hits[${#address_hits[@]}]=${1}' '${list_server[${_cl}]}
 1546&nbsp;          _hs_RC=2
 1547&nbsp;          for (( _clr = 0 ; _clr &#60; ${#_cl_reply[@]} ; _clr++ ))
 1548&nbsp;          do
 1549&nbsp;            echo '            '${_cl_reply[${_clr}]}
 1550&nbsp;          done
 1551&nbsp;        fi
 1552&nbsp;      fi
 1553&nbsp;    done
 1554&nbsp;    return 0
 1555&nbsp;}
 1556&nbsp;
 1557&nbsp;# # # The usual application glue # # #
 1558&nbsp;
 1559&nbsp;# Who did it?
 1560&nbsp;credits() {
 1561&nbsp;   echo
 1562&nbsp;   echo 'Advanced Bash Scripting Guide: is_spammer.bash, v2, 2004-msz'
 1563&nbsp;}
 1564&nbsp;
 1565&nbsp;# How to use it?
 1566&nbsp;# (See also, "Quickstart" at end of script.)
 1567&nbsp;usage() {
 1568&nbsp;    cat &#60;&#60;-'_usage_statement_'
 1569&nbsp;    The script is_spammer.bash requires either one or two arguments.
 1570&nbsp;
 1571&nbsp;    arg 1) May be one of:
 1572&nbsp;        a) A domain name
 1573&nbsp;        b) An IPv4 address
 1574&nbsp;        c) The name of a file with any mix of names
 1575&nbsp;           and addresses, one per line.
 1576&nbsp;
 1577&nbsp;    arg 2) May be one of:
 1578&nbsp;        a) A Blacklist server domain name
 1579&nbsp;        b) The name of a file with Blacklist server
 1580&nbsp;           domain names, one per line.
 1581&nbsp;        c) If not present, a default list of (free)
 1582&nbsp;           Blacklist servers is used.
 1583&nbsp;        d) If a filename of an empty, readable, file
 1584&nbsp;           is given,
 1585&nbsp;           Blacklist server lookup is disabled.
 1586&nbsp;
 1587&nbsp;    All script output is written to stdout.
 1588&nbsp;
 1589&nbsp;    Return codes: 0 -&#62; All OK, 1 -&#62; Script failure,
 1590&nbsp;                  2 -&#62; Something is Blacklisted.
 1591&nbsp;
 1592&nbsp;    Requires the external program 'dig' from the 'bind-9'
 1593&nbsp;    set of DNS programs.  See: http://www.isc.org
 1594&nbsp;
 1595&nbsp;    The domain name lookup depth limit defaults to 2 levels.
 1596&nbsp;    Set the environment variable SPAMMER_LIMIT to change.
 1597&nbsp;    SPAMMER_LIMIT=0 means 'unlimited'
 1598&nbsp;
 1599&nbsp;    Limit may also be set on the command line.
 1600&nbsp;    If arg#1 is an integer, the limit is set to that value
 1601&nbsp;    and then the above argument rules are applied.
 1602&nbsp;
 1603&nbsp;    Setting the environment variable 'SPAMMER_DATA' to a filename
 1604&nbsp;    will cause the script to write a GraphViz graphic file.
 1605&nbsp;
 1606&nbsp;    For the development version;
 1607&nbsp;    Setting the environment variable 'SPAMMER_TRACE' to a filename
 1608&nbsp;    will cause the execution engine to log a function call trace.
 1609&nbsp;
 1610&nbsp;_usage_statement_
 1611&nbsp;}
 1612&nbsp;
 1613&nbsp;# The default list of Blacklist servers:
 1614&nbsp;# Many choices, see: http://www.spews.org/lists.html
 1615&nbsp;
 1616&nbsp;declare -a default_servers
 1617&nbsp;# See: http://www.spamhaus.org (Conservative, well maintained)
 1618&nbsp;default_servers[0]='sbl-xbl.spamhaus.org'
 1619&nbsp;# See: http://ordb.org (Open mail relays)
 1620&nbsp;default_servers[1]='relays.ordb.org'
 1621&nbsp;# See: http://www.spamcop.net/ (You can report spammers here)
 1622&nbsp;default_servers[2]='bl.spamcop.net'
 1623&nbsp;# See: http://www.spews.org (An 'early detect' system)
 1624&nbsp;default_servers[3]='l2.spews.dnsbl.sorbs.net'
 1625&nbsp;# See: http://www.dnsbl.us.sorbs.net/using.shtml
 1626&nbsp;default_servers[4]='dnsbl.sorbs.net'
 1627&nbsp;# See: http://dsbl.org/usage (Various mail relay lists)
 1628&nbsp;default_servers[5]='list.dsbl.org'
 1629&nbsp;default_servers[6]='multihop.dsbl.org'
 1630&nbsp;default_servers[7]='unconfirmed.dsbl.org'
 1631&nbsp;
 1632&nbsp;# User input argument #1
 1633&nbsp;setup_input() {
 1634&nbsp;    if [ -e ${1} ] &#38;&#38; [ -r ${1} ]  # Name of readable file
 1635&nbsp;    then
 1636&nbsp;        file_to_array ${1} uc_name
 1637&nbsp;        echo 'Using filename &#62;'${1}'&#60; as input.'
 1638&nbsp;    else
 1639&nbsp;        if is_address ${1}          # IP address?
 1640&nbsp;        then
 1641&nbsp;            uc_address=( ${1} )
 1642&nbsp;            echo 'Starting with address &#62;'${1}'&#60;'
 1643&nbsp;        else                       # Must be a name.
 1644&nbsp;            uc_name=( ${1} )
 1645&nbsp;            echo 'Starting with domain name &#62;'${1}'&#60;'
 1646&nbsp;        fi
 1647&nbsp;    fi
 1648&nbsp;    return 0
 1649&nbsp;}
 1650&nbsp;
 1651&nbsp;# User input argument #2
 1652&nbsp;setup_servers() {
 1653&nbsp;    if [ -e ${1} ] &#38;&#38; [ -r ${1} ]  # Name of a readable file
 1654&nbsp;    then
 1655&nbsp;        file_to_array ${1} list_server
 1656&nbsp;        echo 'Using filename &#62;'${1}'&#60; as blacklist server list.'
 1657&nbsp;    else
 1658&nbsp;        list_server=( ${1} )
 1659&nbsp;        echo 'Using blacklist server &#62;'${1}'&#60;'
 1660&nbsp;    fi
 1661&nbsp;    return 0
 1662&nbsp;}
 1663&nbsp;
 1664&nbsp;# User environment variable SPAMMER_TRACE
 1665&nbsp;live_log_die() {
 1666&nbsp;    if [ ${SPAMMER_TRACE:=} ]    # Wants trace log?
 1667&nbsp;    then
 1668&nbsp;        if [ ! -e ${SPAMMER_TRACE} ]
 1669&nbsp;        then
 1670&nbsp;            if ! touch ${SPAMMER_TRACE} 2&#62;/dev/null
 1671&nbsp;            then
 1672&nbsp;                pend_func echo $(printf '%q\n' \
 1673&nbsp;                'Unable to create log file &#62;'${SPAMMER_TRACE}'&#60;')
 1674&nbsp;                pend_release
 1675&nbsp;                exit 1
 1676&nbsp;            fi
 1677&nbsp;            _log_file=${SPAMMER_TRACE}
 1678&nbsp;            _pend_hook_=trace_logger
 1679&nbsp;            _log_dump=dump_log
 1680&nbsp;        else
 1681&nbsp;            if [ ! -w ${SPAMMER_TRACE} ]
 1682&nbsp;            then
 1683&nbsp;                pend_func echo $(printf '%q\n' \
 1684&nbsp;                'Unable to write log file &#62;'${SPAMMER_TRACE}'&#60;')
 1685&nbsp;                pend_release
 1686&nbsp;                exit 1
 1687&nbsp;            fi
 1688&nbsp;            _log_file=${SPAMMER_TRACE}
 1689&nbsp;            echo '' &#62; ${_log_file}
 1690&nbsp;            _pend_hook_=trace_logger
 1691&nbsp;            _log_dump=dump_log
 1692&nbsp;        fi
 1693&nbsp;    fi
 1694&nbsp;    return 0
 1695&nbsp;}
 1696&nbsp;
 1697&nbsp;# User environment variable SPAMMER_DATA
 1698&nbsp;data_capture() {
 1699&nbsp;    if [ ${SPAMMER_DATA:=} ]    # Wants a data dump?
 1700&nbsp;    then
 1701&nbsp;        if [ ! -e ${SPAMMER_DATA} ]
 1702&nbsp;        then
 1703&nbsp;            if ! touch ${SPAMMER_DATA} 2&#62;/dev/null
 1704&nbsp;            then
 1705&nbsp;                pend_func echo $(printf '%q]n' \
 1706&nbsp;                'Unable to create data output file &#62;'${SPAMMER_DATA}'&#60;')
 1707&nbsp;                pend_release
 1708&nbsp;                exit 1
 1709&nbsp;            fi
 1710&nbsp;            _dot_file=${SPAMMER_DATA}
 1711&nbsp;            _dot_dump=dump_dot
 1712&nbsp;        else
 1713&nbsp;            if [ ! -w ${SPAMMER_DATA} ]
 1714&nbsp;            then
 1715&nbsp;                pend_func echo $(printf '%q\n' \
 1716&nbsp;                'Unable to write data output file &#62;'${SPAMMER_DATA}'&#60;')
 1717&nbsp;                pend_release
 1718&nbsp;                exit 1
 1719&nbsp;            fi
 1720&nbsp;            _dot_file=${SPAMMER_DATA}
 1721&nbsp;            _dot_dump=dump_dot
 1722&nbsp;        fi
 1723&nbsp;    fi
 1724&nbsp;    return 0
 1725&nbsp;}
 1726&nbsp;
 1727&nbsp;# Grope user specified arguments.
 1728&nbsp;do_user_args() {
 1729&nbsp;    if [ $# -gt 0 ] &#38;&#38; is_number $1
 1730&nbsp;    then
 1731&nbsp;        indirect=$1
 1732&nbsp;        shift
 1733&nbsp;    fi
 1734&nbsp;
 1735&nbsp;    case $# in                     # Did user treat us well?
 1736&nbsp;        1)
 1737&nbsp;            if ! setup_input $1    # Needs error checking.
 1738&nbsp;            then
 1739&nbsp;                pend_release
 1740&nbsp;                $_log_dump
 1741&nbsp;                exit 1
 1742&nbsp;            fi
 1743&nbsp;            list_server=( ${default_servers[@]} )
 1744&nbsp;            _list_cnt=${#list_server[@]}
 1745&nbsp;            echo 'Using default blacklist server list.'
 1746&nbsp;            echo 'Search depth limit: '${indirect}
 1747&nbsp;            ;;
 1748&nbsp;        2)
 1749&nbsp;            if ! setup_input $1    # Needs error checking.
 1750&nbsp;            then
 1751&nbsp;                pend_release
 1752&nbsp;                $_log_dump
 1753&nbsp;                exit 1
 1754&nbsp;            fi
 1755&nbsp;            if ! setup_servers $2  # Needs error checking.
 1756&nbsp;            then
 1757&nbsp;                pend_release
 1758&nbsp;                $_log_dump
 1759&nbsp;                exit 1
 1760&nbsp;            fi
 1761&nbsp;            echo 'Search depth limit: '${indirect}
 1762&nbsp;            ;;
 1763&nbsp;        *)
 1764&nbsp;            pend_func usage
 1765&nbsp;            pend_release
 1766&nbsp;            $_log_dump
 1767&nbsp;            exit 1
 1768&nbsp;            ;;
 1769&nbsp;    esac
 1770&nbsp;    return 0
 1771&nbsp;}
 1772&nbsp;
 1773&nbsp;# A general purpose debug tool.
 1774&nbsp;# list_array &#60;array_name&#62;
 1775&nbsp;list_array() {
 1776&nbsp;    [ $# -eq 1 ] || return 1  # One argument required.
 1777&nbsp;
 1778&nbsp;    local -a _la_lines
 1779&nbsp;    set -f
 1780&nbsp;    local IFS=${NO_WSP}
 1781&nbsp;    eval _la_lines=\(\ \$\{$1\[@\]\}\ \)
 1782&nbsp;    echo
 1783&nbsp;    echo "Element count "${#_la_lines[@]}" array "${1}
 1784&nbsp;    local _ln_cnt=${#_la_lines[@]}
 1785&nbsp;
 1786&nbsp;    for (( _i = 0; _i &#60; ${_ln_cnt}; _i++ ))
 1787&nbsp;    do
 1788&nbsp;        echo 'Element '$_i' &#62;'${_la_lines[$_i]}'&#60;'
 1789&nbsp;    done
 1790&nbsp;    set +f
 1791&nbsp;    return 0
 1792&nbsp;}
 1793&nbsp;
 1794&nbsp;# # # 'Hunt the Spammer' program code # # #
 1795&nbsp;pend_init                               # Ready stack engine.
 1796&nbsp;pend_func credits                       # Last thing to print.
 1797&nbsp;
 1798&nbsp;# # # Deal with user # # #
 1799&nbsp;live_log_die                            # Setup debug trace log.
 1800&nbsp;data_capture                            # Setup data capture file.
 1801&nbsp;echo
 1802&nbsp;do_user_args $@
 1803&nbsp;
 1804&nbsp;# # # Haven't exited yet - There is some hope # # #
 1805&nbsp;# Discovery group - Execution engine is LIFO - pend
 1806&nbsp;# in reverse order of execution.
 1807&nbsp;_hs_RC=0                                # Hunt the Spammer return code
 1808&nbsp;pend_mark
 1809&nbsp;    pend_func report_pairs              # Report name-address pairs.
 1810&nbsp;
 1811&nbsp;    # The two detail_* are mutually recursive functions.
 1812&nbsp;    # They also pend expand_* functions as required.
 1813&nbsp;    # These two (the last of ???) exit the recursion.
 1814&nbsp;    pend_func detail_each_address       # Get all resources of addresses.
 1815&nbsp;    pend_func detail_each_name          # Get all resources of names.
 1816&nbsp;
 1817&nbsp;    #  The two expand_* are mutually recursive functions,
 1818&nbsp;    #+ which pend additional detail_* functions as required.
 1819&nbsp;    pend_func expand_input_address 1    # Expand input names by address.
 1820&nbsp;    pend_func expand_input_name 1       # #xpand input addresses by name.
 1821&nbsp;
 1822&nbsp;    # Start with a unique set of names and addresses.
 1823&nbsp;    pend_func unique_lines uc_address uc_address
 1824&nbsp;    pend_func unique_lines uc_name uc_name
 1825&nbsp;
 1826&nbsp;    # Separate mixed input of names and addresses.
 1827&nbsp;    pend_func split_input
 1828&nbsp;pend_release
 1829&nbsp;
 1830&nbsp;# # # Pairs reported -- Unique list of IP addresses found
 1831&nbsp;echo
 1832&nbsp;_ip_cnt=${#known_address[@]}
 1833&nbsp;if [ ${#list_server[@]} -eq 0 ]
 1834&nbsp;then
 1835&nbsp;    echo 'Blacklist server list empty, none checked.'
 1836&nbsp;else
 1837&nbsp;    if [ ${_ip_cnt} -eq 0 ]
 1838&nbsp;    then
 1839&nbsp;        echo 'Known address list empty, none checked.'
 1840&nbsp;    else
 1841&nbsp;        _ip_cnt=${_ip_cnt}-1   # Start at top.
 1842&nbsp;        echo 'Checking Blacklist servers.'
 1843&nbsp;        for (( _ip = _ip_cnt ; _ip &#62;= 0 ; _ip-- ))
 1844&nbsp;        do
 1845&nbsp;          pend_func check_lists $( printf '%q\n' ${known_address[$_ip]} )
 1846&nbsp;        done
 1847&nbsp;    fi
 1848&nbsp;fi
 1849&nbsp;pend_release
 1850&nbsp;$_dot_dump                   # Graphics file dump
 1851&nbsp;$_log_dump                   # Execution trace
 1852&nbsp;echo
 1853&nbsp;
 1854&nbsp;
 1855&nbsp;##############################
 1856&nbsp;# Example output from script #
 1857&nbsp;##############################
 1858&nbsp;:&#60;&#60;-'_is_spammer_outputs_'
 1859&nbsp;
 1860&nbsp;./is_spammer.bash 0 web4.alojamentos7.com
 1861&nbsp;
 1862&nbsp;Starting with domain name &#62;web4.alojamentos7.com&#60;
 1863&nbsp;Using default blacklist server list.
 1864&nbsp;Search depth limit: 0
 1865&nbsp;.:....::::...:::...:::.......::..::...:::.......::
 1866&nbsp;Known network pairs.
 1867&nbsp;    66.98.208.97             web4.alojamentos7.com.
 1868&nbsp;    66.98.208.97             ns1.alojamentos7.com.
 1869&nbsp;    69.56.202.147            ns2.alojamentos.ws.
 1870&nbsp;    66.98.208.97             alojamentos7.com.
 1871&nbsp;    66.98.208.97             web.alojamentos7.com.
 1872&nbsp;    69.56.202.146            ns1.alojamentos.ws.
 1873&nbsp;    69.56.202.146            alojamentos.ws.
 1874&nbsp;    66.235.180.113           ns1.alojamentos.org.
 1875&nbsp;    66.235.181.192           ns2.alojamentos.org.
 1876&nbsp;    66.235.180.113           alojamentos.org.
 1877&nbsp;    66.235.180.113           web6.alojamentos.org.
 1878&nbsp;    216.234.234.30           ns1.theplanet.com.
 1879&nbsp;    12.96.160.115            ns2.theplanet.com.
 1880&nbsp;    216.185.111.52           mail1.theplanet.com.
 1881&nbsp;    69.56.141.4              spooling.theplanet.com.
 1882&nbsp;    216.185.111.40           theplanet.com.
 1883&nbsp;    216.185.111.40           www.theplanet.com.
 1884&nbsp;    216.185.111.52           mail.theplanet.com.
 1885&nbsp;
 1886&nbsp;Checking Blacklist servers.
 1887&nbsp;  Checking address 66.98.208.97
 1888&nbsp;      Records from dnsbl.sorbs.net
 1889&nbsp;  "Spam Received See: http://www.dnsbl.sorbs.net/lookup.shtml?66.98.208.97"
 1890&nbsp;    Checking address 69.56.202.147
 1891&nbsp;    Checking address 69.56.202.146
 1892&nbsp;    Checking address 66.235.180.113
 1893&nbsp;    Checking address 66.235.181.192
 1894&nbsp;    Checking address 216.185.111.40
 1895&nbsp;    Checking address 216.234.234.30
 1896&nbsp;    Checking address 12.96.160.115
 1897&nbsp;    Checking address 216.185.111.52
 1898&nbsp;    Checking address 69.56.141.4
 1899&nbsp;
 1900&nbsp;Advanced Bash Scripting Guide: is_spammer.bash, v2, 2004-msz
 1901&nbsp;
 1902&nbsp;_is_spammer_outputs_
 1903&nbsp;
 1904&nbsp;exit ${_hs_RC}
 1905&nbsp;
 1906&nbsp;####################################################
 1907&nbsp;#  The script ignores everything from here on down #
 1908&nbsp;#+ because of the 'exit' command, just above.      #
 1909&nbsp;####################################################
 1910&nbsp;
 1911&nbsp;
 1912&nbsp;
 1913&nbsp;Quickstart
 1914&nbsp;==========
 1915&nbsp;
 1916&nbsp; Prerequisites
 1917&nbsp;
 1918&nbsp;  Bash version 2.05b or 3.00 (bash --version)
 1919&nbsp;  A version of Bash which supports arrays. Array 
 1920&nbsp;  support is included by default Bash configurations.
 1921&nbsp;
 1922&nbsp;  'dig,' version 9.x.x (dig $HOSTNAME, see first line of output)
 1923&nbsp;  A version of dig which supports the +short options. 
 1924&nbsp;  See: dig_wrappers.bash for details.
 1925&nbsp;
 1926&nbsp;
 1927&nbsp; Optional Prerequisites
 1928&nbsp;
 1929&nbsp;  'named,' a local DNS caching program. Any flavor will do.
 1930&nbsp;  Do twice: dig $HOSTNAME 
 1931&nbsp;  Check near bottom of output for: SERVER: 127.0.0.1#53
 1932&nbsp;  That means you have one running.
 1933&nbsp;
 1934&nbsp;
 1935&nbsp; Optional Graphics Support
 1936&nbsp;
 1937&nbsp;  'date,' a standard *nix thing. (date -R)
 1938&nbsp;
 1939&nbsp;  dot Program to convert graphic description file to a 
 1940&nbsp;  diagram. (dot -V)
 1941&nbsp;  A part of the Graph-Viz set of programs.
 1942&nbsp;  See: [http://www.research.att.com/sw/tools/graphviz||GraphViz]
 1943&nbsp;
 1944&nbsp;  'dotty,' a visual editor for graphic description files.
 1945&nbsp;  Also a part of the Graph-Viz set of programs.
 1946&nbsp;
 1947&nbsp;
 1948&nbsp;
 1949&nbsp;
 1950&nbsp; Quick Start
 1951&nbsp;
 1952&nbsp;In the same directory as the is_spammer.bash script; 
 1953&nbsp;Do: ./is_spammer.bash
 1954&nbsp;
 1955&nbsp; Usage Details
 1956&nbsp;
 1957&nbsp;1. Blacklist server choices.
 1958&nbsp;
 1959&nbsp;  (a) To use default, built-in list: Do nothing.
 1960&nbsp;
 1961&nbsp;  (b) To use your own list: 
 1962&nbsp;
 1963&nbsp;    i. Create a file with a single Blacklist server 
 1964&nbsp;       domain name per line.
 1965&nbsp;
 1966&nbsp;    ii. Provide that filename as the last argument to 
 1967&nbsp;        the script.
 1968&nbsp;
 1969&nbsp;  (c) To use a single Blacklist server: Last argument 
 1970&nbsp;      to the script.
 1971&nbsp;
 1972&nbsp;  (d) To disable Blacklist lookups:
 1973&nbsp;
 1974&nbsp;    i. Create an empty file (touch spammer.nul)
 1975&nbsp;       Your choice of filename.
 1976&nbsp;
 1977&nbsp;    ii. Provide the filename of that empty file as the 
 1978&nbsp;        last argument to the script.
 1979&nbsp;
 1980&nbsp;2. Search depth limit.
 1981&nbsp;
 1982&nbsp;  (a) To use the default value of 2: Do nothing.
 1983&nbsp;
 1984&nbsp;  (b) To set a different limit: 
 1985&nbsp;      A limit of 0 means: no limit.
 1986&nbsp;
 1987&nbsp;    i. export SPAMMER_LIMIT=1
 1988&nbsp;       or whatever limit you want.
 1989&nbsp;
 1990&nbsp;    ii. OR provide the desired limit as the first 
 1991&nbsp;       argument to the script.
 1992&nbsp;
 1993&nbsp;3. Optional execution trace log.
 1994&nbsp;
 1995&nbsp;  (a) To use the default setting of no log output: Do nothing.
 1996&nbsp;
 1997&nbsp;  (b) To write an execution trace log:
 1998&nbsp;      export SPAMMER_TRACE=spammer.log
 1999&nbsp;      or whatever filename you want.
 2000&nbsp;
 2001&nbsp;4. Optional graphic description file.
 2002&nbsp;
 2003&nbsp;  (a) To use the default setting of no graphic file: Do nothing.
 2004&nbsp;
 2005&nbsp;  (b) To write a Graph-Viz graphic description file:
 2006&nbsp;      export SPAMMER_DATA=spammer.dot
 2007&nbsp;      or whatever filename you want.
 2008&nbsp;
 2009&nbsp;5. Where to start the search.
 2010&nbsp;
 2011&nbsp;  (a) Starting with a single domain name:
 2012&nbsp;
 2013&nbsp;    i. Without a command line search limit: First 
 2014&nbsp;       argument to script.
 2015&nbsp;
 2016&nbsp;    ii. With a command line search limit: Second 
 2017&nbsp;        argument to script.
 2018&nbsp;
 2019&nbsp;  (b) Starting with a single IP address:
 2020&nbsp;
 2021&nbsp;    i. Without a command line search limit: First 
 2022&nbsp;       argument to script.
 2023&nbsp;
 2024&nbsp;    ii. With a command line search limit: Second 
 2025&nbsp;        argument to script.
 2026&nbsp;
 2027&nbsp;  (c) Starting with (mixed) multiple name(s) and/or address(es):
 2028&nbsp;      Create a file with one name or address per line.
 2029&nbsp;      Your choice of filename.
 2030&nbsp;
 2031&nbsp;    i. Without a command line search limit: Filename as 
 2032&nbsp;       first argument to script.
 2033&nbsp;
 2034&nbsp;    ii. With a command line search limit: Filename as 
 2035&nbsp;        second argument to script.
 2036&nbsp;
 2037&nbsp;6. What to do with the display output.
 2038&nbsp;
 2039&nbsp;  (a) To view display output on screen: Do nothing.
 2040&nbsp;
 2041&nbsp;  (b) To save display output to a file: Redirect stdout to a filename.
 2042&nbsp;
 2043&nbsp;  (c) To discard display output: Redirect stdout to /dev/null.
 2044&nbsp;
 2045&nbsp;7. Temporary end of decision making. 
 2046&nbsp;   press RETURN 
 2047&nbsp;   wait (optionally, watch the dots and colons).
 2048&nbsp;
 2049&nbsp;8. Optionally check the return code.
 2050&nbsp;
 2051&nbsp;  (a) Return code 0: All OK
 2052&nbsp;
 2053&nbsp;  (b) Return code 1: Script setup failure
 2054&nbsp;
 2055&nbsp;  (c) Return code 2: Something was blacklisted.
 2056&nbsp;
 2057&nbsp;9. Where is my graph (diagram)?
 2058&nbsp;
 2059&nbsp;The script does not directly produce a graph (diagram). 
 2060&nbsp;It only produces a graphic description file. You can 
 2061&nbsp;process the graphic descriptor file that was output 
 2062&nbsp;with the 'dot' program.
 2063&nbsp;
 2064&nbsp;Until you edit that descriptor file, to describe the 
 2065&nbsp;relationships you want shown, all that you will get is 
 2066&nbsp;a bunch of labeled name and address nodes.
 2067&nbsp;
 2068&nbsp;All of the script's discovered relationships are within 
 2069&nbsp;a comment block in the graphic descriptor file, each 
 2070&nbsp;with a descriptive heading.
 2071&nbsp;
 2072&nbsp;The editing required to draw a line between a pair of 
 2073&nbsp;nodes from the information in the descriptor file may 
 2074&nbsp;be done with a text editor. 
 2075&nbsp;
 2076&nbsp;Given these lines somewhere in the descriptor file:
 2077&nbsp;
 2078&nbsp;# Known domain name nodes
 2079&nbsp;
 2080&nbsp;N0000 [label="guardproof.info."] ;
 2081&nbsp;
 2082&nbsp;N0002 [label="third.guardproof.info."] ;
 2083&nbsp;
 2084&nbsp;
 2085&nbsp;
 2086&nbsp;# Known address nodes
 2087&nbsp;
 2088&nbsp;A0000 [label="61.141.32.197"] ;
 2089&nbsp;
 2090&nbsp;
 2091&nbsp;
 2092&nbsp;/*
 2093&nbsp;
 2094&nbsp;# Known name-&#62;address edges
 2095&nbsp;
 2096&nbsp;NA0000 third.guardproof.info. 61.141.32.197
 2097&nbsp;
 2098&nbsp;
 2099&nbsp;
 2100&nbsp;# Known parent-&#62;child edges
 2101&nbsp;
 2102&nbsp;PC0000 guardproof.info. third.guardproof.info.
 2103&nbsp;
 2104&nbsp; */
 2105&nbsp;
 2106&nbsp;Turn that into the following lines by substituting node 
 2107&nbsp;identifiers into the relationships:
 2108&nbsp;
 2109&nbsp;# Known domain name nodes
 2110&nbsp;
 2111&nbsp;N0000 [label="guardproof.info."] ;
 2112&nbsp;
 2113&nbsp;N0002 [label="third.guardproof.info."] ;
 2114&nbsp;
 2115&nbsp;
 2116&nbsp;
 2117&nbsp;# Known address nodes
 2118&nbsp;
 2119&nbsp;A0000 [label="61.141.32.197"] ;
 2120&nbsp;
 2121&nbsp;
 2122&nbsp;
 2123&nbsp;# PC0000 guardproof.info. third.guardproof.info.
 2124&nbsp;
 2125&nbsp;N0000-&#62;N0002 ;
 2126&nbsp;
 2127&nbsp;
 2128&nbsp;
 2129&nbsp;# NA0000 third.guardproof.info. 61.141.32.197
 2130&nbsp;
 2131&nbsp;N0002-&#62;A0000 ;
 2132&nbsp;
 2133&nbsp;
 2134&nbsp;
 2135&nbsp;/*
 2136&nbsp;
 2137&nbsp;# Known name-&#62;address edges
 2138&nbsp;
 2139&nbsp;NA0000 third.guardproof.info. 61.141.32.197
 2140&nbsp;
 2141&nbsp;
 2142&nbsp;
 2143&nbsp;# Known parent-&#62;child edges
 2144&nbsp;
 2145&nbsp;PC0000 guardproof.info. third.guardproof.info.
 2146&nbsp;
 2147&nbsp; */
 2148&nbsp;
 2149&nbsp;Process that with the 'dot' program, and you have your 
 2150&nbsp;first network diagram.
 2151&nbsp;
 2152&nbsp;In addition to the conventional graphic edges, the 
 2153&nbsp;descriptor file includes similar format pair-data that 
 2154&nbsp;describes services, zone records (sub-graphs?), 
 2155&nbsp;blacklisted addresses, and other things which might be 
 2156&nbsp;interesting to include in your graph. This additional 
 2157&nbsp;information could be displayed as different node 
 2158&nbsp;shapes, colors, line sizes, etc.
 2159&nbsp;
 2160&nbsp;The descriptor file can also be read and edited by a 
 2161&nbsp;Bash script (of course). You should be able to find 
 2162&nbsp;most of the functions required within the 
 2163&nbsp;"is_spammer.bash" script.
 2164&nbsp;
 2165&nbsp;# End Quickstart.
 2166&nbsp;
 2167&nbsp;
 2168&nbsp;
 2169&nbsp;Additional Note
 2170&nbsp;========== ====
 2171&nbsp;
 2172&nbsp;Michael Zick points out that there is a "makeviz.bash" interactive
 2173&nbsp;Web site at rediris.es. Can't give the full URL, since this is not
 2174&nbsp;a publically accessible site.</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
>Another anti-spam script.</P
><P
><A
NAME="WHX0"
></A
></P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="WHX"
></A
><P
><B
>Example A-31. Spammer Hunt</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# whx.sh: "whois" spammer lookup
   3&nbsp;# Author: Walter Dnes
   4&nbsp;# Slight revisions (first section) by ABS Guide author.
   5&nbsp;# Used in ABS Guide with permission.
   6&nbsp;
   7&nbsp;# Needs version 3.x or greater of Bash to run (because of =~ operator).
   8&nbsp;# Commented by script author and ABS Guide author.
   9&nbsp;
  10&nbsp;
  11&nbsp;
  12&nbsp;E_BADARGS=65        # Missing command-line arg.
  13&nbsp;E_NOHOST=66         # Host not found.
  14&nbsp;E_TIMEOUT=67        # Host lookup timed out.
  15&nbsp;E_UNDEF=68          # Some other (undefined) error.
  16&nbsp;HOSTWAIT=10         # Specify up to 10 seconds for host query reply.
  17&nbsp;                    # The actual wait may be a bit longer.
  18&nbsp;OUTFILE=whois.txt   # Output file.
  19&nbsp;PORT=4321
  20&nbsp;
  21&nbsp;
  22&nbsp;if [ -z "$1" ]      # Check for (required) command-line arg.
  23&nbsp;then
  24&nbsp;  echo "Usage: $0 domain name or IP address"
  25&nbsp;  exit $E_BADARGS
  26&nbsp;fi
  27&nbsp;
  28&nbsp;
  29&nbsp;if [[ "$1" =~ "[a-zA-Z][a-zA-Z]$" ]]  # Ends in two alpha chars?
  30&nbsp;then                                  # It's a domain name &#38;&#38; must do host lookup.
  31&nbsp;  IPADDR=$(host -W $HOSTWAIT $1 | awk '{print $4}')
  32&nbsp;                                      # Doing host lookup to get IP address.
  33&nbsp;				      # Extract final field.
  34&nbsp;else
  35&nbsp;  IPADDR="$1"                         # Command-line arg was IP address.
  36&nbsp;fi
  37&nbsp;
  38&nbsp;echo; echo "IP Address is: "$IPADDR""; echo
  39&nbsp;
  40&nbsp;if [ -e "$OUTFILE" ]
  41&nbsp;then
  42&nbsp;  rm -f "$OUTFILE"
  43&nbsp;  echo "Stale output file \"$OUTFILE\" removed."; echo
  44&nbsp;fi
  45&nbsp;
  46&nbsp;
  47&nbsp;#  Sanity checks.
  48&nbsp;#  (This section needs more work.)
  49&nbsp;#  ===============================
  50&nbsp;if [ -z "$IPADDR" ]
  51&nbsp;# No response.
  52&nbsp;then
  53&nbsp;  echo "Host not found!"
  54&nbsp;  exit $E_NOHOST    # Bail out.
  55&nbsp;fi
  56&nbsp;
  57&nbsp;if [[ "$IPADDR" =~ "^[;;]" ]]
  58&nbsp;#  ;; connection timed out; no servers could be reached
  59&nbsp;then
  60&nbsp;  echo "Host lookup timed out!"
  61&nbsp;  exit $E_TIMEOUT   # Bail out.
  62&nbsp;fi
  63&nbsp;
  64&nbsp;if [[ "$IPADDR" =~ "[(NXDOMAIN)]$" ]]
  65&nbsp;#  Host xxxxxxxxx.xxx not found: 3(NXDOMAIN)
  66&nbsp;then
  67&nbsp;  echo "Host not found!"
  68&nbsp;  exit $E_NOHOST    # Bail out.
  69&nbsp;fi
  70&nbsp;
  71&nbsp;if [[ "$IPADDR" =~ "[(SERVFAIL)]$" ]]
  72&nbsp;#  Host xxxxxxxxx.xxx not found: 2(SERVFAIL)
  73&nbsp;then
  74&nbsp;  echo "Host not found!"
  75&nbsp;  exit $E_NOHOST    # Bail out.
  76&nbsp;fi
  77&nbsp;
  78&nbsp;
  79&nbsp;
  80&nbsp;
  81&nbsp;# ======================== Main body of script ========================
  82&nbsp;
  83&nbsp;AFRINICquery() {
  84&nbsp;#  Define the function that queries AFRINIC. Echo a notification to the
  85&nbsp;#+ screen, and then run the actual query, redirecting output to $OUTFILE.
  86&nbsp;
  87&nbsp;  echo "Searching for $IPADDR in whois.afrinic.net"
  88&nbsp;  whois -h whois.afrinic.net "$IPADDR" &#62; $OUTFILE
  89&nbsp;
  90&nbsp;#  Check for presence of reference to an rwhois.
  91&nbsp;#  Warn about non-functional rwhois.infosat.net server
  92&nbsp;#+ and attempt rwhois query.
  93&nbsp;  if grep -e "^remarks: .*rwhois\.[^ ]\+" "$OUTFILE"
  94&nbsp;  then
  95&nbsp;    echo " " &#62;&#62; $OUTFILE
  96&nbsp;    echo "***" &#62;&#62; $OUTFILE
  97&nbsp;    echo "***" &#62;&#62; $OUTFILE
  98&nbsp;    echo "Warning: rwhois.infosat.net was not working as of 2005/02/02" &#62;&#62; $OUTFILE
  99&nbsp;    echo "         when this script was written." &#62;&#62; $OUTFILE
 100&nbsp;    echo "***" &#62;&#62; $OUTFILE
 101&nbsp;    echo "***" &#62;&#62; $OUTFILE
 102&nbsp;    echo " " &#62;&#62; $OUTFILE
 103&nbsp;    RWHOIS=`grep "^remarks: .*rwhois\.[^ ]\+" "$OUTFILE" | tail -n 1 |\
 104&nbsp;    sed "s/\(^.*\)\(rwhois\..*\)\(:4.*\)/\2/"`
 105&nbsp;    whois -h ${RWHOIS}:${PORT} "$IPADDR" &#62;&#62; $OUTFILE
 106&nbsp;  fi
 107&nbsp;}
 108&nbsp;
 109&nbsp;APNICquery() {
 110&nbsp;  echo "Searching for $IPADDR in whois.apnic.net"
 111&nbsp;  whois -h whois.apnic.net "$IPADDR" &#62; $OUTFILE
 112&nbsp;
 113&nbsp;#  Just  about  every  country has its own internet registrar.
 114&nbsp;#  I don't normally bother consulting them, because the regional registry
 115&nbsp;#+ usually supplies sufficient information.
 116&nbsp;#  There are a few exceptions, where the regional registry simply
 117&nbsp;#+ refers to the national registry for direct data.
 118&nbsp;#  These are Japan and South Korea in APNIC, and Brasil in LACNIC.
 119&nbsp;#  The following if statement checks $OUTFILE (whois.txt) for the presence
 120&nbsp;#+ of "KR" (South Korea) or "JP" (Japan) in the country field.
 121&nbsp;#  If either is found, the query is re-run against the appropriate
 122&nbsp;#+ national registry.
 123&nbsp;
 124&nbsp;  if grep -E "^country:[ ]+KR$" "$OUTFILE"
 125&nbsp;  then
 126&nbsp;    echo "Searching for $IPADDR in whois.krnic.net"
 127&nbsp;    whois -h whois.krnic.net "$IPADDR" &#62;&#62; $OUTFILE
 128&nbsp;  elif grep -E "^country:[ ]+JP$" "$OUTFILE"
 129&nbsp;  then
 130&nbsp;    echo "Searching for $IPADDR in whois.nic.ad.jp"
 131&nbsp;    whois -h whois.nic.ad.jp "$IPADDR"/e &#62;&#62; $OUTFILE
 132&nbsp;  fi
 133&nbsp;}
 134&nbsp;
 135&nbsp;ARINquery() {
 136&nbsp;  echo "Searching for $IPADDR in whois.arin.net"
 137&nbsp;  whois -h whois.arin.net "$IPADDR" &#62; $OUTFILE
 138&nbsp;
 139&nbsp;#  Several large internet providers listed by ARIN have their own
 140&nbsp;#+ internal whois service, referred to as "rwhois".
 141&nbsp;#  A large block of IP addresses is listed with the provider
 142&nbsp;#+ under the ARIN registry.
 143&nbsp;#  To get the IP addresses of 2nd-level ISPs or other large customers,
 144&nbsp;#+ one has to refer to the rwhois server on port 4321.
 145&nbsp;#  I originally started with a bunch of "if" statements checking for
 146&nbsp;#+ the larger providers.
 147&nbsp;#  This approach is unwieldy, and there's always another rwhois server
 148&nbsp;#+ that I didn't know about.
 149&nbsp;#  A more elegant approach is to check $OUTFILE for a reference
 150&nbsp;#+ to a whois server, parse that server name out of the comment section,
 151&nbsp;#+ and re-run the query against the appropriate rwhois server.
 152&nbsp;#  The parsing looks a bit ugly, with a long continued line inside
 153&nbsp;#+ backticks.
 154&nbsp;#  But it only has to be done once, and will work as new servers are added.
 155&nbsp;#@   ABS Guide author comment: it isn't all that ugly, and is, in fact,
 156&nbsp;#@+  an instructive use of Regular Expressions.
 157&nbsp;
 158&nbsp;  if grep -E "^Comment: .*rwhois.[^ ]+" "$OUTFILE"
 159&nbsp;  then
 160&nbsp;    RWHOIS=`grep -e "^Comment:.*rwhois\.[^ ]\+" "$OUTFILE" | tail -n 1 |\
 161&nbsp;    sed "s/^\(.*\)\(rwhois\.[^ ]\+\)\(.*$\)/\2/"`
 162&nbsp;    echo "Searching for $IPADDR in ${RWHOIS}"
 163&nbsp;    whois -h ${RWHOIS}:${PORT} "$IPADDR" &#62;&#62; $OUTFILE
 164&nbsp;  fi
 165&nbsp;}
 166&nbsp;
 167&nbsp;LACNICquery() {
 168&nbsp;  echo "Searching for $IPADDR in whois.lacnic.net"
 169&nbsp;  whois -h whois.lacnic.net "$IPADDR" &#62; $OUTFILE
 170&nbsp;
 171&nbsp;#  The  following if statement checks $OUTFILE (whois.txt) for the presence of
 172&nbsp;#+ "BR" (Brasil) in the country field.
 173&nbsp;#  If it is found, the query is re-run against whois.registro.br.
 174&nbsp;
 175&nbsp;  if grep -E "^country:[ ]+BR$" "$OUTFILE"
 176&nbsp;  then
 177&nbsp;    echo "Searching for $IPADDR in whois.registro.br"
 178&nbsp;    whois -h whois.registro.br "$IPADDR" &#62;&#62; $OUTFILE
 179&nbsp;  fi
 180&nbsp;}
 181&nbsp;
 182&nbsp;RIPEquery() {
 183&nbsp;  echo "Searching for $IPADDR in whois.ripe.net"
 184&nbsp;  whois -h whois.ripe.net "$IPADDR" &#62; $OUTFILE
 185&nbsp;}
 186&nbsp;
 187&nbsp;#  Initialize a few variables.
 188&nbsp;#  * slash8 is the most significant octet
 189&nbsp;#  * slash16 consists of the two most significant octets
 190&nbsp;#  * octet2 is the second most significant octet
 191&nbsp;
 192&nbsp;
 193&nbsp;
 194&nbsp;
 195&nbsp;slash8=`echo $IPADDR | cut -d. -f 1`
 196&nbsp;  if [ -z "$slash8" ]  # Yet another sanity check.
 197&nbsp;  then
 198&nbsp;    echo "Undefined error!"
 199&nbsp;    exit $E_UNDEF
 200&nbsp;  fi
 201&nbsp;slash16=`echo $IPADDR | cut -d. -f 1-2`
 202&nbsp;#                             ^ Period specified as 'cut" delimiter.
 203&nbsp;  if [ -z "$slash16" ]
 204&nbsp;  then
 205&nbsp;    echo "Undefined error!"
 206&nbsp;    exit $E_UNDEF
 207&nbsp;  fi
 208&nbsp;octet2=`echo $slash16 | cut -d. -f 2`
 209&nbsp;  if [ -z "$octet2" ]
 210&nbsp;  then
 211&nbsp;    echo "Undefined error!"
 212&nbsp;    exit $E_UNDEF
 213&nbsp;  fi
 214&nbsp;
 215&nbsp;
 216&nbsp;#  Check for various odds and ends of reserved space.
 217&nbsp;#  There is no point in querying for those addresses.
 218&nbsp;
 219&nbsp;if [ $slash8 == 0 ]; then
 220&nbsp;  echo $IPADDR is '"This Network"' space\; Not querying
 221&nbsp;elif [ $slash8 == 10 ]; then
 222&nbsp;  echo $IPADDR is RFC1918 space\; Not querying
 223&nbsp;elif [ $slash8 == 14 ]; then
 224&nbsp;  echo $IPADDR is '"Public Data Network"' space\; Not querying
 225&nbsp;elif [ $slash8 == 127 ]; then
 226&nbsp;  echo $IPADDR is loopback space\; Not querying
 227&nbsp;elif [ $slash16 == 169.254 ]; then
 228&nbsp;  echo $IPADDR is link-local space\; Not querying
 229&nbsp;elif [ $slash8 == 172 ] &#38;&#38; [ $octet2 -ge 16 ] &#38;&#38; [ $octet2 -le 31 ];then
 230&nbsp;  echo $IPADDR is RFC1918 space\; Not querying
 231&nbsp;elif [ $slash16 == 192.168 ]; then
 232&nbsp;  echo $IPADDR is RFC1918 space\; Not querying
 233&nbsp;elif [ $slash8 -ge 224 ]; then
 234&nbsp;  echo $IPADDR is either Multicast or reserved space\; Not querying
 235&nbsp;elif [ $slash8 -ge 200 ] &#38;&#38; [ $slash8 -le 201 ]; then LACNICquery "$IPADDR"
 236&nbsp;elif [ $slash8 -ge 202 ] &#38;&#38; [ $slash8 -le 203 ]; then APNICquery "$IPADDR"
 237&nbsp;elif [ $slash8 -ge 210 ] &#38;&#38; [ $slash8 -le 211 ]; then APNICquery "$IPADDR"
 238&nbsp;elif [ $slash8 -ge 218 ] &#38;&#38; [ $slash8 -le 223 ]; then APNICquery "$IPADDR"
 239&nbsp;
 240&nbsp;#  If we got this far without making a decision, query ARIN.
 241&nbsp;#  If a reference is found in $OUTFILE to APNIC, AFRINIC, LACNIC, or RIPE,
 242&nbsp;#+ query the appropriate whois server.
 243&nbsp;
 244&nbsp;else
 245&nbsp;  ARINquery "$IPADDR"
 246&nbsp;  if grep "whois.afrinic.net" "$OUTFILE"; then
 247&nbsp;    AFRINICquery "$IPADDR"
 248&nbsp;  elif grep -E "^OrgID:[ ]+RIPE$" "$OUTFILE"; then
 249&nbsp;    RIPEquery "$IPADDR"
 250&nbsp;  elif grep -E "^OrgID:[ ]+APNIC$" "$OUTFILE"; then
 251&nbsp;    APNICquery "$IPADDR"
 252&nbsp;  elif grep -E "^OrgID:[ ]+LACNIC$" "$OUTFILE"; then
 253&nbsp;    LACNICquery "$IPADDR"
 254&nbsp;  fi
 255&nbsp;fi
 256&nbsp;
 257&nbsp;#@  ---------------------------------------------------------------
 258&nbsp;#   Try also:
 259&nbsp;#   wget http://logi.cc/nw/whois.php3?ACTION=doQuery&#38;DOMAIN=$IPADDR
 260&nbsp;#@  ---------------------------------------------------------------
 261&nbsp;
 262&nbsp;#  We've  now  finished  the querying.
 263&nbsp;#  Echo a copy of the final result to the screen.
 264&nbsp;
 265&nbsp;cat $OUTFILE
 266&nbsp;# Or "less $OUTFILE" . . .
 267&nbsp;
 268&nbsp;
 269&nbsp;exit 0
 270&nbsp;
 271&nbsp;#@  ABS Guide author comments:
 272&nbsp;#@  Nothing fancy here, but still a very useful tool for hunting spammers.
 273&nbsp;#@  Sure, the script can be cleaned up some, and it's still a bit buggy,
 274&nbsp;#@+ (exercise for reader), but all the same, it's a nice piece of coding
 275&nbsp;#@+ by Walter Dnes.
 276&nbsp;#@  Thank you!</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
><SPAN
CLASS="QUOTE"
>"Little Monster's"</SPAN
> front end to <A
HREF="communications.html#WGETREF"
>wget</A
>.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="WGETTER2"
></A
><P
><B
>Example A-32. Making <I
CLASS="FIRSTTERM"
>wget</I
> easier to use</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# wgetter2.bash
   3&nbsp;
   4&nbsp;# Author: Little Monster [monster@monstruum.co.uk]
   5&nbsp;# ==&#62; Used in ABS Guide with permission of script author.
   6&nbsp;# ==&#62; This script still needs debugging and fixups (exercise for reader).
   7&nbsp;# ==&#62; It could also use some additional editing in the comments.
   8&nbsp;
   9&nbsp;
  10&nbsp;#  This is wgetter2 --
  11&nbsp;#+ a Bash script to make wget a bit more friendly, and save typing.
  12&nbsp;
  13&nbsp;#  Carefully crafted by Little Monster.
  14&nbsp;#  More or less complete on 02/02/2005.
  15&nbsp;#  If you think this script can be improved,
  16&nbsp;#+ email me at: monster@monstruum.co.uk
  17&nbsp;# ==&#62; and cc: to the author of the ABS Guide, please.
  18&nbsp;#  This script is licenced under the GPL.
  19&nbsp;#  You are free to copy, alter and re-use it,
  20&nbsp;#+ but please don't try to claim you wrote it.
  21&nbsp;#  Log your changes here instead.
  22&nbsp;
  23&nbsp;# =======================================================================
  24&nbsp;# changelog:
  25&nbsp;
  26&nbsp;# 07/02/2005.  Fixups by Little Monster.
  27&nbsp;# 02/02/2005.  Minor additions by Little Monster.
  28&nbsp;#              (See after # +++++++++++ )
  29&nbsp;# 29/01/2005.  Minor stylistic edits and cleanups by author of ABS Guide.
  30&nbsp;#              Added exit error codes.
  31&nbsp;# 22/11/2004.  Finished initial version of second version of wgetter:
  32&nbsp;#              wgetter2 is born.
  33&nbsp;# 01/12/2004.  Changed 'runn' function so it can be run 2 ways --
  34&nbsp;#              either ask for a file name or have one input on the CL.
  35&nbsp;# 01/12/2004.  Made sensible handling of no URL's given.
  36&nbsp;# 01/12/2004.  Made loop of main options, so you don't
  37&nbsp;#              have to keep calling wgetter 2 all the time.
  38&nbsp;#              Runs as a session instead.
  39&nbsp;# 01/12/2004.  Added looping to 'runn' function.
  40&nbsp;#              Simplified and improved.
  41&nbsp;# 01/12/2004.  Added state to recursion setting.
  42&nbsp;#              Enables re-use of previous value.
  43&nbsp;# 05/12/2004.  Modified the file detection routine in the 'runn' function
  44&nbsp;#              so it's not fooled by empty values, and is cleaner.
  45&nbsp;# 01/02/2004.  Added cookie finding routine from later version (which 
  46&nbsp;#              isn't ready yet), so as not to have hard-coded paths.
  47&nbsp;# =======================================================================
  48&nbsp;
  49&nbsp;# Error codes for abnormal exit.
  50&nbsp;E_USAGE=67        # Usage message, then quit.
  51&nbsp;E_NO_OPTS=68      # No command-line args entered.
  52&nbsp;E_NO_URLS=69      # No URLs passed to script.
  53&nbsp;E_NO_SAVEFILE=70  # No save filename passed to script.
  54&nbsp;E_USER_EXIT=71    # User decides to quit.
  55&nbsp;
  56&nbsp;
  57&nbsp;#  Basic default wget command we want to use.
  58&nbsp;#  This is the place to change it, if required.
  59&nbsp;#  NB: if using a proxy, set http_proxy = yourproxy in .wgetrc.
  60&nbsp;#  Otherwise delete --proxy=on, below.
  61&nbsp;# ====================================================================
  62&nbsp;CommandA="wget -nc -c -t 5 --progress=bar --random-wait --proxy=on -r"
  63&nbsp;# ====================================================================
  64&nbsp;
  65&nbsp;
  66&nbsp;
  67&nbsp;# --------------------------------------------------------------------
  68&nbsp;# Set some other variables and explain them.
  69&nbsp;
  70&nbsp;pattern=" -A .jpg,.JPG,.jpeg,.JPEG,.gif,.GIF,.htm,.html,.shtml,.php"
  71&nbsp;                    # wget's option to only get certain types of file.
  72&nbsp;                    # comment out if not using
  73&nbsp;today=`date +%F`    # Used for a filename.
  74&nbsp;home=$HOME          # Set HOME to an internal variable.
  75&nbsp;                    # In case some other path is used, change it here.
  76&nbsp;depthDefault=3      # Set a sensible default recursion.
  77&nbsp;Depth=$depthDefault # Otherwise user feedback doesn't tie in properly.
  78&nbsp;RefA=""             # Set blank referring page.
  79&nbsp;Flag=""             #  Default to not saving anything,
  80&nbsp;                    #+ or whatever else might be wanted in future.
  81&nbsp;lister=""           # Used for passing a list of urls directly to wget.
  82&nbsp;Woptions=""         # Used for passing wget some options for itself.
  83&nbsp;inFile=""           # Used for the run function.
  84&nbsp;newFile=""          # Used for the run function.
  85&nbsp;savePath="$home/w-save"
  86&nbsp;Config="$home/.wgetter2rc"
  87&nbsp;                    #  This is where some variables can be stored, 
  88&nbsp;                    #+ if permanently changed from within the script.
  89&nbsp;Cookie_List="$home/.cookielist"
  90&nbsp;                    # So we know where the cookies are kept . . .
  91&nbsp;cFlag=""            # Part of the cookie file selection routine.
  92&nbsp;
  93&nbsp;# Define the options available. Easy to change letters here if needed.
  94&nbsp;# These are the optional options; you don't just wait to be asked.
  95&nbsp;
  96&nbsp;save=s   # Save command instead of executing it.
  97&nbsp;cook=c   # Change cookie file for this session.
  98&nbsp;help=h   # Usage guide.
  99&nbsp;list=l   # Pass wget the -i option and URL list.
 100&nbsp;runn=r   # Run saved commands as an argument to the option.
 101&nbsp;inpu=i   # Run saved commands interactively.
 102&nbsp;wopt=w   # Allow to enter options to pass directly to wget.
 103&nbsp;# --------------------------------------------------------------------
 104&nbsp;
 105&nbsp;
 106&nbsp;if [ -z "$1" ]; then   # Make sure we get something for wget to eat.
 107&nbsp;   echo "You must at least enter a URL or option!"
 108&nbsp;   echo "-$help for usage."
 109&nbsp;   exit $E_NO_OPTS
 110&nbsp;fi
 111&nbsp;
 112&nbsp;
 113&nbsp;
 114&nbsp;# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 115&nbsp;# added added added added added added added added added added added added
 116&nbsp;
 117&nbsp;if [ ! -e "$Config" ]; then   # See if configuration file exists.
 118&nbsp;   echo "Creating configuration file, $Config"
 119&nbsp;   echo "# This is the configuration file for wgetter2" &#62; "$Config"
 120&nbsp;   echo "# Your customised settings will be saved in this file" &#62;&#62; "$Config"
 121&nbsp;else
 122&nbsp;   source $Config             # Import variables we set outside the script.
 123&nbsp;fi
 124&nbsp;
 125&nbsp;if [ ! -e "$Cookie_List" ]; then
 126&nbsp;   # Set up a list of cookie files, if there isn't one.
 127&nbsp;   echo "Hunting for cookies . . ."
 128&nbsp;   find -name cookies.txt &#62;&#62; $Cookie_List # Create the list of cookie files.
 129&nbsp;fi #  Isolate this in its own 'if' statement,
 130&nbsp;   #+ in case we got interrupted while searching.
 131&nbsp;
 132&nbsp;if [ -z "$cFlag" ]; then # If we haven't already done this . . .
 133&nbsp;   echo                  # Make a nice space after the command prompt.
 134&nbsp;   echo "Looks like you haven't set up your source of cookies yet."
 135&nbsp;   n=0                   #  Make sure the counter
 136&nbsp;                         #+ doesn't contain random values.
 137&nbsp;   while read; do
 138&nbsp;      Cookies[$n]=$REPLY # Put the cookie files we found into an array.
 139&nbsp;      echo "$n) ${Cookies[$n]}"  # Create a menu.
 140&nbsp;      n=$(( n + 1 ))     # Increment the counter.
 141&nbsp;   done &#60; $Cookie_List   # Feed the read statement.
 142&nbsp;   echo "Enter the number of the cookie file you want to use."
 143&nbsp;   echo "If you won't be using cookies, just press RETURN."
 144&nbsp;   echo
 145&nbsp;   echo "I won't be asking this again. Edit $Config"
 146&nbsp;   echo "If you decide to change at a later date"
 147&nbsp;   echo "or use the -${cook} option for per session changes."
 148&nbsp;   read
 149&nbsp;   if [ ! -z $REPLY ]; then   # User didn't just press return.
 150&nbsp;      Cookie=" --load-cookies ${Cookies[$REPLY]}"
 151&nbsp;      # Set the variable here as well as in the config file.
 152&nbsp;
 153&nbsp;      echo "Cookie=\" --load-cookies ${Cookies[$REPLY]}\"" &#62;&#62; $Config
 154&nbsp;   fi
 155&nbsp;   echo "cFlag=1" &#62;&#62; $Config  # So we know not to ask again.
 156&nbsp;fi
 157&nbsp;
 158&nbsp;# end added section end added section end added section end added section
 159&nbsp;# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 160&nbsp;
 161&nbsp;
 162&nbsp;
 163&nbsp;# Another variable.
 164&nbsp;# This one may or may not be subject to variation.
 165&nbsp;# A bit like the small print.
 166&nbsp;CookiesON=$Cookie
 167&nbsp;# echo "cookie file is $CookiesON" # For debugging.
 168&nbsp;# echo "home is ${home}"           # For debugging.
 169&nbsp;                                   # Got caught with this one!
 170&nbsp;
 171&nbsp;
 172&nbsp;wopts()
 173&nbsp;{
 174&nbsp;echo "Enter options to pass to wget."
 175&nbsp;echo "It is assumed you know what you're doing."
 176&nbsp;echo
 177&nbsp;echo "You can pass their arguments here too."
 178&nbsp;# That is to say, everything passed here is passed to wget.
 179&nbsp;
 180&nbsp;read Wopts
 181&nbsp;# Read in the options to be passed to wget.
 182&nbsp;
 183&nbsp;Woptions=" $Wopts"
 184&nbsp;#         ^  Why the leading space?
 185&nbsp;# Assign to another variable.
 186&nbsp;# Just for fun, or something . . .
 187&nbsp;
 188&nbsp;echo "passing options ${Wopts} to wget"
 189&nbsp;# Mainly for debugging.
 190&nbsp;# Is cute.
 191&nbsp;
 192&nbsp;return
 193&nbsp;}
 194&nbsp;
 195&nbsp;
 196&nbsp;save_func()
 197&nbsp;{
 198&nbsp;echo "Settings will be saved."
 199&nbsp;if [ ! -d $savePath ]; then  #  See if directory exists.
 200&nbsp;   mkdir $savePath           #  Create the directory to save things in
 201&nbsp;                             #+ if it isn't already there.
 202&nbsp;fi
 203&nbsp;
 204&nbsp;Flag=S
 205&nbsp;# Tell the final bit of code what to do.
 206&nbsp;# Set a flag since stuff is done in main.
 207&nbsp;
 208&nbsp;return
 209&nbsp;}
 210&nbsp;
 211&nbsp;
 212&nbsp;usage() # Tell them how it works.
 213&nbsp;{
 214&nbsp;    echo "Welcome to wgetter.  This is a front end to wget."
 215&nbsp;    echo "It will always run wget with these options:"
 216&nbsp;    echo "$CommandA"
 217&nbsp;    echo "and the pattern to match: $pattern \
 218&nbsp;(which you can change at the top of this script)."
 219&nbsp;    echo "It will also ask you for recursion depth, \
 220&nbsp;and if you want to use a referring page."
 221&nbsp;    echo "Wgetter accepts the following options:"
 222&nbsp;    echo ""
 223&nbsp;    echo "-$help : Display this help."
 224&nbsp;    echo "-$save : Save the command to a file $savePath/wget-($today) \
 225&nbsp;instead of running it."
 226&nbsp;    echo "-$runn : Run saved wget commands instead of starting a new one -"
 227&nbsp;    echo "Enter filename as argument to this option."
 228&nbsp;    echo "-$inpu : Run saved wget commands interactively --"
 229&nbsp;    echo "The script will ask you for the filename."
 230&nbsp;    echo "-$cook : Change the cookies file for this session."
 231&nbsp;    echo "-$list : Tell wget to use URL's from a list instead of \
 232&nbsp;from the command line."
 233&nbsp;    echo "-$wopt : Pass any other options direct to wget."
 234&nbsp;    echo ""
 235&nbsp;    echo "See the wget man page for additional options \
 236&nbsp;you can pass to wget."
 237&nbsp;    echo ""
 238&nbsp;
 239&nbsp;    exit $E_USAGE  # End here. Don't process anything else.
 240&nbsp;}
 241&nbsp;
 242&nbsp;
 243&nbsp;
 244&nbsp;list_func() #  Gives the user the option to use the -i option to wget,
 245&nbsp;            #+ and a list of URLs.
 246&nbsp;{
 247&nbsp;while [ 1 ]; do
 248&nbsp;   echo "Enter the name of the file containing URL's (press q to change
 249&nbsp;your mind)."
 250&nbsp;   read urlfile
 251&nbsp;   if [ ! -e "$urlfile" ] &#38;&#38; [ "$urlfile" != q ]; then
 252&nbsp;       # Look for a file, or the quit option.
 253&nbsp;       echo "That file does not exist!"
 254&nbsp;   elif [ "$urlfile" = q ]; then # Check quit option.
 255&nbsp;       echo "Not using a url list."
 256&nbsp;       return
 257&nbsp;   else
 258&nbsp;      echo "using $urlfile."
 259&nbsp;      echo "If you gave url's on the command line, I'll use those first."
 260&nbsp;                            # Report wget standard behaviour to the user.
 261&nbsp;      lister=" -i $urlfile" # This is what we want to pass to wget.
 262&nbsp;      return
 263&nbsp;   fi
 264&nbsp;done
 265&nbsp;}
 266&nbsp;
 267&nbsp;
 268&nbsp;cookie_func() # Give the user the option to use a different cookie file.
 269&nbsp;{
 270&nbsp;while [ 1 ]; do
 271&nbsp;   echo "Change the cookies file. Press return if you don't want to change 
 272&nbsp;it."
 273&nbsp;   read Cookies
 274&nbsp;   # NB: this is not the same as Cookie, earlier.
 275&nbsp;   # There is an 's' on the end.
 276&nbsp;   # Bit like chocolate chips.
 277&nbsp;   if [ -z "$Cookies" ]; then                 # Escape clause for wusses.
 278&nbsp;      return
 279&nbsp;   elif [ ! -e "$Cookies" ]; then
 280&nbsp;      echo "File does not exist.  Try again." # Keep em going . . .
 281&nbsp;   else
 282&nbsp;       CookiesON=" --load-cookies $Cookies"   # File is good -- use it!
 283&nbsp;       return
 284&nbsp;   fi
 285&nbsp;done
 286&nbsp;}
 287&nbsp;
 288&nbsp;
 289&nbsp;
 290&nbsp;run_func()
 291&nbsp;{
 292&nbsp;if [ -z "$OPTARG" ]; then
 293&nbsp;# Test to see if we used the in-line option or the query one.
 294&nbsp;   if [ ! -d "$savePath" ]; then      # If directory doesn't exist . . .
 295&nbsp;      echo "$savePath does not appear to exist."
 296&nbsp;      echo "Please supply path and filename of saved wget commands:"
 297&nbsp;      read newFile
 298&nbsp;         until [ -f "$newFile" ]; do  # Keep going till we get something.
 299&nbsp;            echo "Sorry, that file does not exist.  Please try again."
 300&nbsp;            # Try really hard to get something.
 301&nbsp;            read newFile
 302&nbsp;         done
 303&nbsp;
 304&nbsp;
 305&nbsp;# -----------------------------------------------------------------------
 306&nbsp;#       if [ -z ( grep wget ${newfile} ) ]; then
 307&nbsp;        # Assume they haven't got the right file and bail out.
 308&nbsp;#       echo "Sorry, that file does not contain wget commands.  Aborting."
 309&nbsp;#       exit
 310&nbsp;#       fi
 311&nbsp;#
 312&nbsp;# This is bogus code.
 313&nbsp;# It doesn't actually work.
 314&nbsp;# If anyone wants to fix it, feel free!
 315&nbsp;# -----------------------------------------------------------------------
 316&nbsp;
 317&nbsp;
 318&nbsp;      filePath="${newFile}"
 319&nbsp;   else
 320&nbsp;   echo "Save path is $savePath"
 321&nbsp;     echo "Please enter name of the file which you want to use."
 322&nbsp;     echo "You have a choice of:"
 323&nbsp;     ls $savePath                                    # Give them a choice.
 324&nbsp;     read inFile
 325&nbsp;       until [ -f "$savePath/$inFile" ]; do         #  Keep going till
 326&nbsp;                                                    #+ we get something.
 327&nbsp;          if [ ! -f "${savePath}/${inFile}" ]; then # If file doesn't exist.
 328&nbsp;             echo "Sorry, that file does not exist.  Please choose from:"
 329&nbsp;             ls $savePath                           # If a mistake is made.
 330&nbsp;             read inFile
 331&nbsp;          fi
 332&nbsp;         done
 333&nbsp;      filePath="${savePath}/${inFile}"  # Make one variable . . .
 334&nbsp;   fi
 335&nbsp;else filePath="${savePath}/${OPTARG}"   # Which can be many things . . .
 336&nbsp;fi
 337&nbsp;
 338&nbsp;if [ ! -f "$filePath" ]; then           # If a bogus file got through.
 339&nbsp;   echo "You did not specify a suitable file."
 340&nbsp;   echo "Run this script with the -${save} option first."
 341&nbsp;   echo "Aborting."
 342&nbsp;   exit $E_NO_SAVEFILE
 343&nbsp;fi
 344&nbsp;echo "Using: $filePath"
 345&nbsp;while read; do
 346&nbsp;    eval $REPLY
 347&nbsp;    echo "Completed: $REPLY"
 348&nbsp;done &#60; $filePath  # Feed the actual file we are using into a 'while' loop.
 349&nbsp;
 350&nbsp;exit
 351&nbsp;}
 352&nbsp;
 353&nbsp;
 354&nbsp;
 355&nbsp;# Fish out any options we are using for the script.
 356&nbsp;# This is based on the demo in "Learning The Bash Shell" (O'Reilly).
 357&nbsp;while getopts ":$save$cook$help$list$runn:$inpu$wopt" opt
 358&nbsp;do
 359&nbsp;  case $opt in
 360&nbsp;     $save) save_func;;   #  Save some wgetter sessions for later.
 361&nbsp;     $cook) cookie_func;; #  Change cookie file.
 362&nbsp;     $help) usage;;       #  Get help.
 363&nbsp;     $list) list_func;;   #  Allow wget to use a list of URLs.
 364&nbsp;     $runn) run_func;;    #  Useful if you are calling wgetter from,
 365&nbsp;                          #+ for example, a cron script.
 366&nbsp;     $inpu) run_func;;    #  When you don't know what your files are named.
 367&nbsp;     $wopt) wopts;;       #  Pass options directly to wget.
 368&nbsp;        \?) echo "Not a valid option."
 369&nbsp;            echo "Use -${wopt} to pass options directly to wget,"
 370&nbsp;            echo "or -${help} for help";;      # Catch anything else.
 371&nbsp;  esac
 372&nbsp;done
 373&nbsp;shift $((OPTIND - 1))     # Do funky magic stuff with $#.
 374&nbsp;
 375&nbsp;
 376&nbsp;if [ -z "$1" ] &#38;&#38; [ -z "$lister" ]; then
 377&nbsp;                          #  We should be left with at least one URL
 378&nbsp;                          #+ on the command line, unless a list is 
 379&nbsp;			  #+ being used -- catch empty CL's.
 380&nbsp;   echo "No URL's given! You must enter them on the same line as wgetter2."
 381&nbsp;   echo "E.g.,  wgetter2 http://somesite http://anothersite."
 382&nbsp;   echo "Use $help option for more information."
 383&nbsp;   exit $E_NO_URLS        # Bail out, with appropriate error code.
 384&nbsp;fi
 385&nbsp;
 386&nbsp;URLS=" $@"
 387&nbsp;# Use this so that URL list can be changed if we stay in the option loop.
 388&nbsp;
 389&nbsp;while [ 1 ]; do
 390&nbsp;   # This is where we ask for the most used options.
 391&nbsp;   # (Mostly unchanged from version 1 of wgetter)
 392&nbsp;   if [ -z $curDepth ]; then
 393&nbsp;      Current=""
 394&nbsp;   else Current=" Current value is $curDepth"
 395&nbsp;   fi
 396&nbsp;       echo "How deep should I go? \
 397&nbsp;(integer: Default is $depthDefault.$Current)"
 398&nbsp;       read Depth   # Recursion -- how far should we go?
 399&nbsp;       inputB=""    # Reset this to blank on each pass of the loop.
 400&nbsp;       echo "Enter the name of the referring page (default is none)."
 401&nbsp;       read inputB  # Need this for some sites.
 402&nbsp;
 403&nbsp;       echo "Do you want to have the output logged to the terminal"
 404&nbsp;       echo "(y/n, default is yes)?"
 405&nbsp;       read noHide  # Otherwise wget will just log it to a file.
 406&nbsp;
 407&nbsp;       case $noHide in    # Now you see me, now you don't.
 408&nbsp;          y|Y ) hide="";;
 409&nbsp;          n|N ) hide=" -b";;
 410&nbsp;            * ) hide="";;
 411&nbsp;       esac
 412&nbsp;
 413&nbsp;       if [ -z ${Depth} ]; then
 414&nbsp;       #  User accepted either default or current depth,
 415&nbsp;       #+ in which case Depth is now empty.
 416&nbsp;          if [ -z ${curDepth} ]; then
 417&nbsp;          #  See if a depth was set on a previous iteration.
 418&nbsp;             Depth="$depthDefault"
 419&nbsp;             #  Set the default recursion depth if nothing
 420&nbsp;             #+ else to use.
 421&nbsp;          else Depth="$curDepth" #  Otherwise, set the one we used before.
 422&nbsp;          fi
 423&nbsp;       fi
 424&nbsp;   Recurse=" -l $Depth"          # Set how deep we want to go.
 425&nbsp;   curDepth=$Depth               # Remember setting for next time.
 426&nbsp;
 427&nbsp;       if [ ! -z $inputB ]; then
 428&nbsp;          RefA=" --referer=$inputB"   # Option to use referring page.
 429&nbsp;       fi
 430&nbsp;
 431&nbsp;   WGETTER="${CommandA}${pattern}${hide}${RefA}${Recurse}\
 432&nbsp;${CookiesON}${lister}${Woptions}${URLS}"
 433&nbsp;   #  Just string the whole lot together . . .
 434&nbsp;   #  NB: no embedded spaces.
 435&nbsp;   #  They are in the individual elements so that if any are empty,
 436&nbsp;   #+ we don't get an extra space.
 437&nbsp;
 438&nbsp;   if [ -z "${CookiesON}" ] &#38;&#38; [ "$cFlag" = "1" ] ; then
 439&nbsp;       echo "Warning -- can't find cookie file"
 440&nbsp;       #  This should be changed,
 441&nbsp;       #+ in case the user has opted to not use cookies.
 442&nbsp;   fi
 443&nbsp;
 444&nbsp;   if [ "$Flag" = "S" ]; then
 445&nbsp;      echo "$WGETTER" &#62;&#62; $savePath/wget-${today}
 446&nbsp;      #  Create a unique filename for today, or append to it if it exists.
 447&nbsp;      echo "$inputB" &#62;&#62; $savePath/site-list-${today}
 448&nbsp;      #  Make a list, so it's easy to refer back to,
 449&nbsp;      #+ since the whole command is a bit confusing to look at.
 450&nbsp;      echo "Command saved to the file $savePath/wget-${today}"
 451&nbsp;           # Tell the user.
 452&nbsp;      echo "Referring page URL saved to the file$ \
 453&nbsp;savePath/site-list-${today}"
 454&nbsp;           # Tell the user.
 455&nbsp;      Saver=" with save option"
 456&nbsp;      # Stick this somewhere, so it appears in the loop if set.
 457&nbsp;   else
 458&nbsp;       echo "*****************"
 459&nbsp;       echo "*****Getting*****"
 460&nbsp;       echo "*****************"
 461&nbsp;       echo ""
 462&nbsp;       echo "$WGETTER"
 463&nbsp;       echo ""
 464&nbsp;       echo "*****************"
 465&nbsp;       eval "$WGETTER"
 466&nbsp;   fi
 467&nbsp;
 468&nbsp;       echo ""
 469&nbsp;       echo "Starting over$Saver."
 470&nbsp;       echo "If you want to stop, press q."
 471&nbsp;       echo "Otherwise, enter some URL's:"
 472&nbsp;       # Let them go again. Tell about save option being set.
 473&nbsp;
 474&nbsp;       read
 475&nbsp;       case $REPLY in
 476&nbsp;       # Need to change this to a 'trap' clause.
 477&nbsp;          q|Q ) exit $E_USER_EXIT;;  # Exercise for the reader?
 478&nbsp;            * ) URLS=" $REPLY";;
 479&nbsp;       esac
 480&nbsp;
 481&nbsp;       echo ""
 482&nbsp;done
 483&nbsp;
 484&nbsp;
 485&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="BASHPODDER"
></A
><P
><B
>Example A-33. A <I
CLASS="FIRSTTERM"
>podcasting</I
> script</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;#  bashpodder.sh:
   4&nbsp;#  By Linc 10/1/2004
   5&nbsp;#  Find the latest script at
   6&nbsp;#+ http://linc.homeunix.org:8080/scripts/bashpodder
   7&nbsp;#  Last revision 12/14/2004 - Many Contributors!
   8&nbsp;#  If you use this and have made improvements or have comments
   9&nbsp;#+ drop me an email at linc dot fessenden at gmail dot com
  10&nbsp;#  I'd appreciate it!
  11&nbsp;
  12&nbsp;# ==&#62;  ABS Guide extra comments.
  13&nbsp;
  14&nbsp;# ==&#62;  Author of this script has kindly granted permission
  15&nbsp;# ==&#62;+ for inclusion in ABS Guide.
  16&nbsp;
  17&nbsp;
  18&nbsp;# ==&#62; ################################################################
  19&nbsp;# 
  20&nbsp;# ==&#62; What is "podcasting"?
  21&nbsp;
  22&nbsp;# ==&#62; It's broadcasting "radio shows" over the Internet.
  23&nbsp;# ==&#62; These shows can be played on iPods and other music file players.
  24&nbsp;
  25&nbsp;# ==&#62; This script makes it possible.
  26&nbsp;# ==&#62; See documentation at the script author's site, above.
  27&nbsp;
  28&nbsp;# ==&#62; ################################################################
  29&nbsp;
  30&nbsp;
  31&nbsp;# Make script crontab friendly:
  32&nbsp;cd $(dirname $0)
  33&nbsp;# ==&#62; Change to directory where this script lives.
  34&nbsp;
  35&nbsp;# datadir is the directory you want podcasts saved to:
  36&nbsp;datadir=$(date +%Y-%m-%d)
  37&nbsp;# ==&#62; Will create a directory with the name: YYYY-MM-DD
  38&nbsp;
  39&nbsp;# Check for and create datadir if necessary:
  40&nbsp;if test ! -d $datadir
  41&nbsp;        then
  42&nbsp;        mkdir $datadir
  43&nbsp;fi
  44&nbsp;
  45&nbsp;# Delete any temp file:
  46&nbsp;rm -f temp.log
  47&nbsp;
  48&nbsp;# Read the bp.conf file and wget any url not already in the podcast.log file:
  49&nbsp;while read podcast
  50&nbsp;  do # ==&#62; Main action follows.
  51&nbsp;  file=$(wget -q $podcast -O - | tr '\r' '\n' | tr \' \" | \
  52&nbsp;sed -n 's/.*url="\([^"]*\)".*/\1/p')
  53&nbsp;  for url in $file
  54&nbsp;                do
  55&nbsp;                echo $url &#62;&#62; temp.log
  56&nbsp;                if ! grep "$url" podcast.log &#62; /dev/null
  57&nbsp;                        then
  58&nbsp;                        wget -q -P $datadir "$url"
  59&nbsp;                fi
  60&nbsp;                done
  61&nbsp;    done &#60; bp.conf
  62&nbsp;
  63&nbsp;# Move dynamically created log file to permanent log file:
  64&nbsp;cat podcast.log &#62;&#62; temp.log
  65&nbsp;sort temp.log | uniq &#62; podcast.log
  66&nbsp;rm temp.log
  67&nbsp;# Create an m3u playlist:
  68&nbsp;ls $datadir | grep -v m3u &#62; $datadir/podcast.m3u
  69&nbsp;
  70&nbsp;
  71&nbsp;exit 0
  72&nbsp;
  73&nbsp;#################################################
  74&nbsp;For a different scripting approach to Podcasting,
  75&nbsp;see Phil Salkie's article, 
  76&nbsp;"Internet Radio to Podcast with Shell Tools"
  77&nbsp;in the September, 2005 issue of LINUX JOURNAL,
  78&nbsp;http://www.linuxjournal.com/article/8171
  79&nbsp;#################################################</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="NIGHTLYBACKUP"
></A
><P
><B
>Example A-34. Nightly backup to a firewire HD</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# nightly-backup.sh
   3&nbsp;# http://www.richardneill.org/source.php#nightly-backup-rsync
   4&nbsp;# Copyright (c) 2005 Richard Neill &#60;backup@richardneill.org&#62;.
   5&nbsp;# This is Free Software licensed under the GNU GPL.
   6&nbsp;# ==&#62; Included in ABS Guide with script author's kind permission.
   7&nbsp;# ==&#62; (Thanks!)
   8&nbsp;
   9&nbsp;#  This does a backup from the host computer to a locally connected
  10&nbsp;#+ firewire HDD using rsync and ssh.
  11&nbsp;#  It then rotates the backups.
  12&nbsp;#  Run it via cron every night at 5am.
  13&nbsp;#  This only backs up the home directory.
  14&nbsp;#  If ownerships (other than the user's) should be preserved,
  15&nbsp;#+ then run the rsync process as root (and re-instate the -o).
  16&nbsp;#  We save every day for 7 days, then every week for 4 weeks,
  17&nbsp;#+ then every month for 3 months.
  18&nbsp;
  19&nbsp;#  See: http://www.mikerubel.org/computers/rsync_snapshots/
  20&nbsp;#+ for more explanation of the theory.
  21&nbsp;#  Save as: $HOME/bin/nightly-backup_firewire-hdd.sh
  22&nbsp;
  23&nbsp;#  Known bugs:
  24&nbsp;#  ----------
  25&nbsp;#  i)  Ideally, we want to exclude ~/.tmp and the browser caches.
  26&nbsp;
  27&nbsp;#  ii) If the user is sitting at the computer at 5am,
  28&nbsp;#+     and files are modified while the rsync is occurring,
  29&nbsp;#+     then the BACKUP_JUSTINCASE branch gets triggered.
  30&nbsp;#      To some extent, this is a 
  31&nbsp;#+     feature, but it also causes a "disk-space leak".
  32&nbsp;
  33&nbsp;
  34&nbsp;
  35&nbsp;
  36&nbsp;
  37&nbsp;##### BEGIN CONFIGURATION SECTION ############################################
  38&nbsp;LOCAL_USER=rjn                # User whose home directory should be backed up.
  39&nbsp;MOUNT_POINT=/backup           # Mountpoint of backup drive.
  40&nbsp;                              # NO trailing slash!
  41&nbsp;                              # This must be unique (eg using a udev symlink)
  42&nbsp;SOURCE_DIR=/home/$LOCAL_USER  # NO trailing slash - it DOES matter to rsync.
  43&nbsp;BACKUP_DEST_DIR=$MOUNT_POINT/backup/`hostname -s`.${LOCAL_USER}.nightly_backup
  44&nbsp;DRY_RUN=false                 #If true, invoke rsync with -n, to do a dry run.
  45&nbsp;                              # Comment out or set to false for normal use.
  46&nbsp;VERBOSE=false                 # If true, make rsync verbose.
  47&nbsp;                              # Comment out or set to false otherwise.
  48&nbsp;COMPRESS=false                # If true, compress.
  49&nbsp;                              # Good for internet, bad on LAN.
  50&nbsp;                              # Comment out or set to false otherwise.
  51&nbsp;
  52&nbsp;### Exit Codes ###
  53&nbsp;E_VARS_NOT_SET=64
  54&nbsp;E_COMMANDLINE=65
  55&nbsp;E_MOUNT_FAIL=70
  56&nbsp;E_NOSOURCEDIR=71
  57&nbsp;E_UNMOUNTED=72
  58&nbsp;E_BACKUP=73
  59&nbsp;##### END CONFIGURATION SECTION ##############################################
  60&nbsp;
  61&nbsp;
  62&nbsp;# Check that all the important variables have been set:
  63&nbsp;if [ -z "$LOCAL_USER" ] ||
  64&nbsp;   [ -z "$SOURCE_DIR" ] ||
  65&nbsp;   [ -z "$MOUNT_POINT" ]  ||
  66&nbsp;   [ -z "$BACKUP_DEST_DIR" ]
  67&nbsp;then
  68&nbsp;   echo 'One of the variables is not set! Edit the file: $0. BACKUP FAILED.'
  69&nbsp;   exit $E_VARS_NOT_SET
  70&nbsp;fi
  71&nbsp;
  72&nbsp;if [ "$#" != 0 ]  # If command-line param(s) . . .
  73&nbsp;then              # Here document(ation).
  74&nbsp;  cat &#60;&#60;-ENDOFTEXT
  75&nbsp;    Automatic Nightly backup run from cron.
  76&nbsp;    Read the source for more details: $0
  77&nbsp;    The backup directory is $BACKUP_DEST_DIR .
  78&nbsp;    It will be created if necessary; initialisation is no longer required.
  79&nbsp;
  80&nbsp;    WARNING: Contents of $BACKUP_DEST_DIR are rotated.
  81&nbsp;    Directories named 'backup.\$i' will eventually be DELETED.
  82&nbsp;    We keep backups from every day for 7 days (1-8),
  83&nbsp;    then every week for 4 weeks (9-12),
  84&nbsp;    then every month for 3 months (13-15).
  85&nbsp;
  86&nbsp;    You may wish to add this to your crontab using 'crontab -e'
  87&nbsp;    #  Back up files: $SOURCE_DIR to $BACKUP_DEST_DIR
  88&nbsp;    #+ every night at 3:15 am
  89&nbsp;         15 03 * * * /home/$LOCAL_USER/bin/nightly-backup_firewire-hdd.sh
  90&nbsp;
  91&nbsp;    Don't forget to verify the backups are working,
  92&nbsp;    especially if you don't read cron's mail!"
  93&nbsp;	ENDOFTEXT
  94&nbsp;   exit $E_COMMANDLINE
  95&nbsp;fi
  96&nbsp;
  97&nbsp;
  98&nbsp;# Parse the options.
  99&nbsp;# ==================
 100&nbsp;
 101&nbsp;if [ "$DRY_RUN" == "true" ]; then
 102&nbsp;  DRY_RUN="-n"
 103&nbsp;  echo "WARNING:"
 104&nbsp;  echo "THIS IS A 'DRY RUN'!"
 105&nbsp;  echo "No data will actually be transferred!"
 106&nbsp;else
 107&nbsp;  DRY_RUN=""
 108&nbsp;fi
 109&nbsp;
 110&nbsp;if [ "$VERBOSE" == "true" ]; then
 111&nbsp;  VERBOSE="-v"
 112&nbsp;else
 113&nbsp;  VERBOSE=""
 114&nbsp;fi
 115&nbsp;
 116&nbsp;if [ "$COMPRESS" == "true" ]; then
 117&nbsp;  COMPRESS="-z"
 118&nbsp;else
 119&nbsp;  COMPRESS=""
 120&nbsp;fi
 121&nbsp;
 122&nbsp;
 123&nbsp;#  Every week (actually of 8 days) and every month,
 124&nbsp;#+ extra backups are preserved.
 125&nbsp;DAY_OF_MONTH=`date +%d`            # Day of month (01..31).
 126&nbsp;if [ $DAY_OF_MONTH = 01 ]; then    # First of month.
 127&nbsp;  MONTHSTART=true
 128&nbsp;elif [ $DAY_OF_MONTH = 08 \
 129&nbsp;    -o $DAY_OF_MONTH = 16 \
 130&nbsp;    -o $DAY_OF_MONTH = 24 ]; then
 131&nbsp;    # Day 8,16,24  (use 8, not 7 to better handle 31-day months)
 132&nbsp;      WEEKSTART=true
 133&nbsp;fi
 134&nbsp;
 135&nbsp;
 136&nbsp;
 137&nbsp;#  Check that the HDD is mounted.
 138&nbsp;#  At least, check that *something* is mounted here!
 139&nbsp;#  We can use something unique to the device, rather than just guessing
 140&nbsp;#+ the scsi-id by having an appropriate udev rule in
 141&nbsp;#+ /etc/udev/rules.d/10-rules.local
 142&nbsp;#+ and by putting a relevant entry in /etc/fstab.
 143&nbsp;#  Eg: this udev rule:
 144&nbsp;# BUS="scsi", KERNEL="sd*", SYSFS{vendor}="WDC WD16",
 145&nbsp;# SYSFS{model}="00JB-00GVA0     ", NAME="%k", SYMLINK="lacie_1394d%n"
 146&nbsp;
 147&nbsp;if mount | grep $MOUNT_POINT &#62;/dev/null; then
 148&nbsp;  echo "Mount point $MOUNT_POINT is indeed mounted. OK"
 149&nbsp;else
 150&nbsp;  echo -n "Attempting to mount $MOUNT_POINT..."	
 151&nbsp;           # If it isn't mounted, try to mount it.
 152&nbsp;  sudo mount $MOUNT_POINT 2&#62;/dev/null
 153&nbsp;
 154&nbsp;  if mount | grep $MOUNT_POINT &#62;/dev/null; then
 155&nbsp;    UNMOUNT_LATER=TRUE
 156&nbsp;    echo "OK"
 157&nbsp;    #  Note: Ensure that this is also unmounted
 158&nbsp;    #+ if we exit prematurely with failure.
 159&nbsp;  else
 160&nbsp;    echo "FAILED"
 161&nbsp;    echo -e "Nothing is mounted at $MOUNT_POINT. BACKUP FAILED!"
 162&nbsp;    exit $E_MOUNT_FAIL
 163&nbsp;  fi
 164&nbsp;fi
 165&nbsp;
 166&nbsp;
 167&nbsp;# Check that source dir exists and is readable.
 168&nbsp;if [ ! -r  $SOURCE_DIR ] ; then
 169&nbsp;  echo "$SOURCE_DIR does not exist, or cannot be read. BACKUP FAILED."
 170&nbsp;  exit $E_NOSOURCEDIR
 171&nbsp;fi
 172&nbsp;
 173&nbsp;
 174&nbsp;# Check that the backup directory structure is as it should be.
 175&nbsp;# If not, create it.
 176&nbsp;# Create the subdirectories.
 177&nbsp;# Note that backup.0 will be created as needed by rsync.
 178&nbsp;
 179&nbsp;for ((i=1;i&#60;=15;i++)); do
 180&nbsp;  if [ ! -d $BACKUP_DEST_DIR/backup.$i ]; then
 181&nbsp;    if /bin/mkdir -p $BACKUP_DEST_DIR/backup.$i ; then
 182&nbsp;    #  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^  No [ ] test brackets. Why?
 183&nbsp;      echo "Warning: directory $BACKUP_DEST_DIR/backup.$i is missing,"
 184&nbsp;      echo "or was not initialised. (Re-)creating it."
 185&nbsp;    else
 186&nbsp;      echo "ERROR: directory $BACKUP_DEST_DIR/backup.$i"
 187&nbsp;      echo "is missing and could not be created."
 188&nbsp;    if  [ "$UNMOUNT_LATER" == "TRUE" ]; then
 189&nbsp;        # Before we exit, unmount the mount point if necessary.
 190&nbsp;        cd
 191&nbsp;	sudo umount $MOUNT_POINT &#38;&#38;
 192&nbsp;	echo "Unmounted $MOUNT_POINT again. Giving up."
 193&nbsp;    fi
 194&nbsp;      exit $E_UNMOUNTED
 195&nbsp;  fi
 196&nbsp;fi
 197&nbsp;done
 198&nbsp;
 199&nbsp;
 200&nbsp;#  Set the permission to 700 for security
 201&nbsp;#+ on an otherwise permissive multi-user system.
 202&nbsp;if ! /bin/chmod 700 $BACKUP_DEST_DIR ; then
 203&nbsp;  echo "ERROR: Could not set permissions on $BACKUP_DEST_DIR to 700."
 204&nbsp;
 205&nbsp;  if  [ "$UNMOUNT_LATER" == "TRUE" ]; then
 206&nbsp;  # Before we exit, unmount the mount point if necessary.
 207&nbsp;     cd ; sudo umount $MOUNT_POINT \
 208&nbsp;     &#38;&#38; echo "Unmounted $MOUNT_POINT again. Giving up."
 209&nbsp;  fi
 210&nbsp;
 211&nbsp;  exit $E_UNMOUNTED
 212&nbsp;fi
 213&nbsp;
 214&nbsp;# Create the symlink: current -&#62; backup.1 if required.
 215&nbsp;# A failure here is not critical.
 216&nbsp;cd $BACKUP_DEST_DIR
 217&nbsp;if [ ! -h current ] ; then
 218&nbsp;  if ! /bin/ln -s backup.1 current ; then
 219&nbsp;    echo "WARNING: could not create symlink current -&#62; backup.1"
 220&nbsp;  fi
 221&nbsp;fi
 222&nbsp;
 223&nbsp;
 224&nbsp;# Now, do the rsync.
 225&nbsp;echo "Now doing backup with rsync..."
 226&nbsp;echo "Source dir: $SOURCE_DIR"
 227&nbsp;echo -e "Backup destination dir: $BACKUP_DEST_DIR\n"
 228&nbsp;
 229&nbsp;
 230&nbsp;/usr/bin/rsync $DRY_RUN $VERBOSE -a -S --delete --modify-window=60 \
 231&nbsp;--link-dest=../backup.1 $SOURCE_DIR $BACKUP_DEST_DIR/backup.0/
 232&nbsp;
 233&nbsp;#  Only warn, rather than exit if the rsync failed,
 234&nbsp;#+ since it may only be a minor problem.
 235&nbsp;#  E.g., if one file is not readable, rsync will fail.
 236&nbsp;#  This shouldn't prevent the rotation.
 237&nbsp;#  Not using, e.g., `date +%a`  since these directories
 238&nbsp;#+ are just full of links and don't consume *that much* space.
 239&nbsp;
 240&nbsp;if [ $? != 0 ]; then
 241&nbsp;  BACKUP_JUSTINCASE=backup.`date +%F_%T`.justincase
 242&nbsp;  echo "WARNING: the rsync process did not entirely succeed."
 243&nbsp;  echo "Something might be wrong."
 244&nbsp;  echo "Saving an extra copy at: $BACKUP_JUSTINCASE"
 245&nbsp;  echo "WARNING: if this occurs regularly, a LOT of space will be consumed,"
 246&nbsp;  echo "even though these are just hard-links!"
 247&nbsp;fi
 248&nbsp;
 249&nbsp;# Save a readme in the backup parent directory.
 250&nbsp;# Save another one in the recent subdirectory.
 251&nbsp;echo "Backup of $SOURCE_DIR on `hostname` was last run on \
 252&nbsp;`date`" &#62; $BACKUP_DEST_DIR/README.txt
 253&nbsp;echo "This backup of $SOURCE_DIR on `hostname` was created on \
 254&nbsp;`date`" &#62; $BACKUP_DEST_DIR/backup.0/README.txt
 255&nbsp;
 256&nbsp;# If we are not in a dry run, rotate the backups.
 257&nbsp;[ -z "$DRY_RUN" ] &#38;&#38;
 258&nbsp;
 259&nbsp;  #  Check how full the backup disk is.
 260&nbsp;  #  Warn if 90%. if 98% or more, we'll probably fail, so give up.
 261&nbsp;  #  (Note: df can output to more than one line.)
 262&nbsp;  #  We test this here, rather than before
 263&nbsp;  #+ so that rsync may possibly have a chance.
 264&nbsp;  DISK_FULL_PERCENT=`/bin/df $BACKUP_DEST_DIR |
 265&nbsp;  tr "\n" ' ' | awk '{print $12}' | grep -oE [0-9]+ `
 266&nbsp;  echo "Disk space check on backup partition \
 267&nbsp;  $MOUNT_POINT $DISK_FULL_PERCENT% full."
 268&nbsp;  if [ $DISK_FULL_PERCENT -gt 90 ]; then
 269&nbsp;    echo "Warning: Disk is greater than 90% full."
 270&nbsp;  fi
 271&nbsp;  if [ $DISK_FULL_PERCENT -gt 98 ]; then
 272&nbsp;    echo "Error: Disk is full! Giving up."
 273&nbsp;      if  [ "$UNMOUNT_LATER" == "TRUE" ]; then
 274&nbsp;        # Before we exit, unmount the mount point if necessary.
 275&nbsp;        cd; sudo umount $MOUNT_POINT &#38;&#38;
 276&nbsp;        echo "Unmounted $MOUNT_POINT again. Giving up."
 277&nbsp;      fi
 278&nbsp;    exit $E_UNMOUNTED
 279&nbsp;  fi
 280&nbsp;
 281&nbsp;
 282&nbsp; # Create an extra backup.
 283&nbsp; # If this copy fails, give up.
 284&nbsp; if [ -n "$BACKUP_JUSTINCASE" ]; then
 285&nbsp;   if ! /bin/cp -al $BACKUP_DEST_DIR/backup.0 \
 286&nbsp;      $BACKUP_DEST_DIR/$BACKUP_JUSTINCASE
 287&nbsp;   then
 288&nbsp;     echo "ERROR: Failed to create extra copy \
 289&nbsp;     $BACKUP_DEST_DIR/$BACKUP_JUSTINCASE"
 290&nbsp;     if  [ "$UNMOUNT_LATER" == "TRUE" ]; then
 291&nbsp;       # Before we exit, unmount the mount point if necessary.
 292&nbsp;       cd ;sudo umount $MOUNT_POINT &#38;&#38;
 293&nbsp;       echo "Unmounted $MOUNT_POINT again. Giving up."
 294&nbsp;     fi
 295&nbsp;     exit $E_UNMOUNTED
 296&nbsp;   fi
 297&nbsp; fi
 298&nbsp;
 299&nbsp;
 300&nbsp; # At start of month, rotate the oldest 8.
 301&nbsp; if [ "$MONTHSTART" == "true" ]; then
 302&nbsp;   echo -e "\nStart of month. \
 303&nbsp;   Removing oldest backup: $BACKUP_DEST_DIR/backup.15"  &#38;&#38;
 304&nbsp;   /bin/rm -rf  $BACKUP_DEST_DIR/backup.15  &#38;&#38;
 305&nbsp;   echo "Rotating monthly,weekly backups: \
 306&nbsp;   $BACKUP_DEST_DIR/backup.[8-14] -&#62; $BACKUP_DEST_DIR/backup.[9-15]"  &#38;&#38;
 307&nbsp;     /bin/mv $BACKUP_DEST_DIR/backup.14 $BACKUP_DEST_DIR/backup.15  &#38;&#38;
 308&nbsp;     /bin/mv $BACKUP_DEST_DIR/backup.13 $BACKUP_DEST_DIR/backup.14  &#38;&#38;
 309&nbsp;     /bin/mv $BACKUP_DEST_DIR/backup.12 $BACKUP_DEST_DIR/backup.13  &#38;&#38;
 310&nbsp;     /bin/mv $BACKUP_DEST_DIR/backup.11 $BACKUP_DEST_DIR/backup.12  &#38;&#38;
 311&nbsp;     /bin/mv $BACKUP_DEST_DIR/backup.10 $BACKUP_DEST_DIR/backup.11  &#38;&#38;
 312&nbsp;     /bin/mv $BACKUP_DEST_DIR/backup.9 $BACKUP_DEST_DIR/backup.10  &#38;&#38;
 313&nbsp;     /bin/mv $BACKUP_DEST_DIR/backup.8 $BACKUP_DEST_DIR/backup.9
 314&nbsp;
 315&nbsp; # At start of week, rotate the second-oldest 4.
 316&nbsp; elif [ "$WEEKSTART" == "true" ]; then
 317&nbsp;   echo -e "\nStart of week. \
 318&nbsp;   Removing oldest weekly backup: $BACKUP_DEST_DIR/backup.12"  &#38;&#38;
 319&nbsp;   /bin/rm -rf  $BACKUP_DEST_DIR/backup.12  &#38;&#38;
 320&nbsp;
 321&nbsp;   echo "Rotating weekly backups: \
 322&nbsp;   $BACKUP_DEST_DIR/backup.[8-11] -&#62; $BACKUP_DEST_DIR/backup.[9-12]"  &#38;&#38;
 323&nbsp;     /bin/mv $BACKUP_DEST_DIR/backup.11 $BACKUP_DEST_DIR/backup.12  &#38;&#38;
 324&nbsp;     /bin/mv $BACKUP_DEST_DIR/backup.10 $BACKUP_DEST_DIR/backup.11  &#38;&#38;
 325&nbsp;     /bin/mv $BACKUP_DEST_DIR/backup.9 $BACKUP_DEST_DIR/backup.10  &#38;&#38;
 326&nbsp;     /bin/mv $BACKUP_DEST_DIR/backup.8 $BACKUP_DEST_DIR/backup.9
 327&nbsp;
 328&nbsp; else
 329&nbsp;   echo -e "\nRemoving oldest daily backup: $BACKUP_DEST_DIR/backup.8"  &#38;&#38;
 330&nbsp;     /bin/rm -rf  $BACKUP_DEST_DIR/backup.8
 331&nbsp;
 332&nbsp; fi  &#38;&#38;
 333&nbsp;
 334&nbsp; # Every day, rotate the newest 8.
 335&nbsp; echo "Rotating daily backups: \
 336&nbsp; $BACKUP_DEST_DIR/backup.[1-7] -&#62; $BACKUP_DEST_DIR/backup.[2-8]"  &#38;&#38;
 337&nbsp;     /bin/mv $BACKUP_DEST_DIR/backup.7 $BACKUP_DEST_DIR/backup.8  &#38;&#38;
 338&nbsp;     /bin/mv $BACKUP_DEST_DIR/backup.6 $BACKUP_DEST_DIR/backup.7  &#38;&#38;
 339&nbsp;     /bin/mv $BACKUP_DEST_DIR/backup.5 $BACKUP_DEST_DIR/backup.6  &#38;&#38;
 340&nbsp;     /bin/mv $BACKUP_DEST_DIR/backup.4 $BACKUP_DEST_DIR/backup.5  &#38;&#38;
 341&nbsp;     /bin/mv $BACKUP_DEST_DIR/backup.3 $BACKUP_DEST_DIR/backup.4  &#38;&#38;
 342&nbsp;     /bin/mv $BACKUP_DEST_DIR/backup.2 $BACKUP_DEST_DIR/backup.3  &#38;&#38;
 343&nbsp;     /bin/mv $BACKUP_DEST_DIR/backup.1 $BACKUP_DEST_DIR/backup.2  &#38;&#38;
 344&nbsp;     /bin/mv $BACKUP_DEST_DIR/backup.0 $BACKUP_DEST_DIR/backup.1  &#38;&#38;
 345&nbsp;
 346&nbsp; SUCCESS=true
 347&nbsp;
 348&nbsp;
 349&nbsp;if  [ "$UNMOUNT_LATER" == "TRUE" ]; then
 350&nbsp;  # Unmount the mount point if it wasn't mounted to begin with.
 351&nbsp;  cd ; sudo umount $MOUNT_POINT &#38;&#38; echo "Unmounted $MOUNT_POINT again."
 352&nbsp;fi
 353&nbsp;
 354&nbsp;
 355&nbsp;if [ "$SUCCESS" == "true" ]; then
 356&nbsp;  echo 'SUCCESS!'
 357&nbsp;  exit 0
 358&nbsp;fi
 359&nbsp;
 360&nbsp;# Should have already exited if backup worked.
 361&nbsp;echo 'BACKUP FAILED! Is this just a dry run? Is the disk full?) '
 362&nbsp;exit $E_BACKUP</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="CDLL"
></A
><P
><B
>Example A-35. An expanded <I
CLASS="FIRSTTERM"
>cd</I
> command</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;###########################################################################
   2&nbsp;#
   3&nbsp;#       cdll
   4&nbsp;#       by Phil Braham
   5&nbsp;#
   6&nbsp;#       ############################################
   7&nbsp;#       Latest version of this script available from
   8&nbsp;#       http://freshmeat.net/projects/cd/
   9&nbsp;#       ############################################
  10&nbsp;#
  11&nbsp;#       .cd_new
  12&nbsp;#
  13&nbsp;#       An enhancement of the Unix cd command
  14&nbsp;#
  15&nbsp;#       There are unlimited stack entries and special entries. The stack
  16&nbsp;#       entries keep the last cd_maxhistory
  17&nbsp;#       directories that have been used. The special entries can be
  18&nbsp;#       assigned to commonly used directories.
  19&nbsp;#
  20&nbsp;#       The special entries may be pre-assigned by setting the environment
  21&nbsp;#       variables CDSn or by using the -u or -U command.
  22&nbsp;#
  23&nbsp;#       The following is a suggestion for the .profile file:
  24&nbsp;#
  25&nbsp;#               . cdll              #  Set up the cd command
  26&nbsp;#       alias cd='cd_new'           #  Replace the cd command
  27&nbsp;#               cd -U               #  Upload pre-assigned entries for
  28&nbsp;#                                   #+ the stack and special entries
  29&nbsp;#               cd -D               #  Set non-default mode
  30&nbsp;#               alias @="cd_new @"  #  Allow @ to be used to get history
  31&nbsp;#
  32&nbsp;#       For help type:
  33&nbsp;#
  34&nbsp;#               cd -h or
  35&nbsp;#               cd -H
  36&nbsp;#
  37&nbsp;#
  38&nbsp;###########################################################################
  39&nbsp;#
  40&nbsp;#       Version 1.2.1
  41&nbsp;#
  42&nbsp;#       Written by Phil Braham - Realtime Software Pty Ltd
  43&nbsp;#       (realtime@mpx.com.au)
  44&nbsp;#       Please send any suggestions or enhancements to the author (also at
  45&nbsp;#       phil@braham.net)
  46&nbsp;#
  47&nbsp;############################################################################
  48&nbsp;
  49&nbsp;cd_hm ()
  50&nbsp;{
  51&nbsp;        ${PRINTF} "%s" "cd [dir] [0-9] [@[s|h] [-g [&#60;dir&#62;]] [-d] \
  52&nbsp;[-D] [-r&#60;n&#62;] [dir|0-9] [-R&#60;n&#62;] [&#60;dir&#62;|0-9]
  53&nbsp;   [-s&#60;n&#62;] [-S&#60;n&#62;] [-u] [-U] [-f] [-F] [-h] [-H] [-v]
  54&nbsp;    &#60;dir&#62; Go to directory
  55&nbsp;    0-n         Go to previous directory (0 is previous, 1 is last but 1 etc)
  56&nbsp;                n is up to max history (default is 50)
  57&nbsp;    @           List history and special entries
  58&nbsp;    @h          List history entries
  59&nbsp;    @s          List special entries
  60&nbsp;    -g [&#60;dir&#62;]  Go to literal name (bypass special names)
  61&nbsp;                This is to allow access to dirs called '0','1','-h' etc
  62&nbsp;    -d          Change default action - verbose. (See note)
  63&nbsp;    -D          Change default action - silent. (See note)
  64&nbsp;    -s&#60;n&#62; Go to the special entry &#60;n&#62;*
  65&nbsp;    -S&#60;n&#62; Go to the special entry &#60;n&#62;
  66&nbsp;                and replace it with the current dir*
  67&nbsp;    -r&#60;n&#62; [&#60;dir&#62;] Go to directory &#60;dir&#62;
  68&nbsp;                              and then put it on special entry &#60;n&#62;*
  69&nbsp;    -R&#60;n&#62; [&#60;dir&#62;] Go to directory &#60;dir&#62;
  70&nbsp;                              and put current dir on special entry &#60;n&#62;*
  71&nbsp;    -a&#60;n&#62;       Alternative suggested directory. See note below.
  72&nbsp;    -f [&#60;file&#62;] File entries to &#60;file&#62;.
  73&nbsp;    -u [&#60;file&#62;] Update entries from &#60;file&#62;.
  74&nbsp;                If no filename supplied then default file
  75&nbsp;                (${CDPath}${2:-"$CDFile"}) is used
  76&nbsp;                -F and -U are silent versions
  77&nbsp;    -v          Print version number
  78&nbsp;    -h          Help
  79&nbsp;    -H          Detailed help
  80&nbsp;
  81&nbsp;    *The special entries (0 - 9) are held until log off, replaced by another
  82&nbsp;     entry or updated with the -u command
  83&nbsp;
  84&nbsp;    Alternative suggested directories:
  85&nbsp;    If a directory is not found then CD will suggest any
  86&nbsp;    possibilities. These are directories starting with the same letters
  87&nbsp;    and if any are found they are listed prefixed with -a&#60;n&#62;
  88&nbsp;    where &#60;n&#62; is a number.
  89&nbsp;    It's possible to go to the directory by entering cd -a&#60;n&#62;
  90&nbsp;    on the command line.
  91&nbsp;    
  92&nbsp;    The directory for -r&#60;n&#62; or -R&#60;n&#62; may be a number.
  93&nbsp;    For example:
  94&nbsp;        $ cd -r3 4  Go to history entry 4 and put it on special entry 3
  95&nbsp;        $ cd -R3 4  Put current dir on the special entry 3
  96&nbsp;                    and go to history entry 4
  97&nbsp;        $ cd -s3    Go to special entry 3
  98&nbsp;    
  99&nbsp;    Note that commands R,r,S and s may be used without a number
 100&nbsp;    and refer to 0:
 101&nbsp;        $ cd -s     Go to special entry 0
 102&nbsp;        $ cd -S     Go to special entry 0 and make special
 103&nbsp;                    entry 0 current dir
 104&nbsp;        $ cd -r 1   Go to history entry 1 and put it on special entry 0
 105&nbsp;        $ cd -r     Go to history entry 0 and put it on special entry 0
 106&nbsp;    "
 107&nbsp;        if ${TEST} "$CD_MODE" = "PREV"
 108&nbsp;        then
 109&nbsp;                ${PRINTF} "$cd_mnset"
 110&nbsp;        else
 111&nbsp;                ${PRINTF} "$cd_mset"
 112&nbsp;        fi
 113&nbsp;}
 114&nbsp;
 115&nbsp;cd_Hm ()
 116&nbsp;{
 117&nbsp;        cd_hm
 118&nbsp;        ${PRINTF} "%s" "
 119&nbsp;        The previous directories (0-$cd_maxhistory) are stored in the
 120&nbsp;        environment variables CD[0] - CD[$cd_maxhistory]
 121&nbsp;        Similarly the special directories S0 - $cd_maxspecial are in
 122&nbsp;        the environment variable CDS[0] - CDS[$cd_maxspecial]
 123&nbsp;        and may be accessed from the command line
 124&nbsp;
 125&nbsp;        The default pathname for the -f and -u commands is $CDPath
 126&nbsp;        The default filename for the -f and -u commands is $CDFile
 127&nbsp;
 128&nbsp;        Set the following environment variables:
 129&nbsp;            CDL_PROMPTLEN  - Set to the length of prompt you require.
 130&nbsp;                Prompt string is set to the right characters of the
 131&nbsp;                current directory.
 132&nbsp;                If not set then prompt is left unchanged
 133&nbsp;            CDL_PROMPT_PRE - Set to the string to prefix the prompt.
 134&nbsp;                Default is:
 135&nbsp;                    non-root:  \"\\[\\e[01;34m\\]\"  (sets colour to blue).
 136&nbsp;                    root:      \"\\[\\e[01;31m\\]\"  (sets colour to red).
 137&nbsp;            CDL_PROMPT_POST    - Set to the string to suffix the prompt.
 138&nbsp;                Default is:
 139&nbsp;                    non-root:  \"\\[\\e[00m\\]$\"
 140&nbsp;                                (resets colour and displays $).
 141&nbsp;                    root:      \"\\[\\e[00m\\]#\"
 142&nbsp;                                (resets colour and displays #).
 143&nbsp;            CDPath - Set the default path for the -f &#38; -u options.
 144&nbsp;                     Default is home directory
 145&nbsp;            CDFile - Set the default filename for the -f &#38; -u options.
 146&nbsp;                     Default is cdfile
 147&nbsp;        
 148&nbsp;"
 149&nbsp;    cd_version
 150&nbsp;
 151&nbsp;}
 152&nbsp;
 153&nbsp;cd_version ()
 154&nbsp;{
 155&nbsp; printf "Version: ${VERSION_MAJOR}.${VERSION_MINOR} Date: ${VERSION_DATE}\n"
 156&nbsp;}
 157&nbsp;
 158&nbsp;#
 159&nbsp;# Truncate right.
 160&nbsp;#
 161&nbsp;# params:
 162&nbsp;#   p1 - string
 163&nbsp;#   p2 - length to truncate to
 164&nbsp;#
 165&nbsp;# returns string in tcd
 166&nbsp;#
 167&nbsp;cd_right_trunc ()
 168&nbsp;{
 169&nbsp;    local tlen=${2}
 170&nbsp;    local plen=${#1}
 171&nbsp;    local str="${1}"
 172&nbsp;    local diff
 173&nbsp;    local filler="&#60;--"
 174&nbsp;    if ${TEST} ${plen} -le ${tlen}
 175&nbsp;    then
 176&nbsp;        tcd="${str}"
 177&nbsp;    else
 178&nbsp;        let diff=${plen}-${tlen}
 179&nbsp;        elen=3
 180&nbsp;        if ${TEST} ${diff} -le 2
 181&nbsp;        then
 182&nbsp;            let elen=${diff}
 183&nbsp;        fi
 184&nbsp;        tlen=-${tlen}
 185&nbsp;        let tlen=${tlen}+${elen}
 186&nbsp;        tcd=${filler:0:elen}${str:tlen}
 187&nbsp;    fi
 188&nbsp;}
 189&nbsp;
 190&nbsp;#
 191&nbsp;# Three versions of do history:
 192&nbsp;#    cd_dohistory  - packs history and specials side by side
 193&nbsp;#    cd_dohistoryH - Shows only hstory
 194&nbsp;#    cd_dohistoryS - Shows only specials
 195&nbsp;#
 196&nbsp;cd_dohistory ()
 197&nbsp;{
 198&nbsp;    cd_getrc
 199&nbsp;        ${PRINTF} "History:\n"
 200&nbsp;    local -i count=${cd_histcount}
 201&nbsp;    while ${TEST} ${count} -ge 0
 202&nbsp;    do
 203&nbsp;        cd_right_trunc "${CD[count]}" ${cd_lchar}
 204&nbsp;            ${PRINTF} "%2d %-${cd_lchar}.${cd_lchar}s " ${count} "${tcd}"
 205&nbsp;
 206&nbsp;        cd_right_trunc "${CDS[count]}" ${cd_rchar}
 207&nbsp;            ${PRINTF} "S%d %-${cd_rchar}.${cd_rchar}s\n" ${count} "${tcd}"
 208&nbsp;        count=${count}-1
 209&nbsp;    done
 210&nbsp;}
 211&nbsp;
 212&nbsp;cd_dohistoryH ()
 213&nbsp;{
 214&nbsp;    cd_getrc
 215&nbsp;        ${PRINTF} "History:\n"
 216&nbsp;        local -i count=${cd_maxhistory}
 217&nbsp;        while ${TEST} ${count} -ge 0
 218&nbsp;        do
 219&nbsp;          ${PRINTF} "${count} %-${cd_flchar}.${cd_flchar}s\n" ${CD[$count]}
 220&nbsp;          count=${count}-1
 221&nbsp;        done
 222&nbsp;}
 223&nbsp;
 224&nbsp;cd_dohistoryS ()
 225&nbsp;{
 226&nbsp;    cd_getrc
 227&nbsp;        ${PRINTF} "Specials:\n"
 228&nbsp;        local -i count=${cd_maxspecial}
 229&nbsp;        while ${TEST} ${count} -ge 0
 230&nbsp;        do
 231&nbsp;          ${PRINTF} "S${count} %-${cd_flchar}.${cd_flchar}s\n" ${CDS[$count]}
 232&nbsp;          count=${count}-1
 233&nbsp;        done
 234&nbsp;}
 235&nbsp;
 236&nbsp;cd_getrc ()
 237&nbsp;{
 238&nbsp;    cd_flchar=$(stty -a | awk -F \;
 239&nbsp;    '/rows/ { print $2 $3 }' | awk -F \  '{ print $4 }')
 240&nbsp;    if ${TEST} ${cd_flchar} -ne 0
 241&nbsp;    then
 242&nbsp;        cd_lchar=${cd_flchar}/2-5
 243&nbsp;        cd_rchar=${cd_flchar}/2-5
 244&nbsp;            cd_flchar=${cd_flchar}-5
 245&nbsp;    else
 246&nbsp;            cd_flchar=${FLCHAR:=75}
 247&nbsp;	    # cd_flchar is used for for the @s &#38; @h history
 248&nbsp;            cd_lchar=${LCHAR:=35}
 249&nbsp;            cd_rchar=${RCHAR:=35}
 250&nbsp;    fi
 251&nbsp;}
 252&nbsp;
 253&nbsp;cd_doselection ()
 254&nbsp;{
 255&nbsp;        local -i nm=0
 256&nbsp;        cd_doflag="TRUE"
 257&nbsp;        if ${TEST} "${CD_MODE}" = "PREV"
 258&nbsp;        then
 259&nbsp;                if ${TEST} -z "$cd_npwd"
 260&nbsp;                then
 261&nbsp;                        cd_npwd=0
 262&nbsp;                fi
 263&nbsp;        fi
 264&nbsp;        tm=$(echo "${cd_npwd}" | cut -b 1)
 265&nbsp;    if ${TEST} "${tm}" = "-"
 266&nbsp;    then
 267&nbsp;        pm=$(echo "${cd_npwd}" | cut -b 2)
 268&nbsp;        nm=$(echo "${cd_npwd}" | cut -d $pm -f2)
 269&nbsp;        case "${pm}" in
 270&nbsp;             a) cd_npwd=${cd_sugg[$nm]} ;;
 271&nbsp;             s) cd_npwd="${CDS[$nm]}" ;;
 272&nbsp;             S) cd_npwd="${CDS[$nm]}" ; CDS[$nm]=`pwd` ;;
 273&nbsp;             r) cd_npwd="$2" ; cd_specDir=$nm ; cd_doselection "$1" "$2";;
 274&nbsp;             R) cd_npwd="$2" ; CDS[$nm]=`pwd` ; cd_doselection "$1" "$2";;
 275&nbsp;        esac
 276&nbsp;    fi
 277&nbsp;
 278&nbsp;    if ${TEST} "${cd_npwd}" != "." -a "${cd_npwd}" \
 279&nbsp;!= ".." -a "${cd_npwd}" -le ${cd_maxhistory} &#62;&#62;/dev/null 2&#62;&#38;1
 280&nbsp;    then
 281&nbsp;      cd_npwd=${CD[$cd_npwd]}
 282&nbsp;     else
 283&nbsp;       case "$cd_npwd" in
 284&nbsp;                @)  cd_dohistory ; cd_doflag="FALSE" ;;
 285&nbsp;               @h) cd_dohistoryH ; cd_doflag="FALSE" ;;
 286&nbsp;               @s) cd_dohistoryS ; cd_doflag="FALSE" ;;
 287&nbsp;               -h) cd_hm ; cd_doflag="FALSE" ;;
 288&nbsp;               -H) cd_Hm ; cd_doflag="FALSE" ;;
 289&nbsp;               -f) cd_fsave "SHOW" $2 ; cd_doflag="FALSE" ;;
 290&nbsp;               -u) cd_upload "SHOW" $2 ; cd_doflag="FALSE" ;;
 291&nbsp;               -F) cd_fsave "NOSHOW" $2 ; cd_doflag="FALSE" ;;
 292&nbsp;               -U) cd_upload "NOSHOW" $2 ; cd_doflag="FALSE" ;;
 293&nbsp;               -g) cd_npwd="$2" ;;
 294&nbsp;               -d) cd_chdefm 1; cd_doflag="FALSE" ;;
 295&nbsp;               -D) cd_chdefm 0; cd_doflag="FALSE" ;;
 296&nbsp;               -r) cd_npwd="$2" ; cd_specDir=0 ; cd_doselection "$1" "$2";;
 297&nbsp;               -R) cd_npwd="$2" ; CDS[0]=`pwd` ; cd_doselection "$1" "$2";;
 298&nbsp;               -s) cd_npwd="${CDS[0]}" ;;
 299&nbsp;               -S) cd_npwd="${CDS[0]}"  ; CDS[0]=`pwd` ;;
 300&nbsp;               -v) cd_version ; cd_doflag="FALSE";;
 301&nbsp;       esac
 302&nbsp;    fi
 303&nbsp;}
 304&nbsp;
 305&nbsp;cd_chdefm ()
 306&nbsp;{
 307&nbsp;        if ${TEST} "${CD_MODE}" = "PREV"
 308&nbsp;        then
 309&nbsp;                CD_MODE=""
 310&nbsp;                if ${TEST} $1 -eq 1
 311&nbsp;                then
 312&nbsp;                        ${PRINTF} "${cd_mset}"
 313&nbsp;                fi
 314&nbsp;        else
 315&nbsp;                CD_MODE="PREV"
 316&nbsp;                if ${TEST} $1 -eq 1
 317&nbsp;                then
 318&nbsp;                        ${PRINTF} "${cd_mnset}"
 319&nbsp;                fi
 320&nbsp;        fi
 321&nbsp;}
 322&nbsp;
 323&nbsp;cd_fsave ()
 324&nbsp;{
 325&nbsp;        local sfile=${CDPath}${2:-"$CDFile"}
 326&nbsp;        if ${TEST} "$1" = "SHOW"
 327&nbsp;        then
 328&nbsp;                ${PRINTF} "Saved to %s\n" $sfile
 329&nbsp;        fi
 330&nbsp;        ${RM} -f ${sfile}
 331&nbsp;        local -i count=0
 332&nbsp;        while ${TEST} ${count} -le ${cd_maxhistory}
 333&nbsp;        do
 334&nbsp;                echo "CD[$count]=\"${CD[$count]}\"" &#62;&#62; ${sfile}
 335&nbsp;                count=${count}+1
 336&nbsp;        done
 337&nbsp;        count=0
 338&nbsp;        while ${TEST} ${count} -le ${cd_maxspecial}
 339&nbsp;        do
 340&nbsp;                echo "CDS[$count]=\"${CDS[$count]}\"" &#62;&#62; ${sfile}
 341&nbsp;                count=${count}+1
 342&nbsp;        done
 343&nbsp;}
 344&nbsp;
 345&nbsp;cd_upload ()
 346&nbsp;{
 347&nbsp;        local sfile=${CDPath}${2:-"$CDFile"}
 348&nbsp;        if ${TEST} "${1}" = "SHOW"
 349&nbsp;        then
 350&nbsp;                ${PRINTF} "Loading from %s\n" ${sfile}
 351&nbsp;        fi
 352&nbsp;        . ${sfile}
 353&nbsp;}
 354&nbsp;
 355&nbsp;cd_new ()
 356&nbsp;{
 357&nbsp;    local -i count
 358&nbsp;    local -i choose=0
 359&nbsp;
 360&nbsp;        cd_npwd="${1}"
 361&nbsp;        cd_specDir=-1
 362&nbsp;        cd_doselection "${1}" "${2}"
 363&nbsp;
 364&nbsp;        if ${TEST} ${cd_doflag} = "TRUE"
 365&nbsp;        then
 366&nbsp;                if ${TEST} "${CD[0]}" != "`pwd`"
 367&nbsp;                then
 368&nbsp;                        count=$cd_maxhistory
 369&nbsp;                        while ${TEST} $count -gt 0
 370&nbsp;                        do
 371&nbsp;                                CD[$count]=${CD[$count-1]}
 372&nbsp;                                count=${count}-1
 373&nbsp;                        done
 374&nbsp;                        CD[0]=`pwd`
 375&nbsp;                fi
 376&nbsp;                command cd "${cd_npwd}" 2&#62;/dev/null
 377&nbsp;        if ${TEST} $? -eq 1
 378&nbsp;        then
 379&nbsp;            ${PRINTF} "Unknown dir: %s\n" "${cd_npwd}"
 380&nbsp;            local -i ftflag=0
 381&nbsp;            for i in "${cd_npwd}"*
 382&nbsp;            do
 383&nbsp;                if ${TEST} -d "${i}"
 384&nbsp;                then
 385&nbsp;                    if ${TEST} ${ftflag} -eq 0
 386&nbsp;                    then
 387&nbsp;                        ${PRINTF} "Suggest:\n"
 388&nbsp;                        ftflag=1
 389&nbsp;                fi
 390&nbsp;                    ${PRINTF} "\t-a${choose} %s\n" "$i"
 391&nbsp;                                        cd_sugg[$choose]="${i}"
 392&nbsp;                    choose=${choose}+1
 393&nbsp;        fi
 394&nbsp;            done
 395&nbsp;        fi
 396&nbsp;        fi
 397&nbsp;
 398&nbsp;        if ${TEST} ${cd_specDir} -ne -1
 399&nbsp;        then
 400&nbsp;                CDS[${cd_specDir}]=`pwd`
 401&nbsp;        fi
 402&nbsp;
 403&nbsp;        if ${TEST} ! -z "${CDL_PROMPTLEN}"
 404&nbsp;        then
 405&nbsp;        cd_right_trunc "${PWD}" ${CDL_PROMPTLEN}
 406&nbsp;            cd_rp=${CDL_PROMPT_PRE}${tcd}${CDL_PROMPT_POST}
 407&nbsp;                export PS1="$(echo -ne ${cd_rp})"
 408&nbsp;        fi
 409&nbsp;}
 410&nbsp;#########################################################################
 411&nbsp;#                                                                       #
 412&nbsp;#                        Initialisation here                            #
 413&nbsp;#                                                                       #
 414&nbsp;#########################################################################
 415&nbsp;#
 416&nbsp;VERSION_MAJOR="1"
 417&nbsp;VERSION_MINOR="2.1"
 418&nbsp;VERSION_DATE="24-MAY-2003"
 419&nbsp;#
 420&nbsp;alias cd=cd_new
 421&nbsp;#
 422&nbsp;# Set up commands
 423&nbsp;RM=/bin/rm
 424&nbsp;TEST=test
 425&nbsp;PRINTF=printf              # Use builtin printf
 426&nbsp;
 427&nbsp;#########################################################################
 428&nbsp;#                                                                       #
 429&nbsp;# Change this to modify the default pre- and post prompt strings.       #
 430&nbsp;# These only come into effect if CDL_PROMPTLEN is set.                  #
 431&nbsp;#                                                                       #
 432&nbsp;#########################################################################
 433&nbsp;if ${TEST} ${EUID} -eq 0
 434&nbsp;then
 435&nbsp;#   CDL_PROMPT_PRE=${CDL_PROMPT_PRE:="$HOSTNAME@"}
 436&nbsp;    CDL_PROMPT_PRE=${CDL_PROMPT_PRE:="\\[\\e[01;31m\\]"}  # Root is in red
 437&nbsp;    CDL_PROMPT_POST=${CDL_PROMPT_POST:="\\[\\e[00m\\]#"}
 438&nbsp;else
 439&nbsp;    CDL_PROMPT_PRE=${CDL_PROMPT_PRE:="\\[\\e[01;34m\\]"}  # Users in blue
 440&nbsp;    CDL_PROMPT_POST=${CDL_PROMPT_POST:="\\[\\e[00m\\]$"}
 441&nbsp;fi
 442&nbsp;#########################################################################
 443&nbsp;#
 444&nbsp;# cd_maxhistory defines the max number of history entries allowed.
 445&nbsp;typeset -i cd_maxhistory=50
 446&nbsp;
 447&nbsp;#########################################################################
 448&nbsp;#
 449&nbsp;# cd_maxspecial defines the number of special entries.
 450&nbsp;typeset -i cd_maxspecial=9
 451&nbsp;#
 452&nbsp;#
 453&nbsp;#########################################################################
 454&nbsp;#
 455&nbsp;#  cd_histcount defines the number of entries displayed in
 456&nbsp;#+ the history command.
 457&nbsp;typeset -i cd_histcount=9
 458&nbsp;#
 459&nbsp;#########################################################################
 460&nbsp;export CDPath=${HOME}/
 461&nbsp;#  Change these to use a different                                      #
 462&nbsp;#+ default path and filename                                            #
 463&nbsp;export CDFile=${CDFILE:=cdfile}           # for the -u and -f commands  #
 464&nbsp;#
 465&nbsp;#########################################################################
 466&nbsp;                                                                        #
 467&nbsp;typeset -i cd_lchar cd_rchar cd_flchar
 468&nbsp;                        #  This is the number of chars to allow for the #
 469&nbsp;cd_flchar=${FLCHAR:=75} #+ cd_flchar is used for for the @s &#38; @h history#
 470&nbsp;
 471&nbsp;typeset -ax CD CDS
 472&nbsp;#
 473&nbsp;cd_mset="\n\tDefault mode is now set - entering cd with no parameters \
 474&nbsp;has the default action\n\tUse cd -d or -D for cd to go to \
 475&nbsp;previous directory with no parameters\n"
 476&nbsp;cd_mnset="\n\tNon-default mode is now set - entering cd with no \
 477&nbsp;parameters is the same as entering cd 0\n\tUse cd -d or \
 478&nbsp;-D to change default cd action\n"
 479&nbsp;
 480&nbsp;# ==================================================================== #
 481&nbsp;
 482&nbsp;
 483&nbsp;
 484&nbsp;: &#60;&#60;DOCUMENTATION
 485&nbsp;
 486&nbsp;Written by Phil Braham. Realtime Software Pty Ltd.
 487&nbsp;Released under GNU license. Free to use. Please pass any modifications
 488&nbsp;or comments to the author Phil Braham:
 489&nbsp;
 490&nbsp;realtime@mpx.com.au
 491&nbsp;=======================================================================
 492&nbsp;
 493&nbsp;cdll is a replacement for cd and incorporates similar functionality to
 494&nbsp;the bash pushd and popd commands but is independent of them.
 495&nbsp;
 496&nbsp;This version of cdll has been tested on Linux using Bash. It will work
 497&nbsp;on most Linux versions but will probably not work on other shells without
 498&nbsp;modification.
 499&nbsp;
 500&nbsp;Introduction
 501&nbsp;============
 502&nbsp;
 503&nbsp;cdll allows easy moving about between directories. When changing to a new
 504&nbsp;directory the current one is automatically put onto a stack. By default
 505&nbsp;50 entries are kept, but this is configurable. Special directories can be
 506&nbsp;kept for easy access - by default up to 10, but this is configurable. The
 507&nbsp;most recent stack entries and the special entries can be easily viewed.
 508&nbsp;
 509&nbsp;The directory stack and special entries can be saved to, and loaded from,
 510&nbsp;a file. This allows them to be set up on login, saved before logging out
 511&nbsp;or changed when moving project to project.
 512&nbsp;
 513&nbsp;In addition, cdll provides a flexible command prompt facility that allows,
 514&nbsp;for example, a directory name in colour that is truncated from the left
 515&nbsp;if it gets too long.
 516&nbsp;
 517&nbsp;
 518&nbsp;Setting up cdll
 519&nbsp;===============
 520&nbsp;
 521&nbsp;Copy cdll to either your local home directory or a central directory
 522&nbsp;such as /usr/bin (this will require root access).
 523&nbsp;
 524&nbsp;Copy the file cdfile to your home directory. It will require read and
 525&nbsp;write access. This a default file that contains a directory stack and
 526&nbsp;special entries.
 527&nbsp;
 528&nbsp;To replace the cd command you must add commands to your login script.
 529&nbsp;The login script is one or more of:
 530&nbsp;
 531&nbsp;    /etc/profile
 532&nbsp;    ~/.bash_profile
 533&nbsp;    ~/.bash_login
 534&nbsp;    ~/.profile
 535&nbsp;    ~/.bashrc
 536&nbsp;    /etc/bash.bashrc.local
 537&nbsp;    
 538&nbsp;To setup your login, ~/.bashrc is recommended, for global (and root) setup
 539&nbsp;add the commands to /etc/bash.bashrc.local
 540&nbsp;    
 541&nbsp;To set up on login, add the command:
 542&nbsp;    . &#60;dir&#62;/cdll
 543&nbsp;For example if cdll is in your local home directory:
 544&nbsp;    . ~/cdll
 545&nbsp;If in /usr/bin then:
 546&nbsp;    . /usr/bin/cdll
 547&nbsp;
 548&nbsp;If you want to use this instead of the buitin cd command then add:
 549&nbsp;    alias cd='cd_new'
 550&nbsp;We would also recommend the following commands:
 551&nbsp;    alias @='cd_new @'
 552&nbsp;    cd -U
 553&nbsp;    cd -D
 554&nbsp;
 555&nbsp;If you want to use cdll's prompt facilty then add the following:
 556&nbsp;    CDL_PROMPTLEN=nn
 557&nbsp;Where nn is a number described below. Initially 99 would be suitable
 558&nbsp;number.
 559&nbsp;
 560&nbsp;Thus the script looks something like this:
 561&nbsp;
 562&nbsp;    ######################################################################
 563&nbsp;    # CD Setup
 564&nbsp;    ######################################################################
 565&nbsp;    CDL_PROMPTLEN=21        # Allow a prompt length of up to 21 characters
 566&nbsp;    . /usr/bin/cdll         # Initialise cdll
 567&nbsp;    alias cd='cd_new'       # Replace the built in cd command
 568&nbsp;    alias @='cd_new @'      # Allow @ at the prompt to display history
 569&nbsp;    cd -U                   # Upload directories
 570&nbsp;    cd -D                   # Set default action to non-posix
 571&nbsp;    ######################################################################
 572&nbsp;
 573&nbsp;The full meaning of these commands will become clear later.
 574&nbsp;
 575&nbsp;There are a couple of caveats. If another program changes the directory
 576&nbsp;without calling cdll, then the directory won't be put on the stack and
 577&nbsp;also if the prompt facility is used then this will not be updated. Two
 578&nbsp;programs that can do this are pushd and popd. To update the prompt and
 579&nbsp;stack simply enter:
 580&nbsp;
 581&nbsp;    cd .
 582&nbsp;    
 583&nbsp;Note that if the previous entry on the stack is the current directory
 584&nbsp;then the stack is not updated.
 585&nbsp;
 586&nbsp;Usage
 587&nbsp;=====  
 588&nbsp;cd [dir] [0-9] [@[s|h] [-g &#60;dir&#62;] [-d] [-D] [-r&#60;n&#62;]
 589&nbsp;   [dir|0-9] [-R&#60;n&#62;] [&#60;dir&#62;|0-9] [-s&#60;n&#62;] [-S&#60;n&#62;]
 590&nbsp;   [-u] [-U] [-f] [-F] [-h] [-H] [-v]
 591&nbsp;
 592&nbsp;    &#60;dir&#62;       Go to directory
 593&nbsp;    0-n         Goto previous directory (0 is previous,
 594&nbsp;                1 is last but 1, etc.)
 595&nbsp;                n is up to max history (default is 50)
 596&nbsp;    @           List history and special entries (Usually available as $ @)
 597&nbsp;    @h          List history entries
 598&nbsp;    @s          List special entries
 599&nbsp;    -g [&#60;dir&#62;]  Go to literal name (bypass special names)
 600&nbsp;                This is to allow access to dirs called '0','1','-h' etc
 601&nbsp;    -d          Change default action - verbose. (See note)
 602&nbsp;    -D          Change default action - silent. (See note)
 603&nbsp;    -s&#60;n&#62;       Go to the special entry &#60;n&#62;
 604&nbsp;    -S&#60;n&#62;       Go to the special entry &#60;n&#62;
 605&nbsp;                      and replace it with the current dir
 606&nbsp;    -r&#60;n&#62; [&#60;dir&#62;] Go to directory &#60;dir&#62;
 607&nbsp;                              and then put it on special entry &#60;n&#62;
 608&nbsp;    -R&#60;n&#62; [&#60;dir&#62;] Go to directory &#60;dir&#62;
 609&nbsp;                              and put current dir on special entry &#60;n&#62;
 610&nbsp;    -a&#60;n&#62;       Alternative suggested directory. See note below.
 611&nbsp;    -f [&#60;file&#62;] File entries to &#60;file&#62;.
 612&nbsp;    -u [&#60;file&#62;] Update entries from &#60;file&#62;.
 613&nbsp;                If no filename supplied then default file (~/cdfile) is used
 614&nbsp;                -F and -U are silent versions
 615&nbsp;    -v          Print version number
 616&nbsp;    -h          Help
 617&nbsp;    -H          Detailed help
 618&nbsp;
 619&nbsp;
 620&nbsp;
 621&nbsp;Examples
 622&nbsp;========
 623&nbsp;
 624&nbsp;These examples assume non-default mode is set (that is, cd with no
 625&nbsp;parameters will go to the most recent stack directory), that aliases
 626&nbsp;have been set up for cd and @ as described above and that cd's prompt
 627&nbsp;facility is active and the prompt length is 21 characters.
 628&nbsp;
 629&nbsp;    /home/phil$ @
 630&nbsp;    # List the entries with the @
 631&nbsp;    History:
 632&nbsp;    # Output of the @ command
 633&nbsp;    .....
 634&nbsp;    # Skipped these entries for brevity
 635&nbsp;    1 /home/phil/ummdev               S1 /home/phil/perl
 636&nbsp;    # Most recent two history entries
 637&nbsp;    0 /home/phil/perl/eg              S0 /home/phil/umm/ummdev
 638&nbsp;    # and two special entries are shown
 639&nbsp;    
 640&nbsp;    /home/phil$ cd /home/phil/utils/Cdll
 641&nbsp;    # Now change directories
 642&nbsp;    /home/phil/utils/Cdll$ @
 643&nbsp;    # Prompt reflects the directory.
 644&nbsp;    History:
 645&nbsp;    # New history
 646&nbsp;    .....   
 647&nbsp;    1 /home/phil/perl/eg              S1 /home/phil/perl
 648&nbsp;    # History entry 0 has moved to 1
 649&nbsp;    0 /home/phil                      S0 /home/phil/umm/ummdev
 650&nbsp;    # and the most recent has entered
 651&nbsp;       
 652&nbsp;To go to a history entry:
 653&nbsp;
 654&nbsp;    /home/phil/utils/Cdll$ cd 1
 655&nbsp;    # Go to history entry 1.
 656&nbsp;    /home/phil/perl/eg$
 657&nbsp;    # Current directory is now what was 1
 658&nbsp;    
 659&nbsp;To go to a special entry:
 660&nbsp;
 661&nbsp;    /home/phil/perl/eg$ cd -s1
 662&nbsp;    # Go to special entry 1
 663&nbsp;    /home/phil/umm/ummdev$
 664&nbsp;    # Current directory is S1
 665&nbsp;
 666&nbsp;To go to a directory called, for example, 1:
 667&nbsp;
 668&nbsp;    /home/phil$ cd -g 1
 669&nbsp;    # -g ignores the special meaning of 1
 670&nbsp;    /home/phil/1$
 671&nbsp;    
 672&nbsp;To put current directory on the special list as S1:
 673&nbsp;    cd -r1 .        #  OR
 674&nbsp;    cd -R1 .        #  These have the same effect if the directory is
 675&nbsp;                    #+ . (the current directory)
 676&nbsp;
 677&nbsp;To go to a directory and add it as a special  
 678&nbsp;  The directory for -r&#60;n&#62; or -R&#60;n&#62; may be a number.
 679&nbsp;  For example:
 680&nbsp;        $ cd -r3 4  Go to history entry 4 and put it on special entry 3
 681&nbsp;        $ cd -R3 4  Put current dir on the special entry 3 and go to
 682&nbsp;                    history entry 4
 683&nbsp;        $ cd -s3    Go to special entry 3
 684&nbsp;
 685&nbsp;    Note that commands R,r,S and s may be used without a number and
 686&nbsp;    refer to 0:
 687&nbsp;        $ cd -s     Go to special entry 0
 688&nbsp;        $ cd -S     Go to special entry 0 and make special entry 0
 689&nbsp;                    current dir
 690&nbsp;        $ cd -r 1   Go to history entry 1 and put it on special entry 0
 691&nbsp;        $ cd -r     Go to history entry 0 and put it on special entry 0
 692&nbsp;
 693&nbsp;
 694&nbsp;    Alternative suggested directories:
 695&nbsp;
 696&nbsp;    If a directory is not found, then CD will suggest any
 697&nbsp;    possibilities. These are directories starting with the same letters
 698&nbsp;    and if any are found they are listed prefixed with -a&#60;n&#62;
 699&nbsp;    where &#60;n&#62; is a number. It's possible to go to the directory
 700&nbsp;    by entering cd -a&#60;n&#62; on the command line.
 701&nbsp;
 702&nbsp;        Use cd -d or -D to change default cd action. cd -H will show
 703&nbsp;        current action.
 704&nbsp;
 705&nbsp;        The history entries (0-n) are stored in the environment variables
 706&nbsp;        CD[0] - CD[n]
 707&nbsp;        Similarly the special directories S0 - 9 are in the environment
 708&nbsp;        variable CDS[0] - CDS[9]
 709&nbsp;        and may be accessed from the command line, for example:
 710&nbsp;        
 711&nbsp;            ls -l ${CDS[3]}
 712&nbsp;            cat ${CD[8]}/file.txt
 713&nbsp;
 714&nbsp;        The default pathname for the -f and -u commands is ~
 715&nbsp;        The default filename for the -f and -u commands is cdfile
 716&nbsp;
 717&nbsp;
 718&nbsp;Configuration
 719&nbsp;=============
 720&nbsp;
 721&nbsp;    The following environment variables can be set:
 722&nbsp;    
 723&nbsp;        CDL_PROMPTLEN  - Set to the length of prompt you require.
 724&nbsp;            Prompt string is set to the right characters of the current
 725&nbsp;            directory. If not set, then prompt is left unchanged. Note
 726&nbsp;            that this is the number of characters that the directory is
 727&nbsp;            shortened to, not the total characters in the prompt.
 728&nbsp;
 729&nbsp;            CDL_PROMPT_PRE - Set to the string to prefix the prompt.
 730&nbsp;                Default is:
 731&nbsp;                    non-root:  "\\[\\e[01;34m\\]"  (sets colour to blue).
 732&nbsp;                    root:      "\\[\\e[01;31m\\]"  (sets colour to red).
 733&nbsp;
 734&nbsp;            CDL_PROMPT_POST    - Set to the string to suffix the prompt.
 735&nbsp;                Default is:
 736&nbsp;                    non-root:  "\\[\\e[00m\\]$"
 737&nbsp;                               (resets colour and displays $).
 738&nbsp;                    root:      "\\[\\e[00m\\]#"
 739&nbsp;                               (resets colour and displays #).
 740&nbsp;
 741&nbsp;        Note:
 742&nbsp;            CDL_PROMPT_PRE &#38; _POST only t
 743&nbsp;
 744&nbsp;        CDPath - Set the default path for the -f &#38; -u options.
 745&nbsp;                 Default is home directory
 746&nbsp;        CDFile - Set the default filename for the -f &#38; -u options.
 747&nbsp;                 Default is cdfile
 748&nbsp;
 749&nbsp;
 750&nbsp;    There are three variables defined in the file cdll which control the
 751&nbsp;    number of entries stored or displayed. They are in the section labeled
 752&nbsp;    'Initialisation here' towards the end of the file.
 753&nbsp;
 754&nbsp;        cd_maxhistory       - The number of history entries stored.
 755&nbsp;                              Default is 50.
 756&nbsp;        cd_maxspecial       - The number of special entries allowed.
 757&nbsp;                              Default is 9.
 758&nbsp;        cd_histcount        - The number of history and special entries
 759&nbsp;                              displayed. Default is 9.
 760&nbsp;
 761&nbsp;    Note that cd_maxspecial should be &#62;= cd_histcount to avoid displaying
 762&nbsp;    special entries that can't be set.
 763&nbsp;
 764&nbsp;
 765&nbsp;Version: 1.2.1 Date: 24-MAY-2003
 766&nbsp;
 767&nbsp;DOCUMENTATION</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="SOUNDCARDON"
></A
><P
><B
>Example A-36. A soundcard setup script</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# soundcard-on.sh
   3&nbsp;
   4&nbsp;#  Script author: Mkarcher
   5&nbsp;#  http://www.thinkwiki.org/wiki  ...
   6&nbsp;#  /Script_for_configuring_the_CS4239_sound_chip_in_PnP_mode
   7&nbsp;#  ABS Guide author made minor changes and added comments.
   8&nbsp;#  Couldn't contact script author to ask for permission to use, but ...
   9&nbsp;#+ the script was released under the FDL,
  10&nbsp;#+ so its use here should be both legal and ethical.
  11&nbsp;
  12&nbsp;#  Sound-via-pnp-script for Thinkpad 600E
  13&nbsp;#+ and possibly other computers with onboard CS4239/CS4610
  14&nbsp;#+ that do not work with the PCI driver
  15&nbsp;#+ and are not recognized by the PnP code of snd-cs4236.
  16&nbsp;#  Also for some 770-series Thinkpads, such as the 770x.
  17&nbsp;#  Run as root user, of course.
  18&nbsp;#
  19&nbsp;#  These are old and very obsolete laptop computers,
  20&nbsp;#+ but this particular script is very instructive,
  21&nbsp;#+ as it shows how to set up and hack device files.
  22&nbsp;
  23&nbsp;
  24&nbsp;
  25&nbsp;#  Search for sound card pnp device:
  26&nbsp;
  27&nbsp;for dev in /sys/bus/pnp/devices/*
  28&nbsp;do
  29&nbsp;  grep CSC0100 $dev/id &#62; /dev/null &#38;&#38; WSSDEV=$dev
  30&nbsp;  grep CSC0110 $dev/id &#62; /dev/null &#38;&#38; CTLDEV=$dev
  31&nbsp;done
  32&nbsp;# On 770x:
  33&nbsp;# WSSDEV = /sys/bus/pnp/devices/00:07
  34&nbsp;# CTLDEV = /sys/bus/pnp/devices/00:06
  35&nbsp;# These are symbolic links to /sys/devices/pnp0/ ...
  36&nbsp;
  37&nbsp;
  38&nbsp;#  Activate devices:
  39&nbsp;#  Thinkpad boots with devices disabled unless "fast boot" is turned off
  40&nbsp;#+ (in BIOS).
  41&nbsp;
  42&nbsp;echo activate &#62; $WSSDEV/resources
  43&nbsp;echo activate &#62; $CTLDEV/resources
  44&nbsp;
  45&nbsp;
  46&nbsp;# Parse resource settings.
  47&nbsp;
  48&nbsp;{ read # Discard "state = active" (see below).
  49&nbsp;  read bla port1
  50&nbsp;  read bla port2
  51&nbsp;  read bla port3
  52&nbsp;  read bla irq
  53&nbsp;  read bla dma1
  54&nbsp;  read bla dma2
  55&nbsp; # The "bla's" are labels in the first field: "io," "state," etc.
  56&nbsp; # These are discarded.
  57&nbsp;
  58&nbsp; #  Hack: with PnPBIOS: ports are: port1: WSS, port2:
  59&nbsp; #+ OPL, port3: sb (unneeded)
  60&nbsp; #       with ACPI-PnP:ports are: port1: OPL, port2: sb, port3: WSS
  61&nbsp; #  (ACPI bios seems to be wrong here, the PnP-card-code in snd-cs4236.c
  62&nbsp; #+  uses the PnPBIOS port order)
  63&nbsp; #  Detect port order using the fixed OPL port as reference.
  64&nbsp;  if [ ${port2%%-*} = 0x388 ]
  65&nbsp; #            ^^^^  Strip out everything following hyphen in port address.
  66&nbsp; #                  So, if port1 is 0x530-0x537
  67&nbsp; #+                 we're left with 0x530 -- the start address of the port.
  68&nbsp; then
  69&nbsp;   # PnPBIOS: usual order
  70&nbsp;   port=${port1%%-*}
  71&nbsp;   oplport=${port2%%-*}
  72&nbsp; else
  73&nbsp;   # ACPI: mixed-up order
  74&nbsp;   port=${port3%%-*}
  75&nbsp;   oplport=${port1%%-*}
  76&nbsp; fi
  77&nbsp; } &#60; $WSSDEV/resources
  78&nbsp;# To see what's going on here:
  79&nbsp;# ---------------------------
  80&nbsp;#   cat /sys/devices/pnp0/00:07/resources
  81&nbsp;#
  82&nbsp;#   state = active
  83&nbsp;#   io 0x530-0x537
  84&nbsp;#   io 0x388-0x38b
  85&nbsp;#   io 0x220-0x233
  86&nbsp;#   irq 5
  87&nbsp;#   dma 1
  88&nbsp;#   dma 0
  89&nbsp;#   ^^^   "bla" labels in first field (discarded). 
  90&nbsp;
  91&nbsp;
  92&nbsp;{ read # Discard first line, as above.
  93&nbsp;  read bla port1
  94&nbsp;  cport=${port1%%-*}
  95&nbsp;  #            ^^^^
  96&nbsp;  # Just want _start_ address of port.
  97&nbsp;} &#60; $CTLDEV/resources
  98&nbsp;
  99&nbsp;
 100&nbsp;# Load the module:
 101&nbsp;
 102&nbsp;modprobe --ignore-install snd-cs4236 port=$port cport=$cport\
 103&nbsp;fm_port=$oplport irq=$irq dma1=$dma1 dma2=$dma2 isapnp=0 index=0
 104&nbsp;# See the modprobe manpage.
 105&nbsp;
 106&nbsp;exit $?</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
><A
NAME="FINDSPLIT0"
></A
></P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="FINDSPLIT"
></A
><P
><B
>Example A-37. Locating split paragraphs in a text file</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# find-splitpara.sh
   3&nbsp;#  Finds split paragraphs in a text file,
   4&nbsp;#+ and tags the line numbers.
   5&nbsp;
   6&nbsp;
   7&nbsp;ARGCOUNT=1       # Expect one arg.
   8&nbsp;E_WRONGARGS=65
   9&nbsp;
  10&nbsp;file="$1"        # Target filename.
  11&nbsp;lineno=1         # Line number. Start at 1.
  12&nbsp;Flag=0           # Blank line flag.
  13&nbsp;
  14&nbsp;if [ $# -ne "$ARGCOUNT" ]
  15&nbsp;then
  16&nbsp;  echo "Usage: `basename $0` FILENAME"
  17&nbsp;  exit $E_WRONGARGS
  18&nbsp;fi  
  19&nbsp;
  20&nbsp;file_read ()     # Scan file for pattern, then print line.
  21&nbsp;{
  22&nbsp;while read line
  23&nbsp;do
  24&nbsp;
  25&nbsp;  if [[ "$line" =~ ^[a-z] &#38;&#38; $Flag -eq 1 ]]
  26&nbsp;     then  # Line begins with lc character, following blank line.
  27&nbsp;     echo -n "$lineno::   "
  28&nbsp;     echo "$line"
  29&nbsp;  fi
  30&nbsp;
  31&nbsp;
  32&nbsp;  if [[ "$line" =~ "^$" ]]
  33&nbsp;     then     #  If blank line,
  34&nbsp;     Flag=1   #+ set flag.
  35&nbsp;  else
  36&nbsp;     Flag=0
  37&nbsp;  fi
  38&nbsp;
  39&nbsp;  ((lineno++))
  40&nbsp;
  41&nbsp;done
  42&nbsp;} &#60; $file  # Redirect file into function's stdin.
  43&nbsp;
  44&nbsp;file_read
  45&nbsp;
  46&nbsp;
  47&nbsp;exit $?
  48&nbsp;
  49&nbsp;
  50&nbsp;# ----------------------------------------------------------------
  51&nbsp;This is line one of an example paragraph, bla, bla, bla.
  52&nbsp;This is line two, and line three should follow on next line, but
  53&nbsp;
  54&nbsp;there is a blank line separating the two parts of the paragraph.
  55&nbsp;# ----------------------------------------------------------------
  56&nbsp;
  57&nbsp;Running this script on a file containing the above paragraph
  58&nbsp;yields:
  59&nbsp;
  60&nbsp;4::   there is a blank line separating the two parts of the paragraph.
  61&nbsp;
  62&nbsp;
  63&nbsp;There will be additional output for all the other split paragraphs
  64&nbsp;in the target file.</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
><A
NAME="INSERTIONSORT0"
></A
></P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="INSERTIONSORT"
></A
><P
><B
>Example A-38. Insertion sort</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# insertion-sort.bash: Insertion sort implementation in Bash
   3&nbsp;#                      Heavy use of Bash array features:
   4&nbsp;#+                     (string) slicing, merging, etc
   5&nbsp;# URL: http://www.lugmen.org.ar/~jjo/jjotip/insertion-sort.bash.d
   6&nbsp;#+          /insertion-sort.bash.sh
   7&nbsp;#
   8&nbsp;# Author: JuanJo Ciarlante &#60;jjo@irrigacion.gov.ar&#62;
   9&nbsp;# Lightly reformatted by ABS Guide author.
  10&nbsp;# License: GPLv2
  11&nbsp;# Used in ABS Guide with author's permission (thanks!).
  12&nbsp;#
  13&nbsp;# Test with:   ./insertion-sort.bash -t
  14&nbsp;# Or:          bash insertion-sort.bash -t
  15&nbsp;# The following *doesn't* work:
  16&nbsp;#              sh insertion-sort.bash -t
  17&nbsp;#  Why not? Hint: which Bash-specific features are disabled
  18&nbsp;#+ when running a script by 'sh script.sh'?
  19&nbsp;#
  20&nbsp;: ${DEBUG:=0}  # Debug, override with:  DEBUG=1 ./scriptname . . .
  21&nbsp;# Parameter substitution -- set DEBUG to 0 if not previously set.
  22&nbsp;
  23&nbsp;# Global array: "list"
  24&nbsp;typeset -a list
  25&nbsp;# Load whitespace-separated numbers from stdin.
  26&nbsp;if [ "$1" = "-t" ]; then
  27&nbsp;DEBUG=1
  28&nbsp;        read -a list &#60; &#60;( od -Ad -w24 -t u2 /dev/urandom ) # Random list.
  29&nbsp;#                    ^ ^  process substition
  30&nbsp;else
  31&nbsp;        read -a list
  32&nbsp;fi
  33&nbsp;numelem=${#list[*]}
  34&nbsp;
  35&nbsp;#  Shows the list, marking the element whose index is $1
  36&nbsp;#+ by surrounding it with the two chars passed as $2.
  37&nbsp;#  Whole line prefixed with $3.
  38&nbsp;showlist()
  39&nbsp;  {
  40&nbsp;  echo "$3"${list[@]:0:$1} ${2:0:1}${list[$1]}${2:1:1} ${list[@]:$1+1};
  41&nbsp;  }
  42&nbsp;
  43&nbsp;# Loop _pivot_ -- from second element to end of list.
  44&nbsp;for(( i=1; i&#60;numelem; i++ )) do
  45&nbsp;        ((DEBUG))&#38;&#38;showlist i "[]" " "
  46&nbsp;        # From current _pivot_, back to first element.
  47&nbsp;        for(( j=i; j; j-- )) do
  48&nbsp;                # Search for the 1st elem. less than current "pivot" . . .
  49&nbsp;                [[ "${list[j-1]}" -le "${list[i]}" ]] &#38;&#38; break
  50&nbsp;        done
  51&nbsp;	(( i==j )) &#38;&#38; continue ## No insertion was needed for this element.
  52&nbsp;	# . . . Move list[i] (pivot) to the left of list[j]:
  53&nbsp;        list=(${list[@]:0:j} ${list[i]} ${list[j]}\
  54&nbsp;	#         {0,j-1}        {i}       {j}
  55&nbsp;              ${list[@]:j+1:i-(j+1)} ${list[@]:i+1})
  56&nbsp;	#         {j+1,i-1}              {i+1,last}
  57&nbsp;	((DEBUG))&#38;&#38;showlist j "&#60;&#62;" "*"
  58&nbsp;done
  59&nbsp;
  60&nbsp;
  61&nbsp;echo
  62&nbsp;echo  "------"
  63&nbsp;echo $'Result:\n'${list[@]}
  64&nbsp;
  65&nbsp;exit $?</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="PADSW"
></A
><P
><B
>Example A-39. A <I
CLASS="FIRSTTERM"
>pad</I
> file generator for shareware
        authors</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# pad.sh
   3&nbsp;
   4&nbsp;######################################################
   5&nbsp;#               PAD (xml) file creator
   6&nbsp;#+ Written by Mendel Cooper &#60;thegrendel@theriver.com&#62;.
   7&nbsp;#+ Released to the Public Domain.
   8&nbsp;#
   9&nbsp;#  Generates a "PAD" descriptor file for shareware
  10&nbsp;#+ packages, according to the specifications
  11&nbsp;#+ of the ASP.
  12&nbsp;#  http://www.asp-shareware.org/pad
  13&nbsp;######################################################
  14&nbsp;
  15&nbsp;
  16&nbsp;# Accepts (optional) save filename as a command-line argument.
  17&nbsp;if [ -n "$1" ]
  18&nbsp;then
  19&nbsp;  savefile=$1
  20&nbsp;else
  21&nbsp;  savefile=save_file.xml               # Default save_file name.
  22&nbsp;fi  
  23&nbsp;
  24&nbsp;
  25&nbsp;# ===== PAD file headers =====
  26&nbsp;HDR1="&#60;?xml version=\"1.0\" encoding=\"Windows-1252\" ?&#62;"
  27&nbsp;HDR2="&#60;XML_DIZ_INFO&#62;"
  28&nbsp;HDR3="&#60;MASTER_PAD_VERSION_INFO&#62;"
  29&nbsp;HDR4="\t&#60;MASTER_PAD_VERSION&#62;1.15&#60;/MASTER_PAD_VERSION&#62;"
  30&nbsp;HDR5="\t&#60;MASTER_PAD_INFO&#62;Portable Application Description, or PAD
  31&nbsp;for short, is a data set that is used by shareware authors to
  32&nbsp;disseminate information to anyone interested in their software products.
  33&nbsp;To find out more go to http://www.asp-shareware.org/pad&#60;/MASTER_PAD_INFO&#62;"
  34&nbsp;HDR6="&#60;/MASTER_PAD_VERSION_INFO&#62;"
  35&nbsp;# ============================
  36&nbsp;
  37&nbsp;
  38&nbsp;fill_in ()
  39&nbsp;{
  40&nbsp;  if [ -z "$2" ]
  41&nbsp;  then
  42&nbsp;    echo -n "$1? "     # Get user input.
  43&nbsp;  else
  44&nbsp;    echo -n "$1 $2? "  # Additional query?
  45&nbsp;  fi  
  46&nbsp;
  47&nbsp;  read var             # May paste to fill in field.
  48&nbsp;                       # This shows how flexible "read" can be.
  49&nbsp;
  50&nbsp;  if [ -z "$var" ]
  51&nbsp;  then
  52&nbsp;    echo -e "\t\t&#60;$1 /&#62;" &#62;&#62;$savefile    # Indent with 2 tabs.
  53&nbsp;    return
  54&nbsp;  else
  55&nbsp;    echo -e "\t\t&#60;$1&#62;$var&#60;/$1&#62;" &#62;&#62;$savefile
  56&nbsp;    return ${#var}     # Return length of input string.
  57&nbsp;  fi
  58&nbsp;}    
  59&nbsp;
  60&nbsp;check_field_length ()  # Check length of program description fields.
  61&nbsp;{
  62&nbsp;  # $1 = maximum field length
  63&nbsp;  # $2 = actual field length
  64&nbsp;  if [ "$2" -gt "$1" ]
  65&nbsp;  then
  66&nbsp;    echo "Warning: Maximum field length of $1 characters exceeded!"
  67&nbsp;  fi
  68&nbsp;}  
  69&nbsp;
  70&nbsp;clear                  # Clear screen.
  71&nbsp;echo "PAD File Creator"
  72&nbsp;echo "--- ---- -------"
  73&nbsp;echo
  74&nbsp;
  75&nbsp;# Write File Headers to file.
  76&nbsp;echo $HDR1 &#62;$savefile
  77&nbsp;echo $HDR2 &#62;&#62;$savefile
  78&nbsp;echo $HDR3 &#62;&#62;$savefile
  79&nbsp;echo -e $HDR4 &#62;&#62;$savefile
  80&nbsp;echo -e $HDR5 &#62;&#62;$savefile
  81&nbsp;echo $HDR6 &#62;&#62;$savefile
  82&nbsp;
  83&nbsp;
  84&nbsp;# Company_Info
  85&nbsp;echo "COMPANY INFO"
  86&nbsp;CO_HDR="Company_Info"
  87&nbsp;echo "&#60;$CO_HDR&#62;" &#62;&#62;$savefile
  88&nbsp;
  89&nbsp;fill_in Company_Name
  90&nbsp;fill_in Address_1
  91&nbsp;fill_in Address_2
  92&nbsp;fill_in City_Town 
  93&nbsp;fill_in State_Province
  94&nbsp;fill_in Zip_Postal_Code
  95&nbsp;fill_in Country
  96&nbsp;
  97&nbsp;# If applicable:
  98&nbsp;# fill_in ASP_Member "[Y/N]"
  99&nbsp;# fill_in ASP_Member_Number
 100&nbsp;# fill_in ESC_Member "[Y/N]"
 101&nbsp;
 102&nbsp;fill_in Company_WebSite_URL
 103&nbsp;
 104&nbsp;clear   # Clear screen between sections.
 105&nbsp;
 106&nbsp;   # Contact_Info
 107&nbsp;echo "CONTACT INFO"
 108&nbsp;CONTACT_HDR="Contact_Info"
 109&nbsp;echo "&#60;$CONTACT_HDR&#62;" &#62;&#62;$savefile
 110&nbsp;fill_in Author_First_Name
 111&nbsp;fill_in Author_Last_Name
 112&nbsp;fill_in Author_Email
 113&nbsp;fill_in Contact_First_Name
 114&nbsp;fill_in Contact_Last_Name
 115&nbsp;fill_in Contact_Email
 116&nbsp;echo -e "\t&#60;/$CONTACT_HDR&#62;" &#62;&#62;$savefile
 117&nbsp;   # END Contact_Info
 118&nbsp;
 119&nbsp;clear
 120&nbsp;
 121&nbsp;   # Support_Info
 122&nbsp;echo "SUPPORT INFO"
 123&nbsp;SUPPORT_HDR="Support_Info"
 124&nbsp;echo "&#60;$SUPPORT_HDR&#62;" &#62;&#62;$savefile
 125&nbsp;fill_in Sales_Email
 126&nbsp;fill_in Support_Email
 127&nbsp;fill_in General_Email
 128&nbsp;fill_in Sales_Phone
 129&nbsp;fill_in Support_Phone
 130&nbsp;fill_in General_Phone
 131&nbsp;fill_in Fax_Phone
 132&nbsp;echo -e "\t&#60;/$SUPPORT_HDR&#62;" &#62;&#62;$savefile
 133&nbsp;   # END Support_Info
 134&nbsp;
 135&nbsp;echo "&#60;/$CO_HDR&#62;" &#62;&#62;$savefile
 136&nbsp;# END Company_Info
 137&nbsp;
 138&nbsp;clear
 139&nbsp;
 140&nbsp;# Program_Info 
 141&nbsp;echo "PROGRAM INFO"
 142&nbsp;PROGRAM_HDR="Program_Info"
 143&nbsp;echo "&#60;$PROGRAM_HDR&#62;" &#62;&#62;$savefile
 144&nbsp;fill_in Program_Name
 145&nbsp;fill_in Program_Version
 146&nbsp;fill_in Program_Release_Month
 147&nbsp;fill_in Program_Release_Day
 148&nbsp;fill_in Program_Release_Year
 149&nbsp;fill_in Program_Cost_Dollars
 150&nbsp;fill_in Program_Cost_Other
 151&nbsp;fill_in Program_Type "[Shareware/Freeware/GPL]"
 152&nbsp;fill_in Program_Release_Status "[Beta, Major Upgrade, etc.]"
 153&nbsp;fill_in Program_Install_Support
 154&nbsp;fill_in Program_OS_Support "[Win9x/Win2k/Linux/etc.]"
 155&nbsp;fill_in Program_Language "[English/Spanish/etc.]"
 156&nbsp;
 157&nbsp;echo; echo
 158&nbsp;
 159&nbsp;  # File_Info 
 160&nbsp;echo "FILE INFO"
 161&nbsp;FILEINFO_HDR="File_Info"
 162&nbsp;echo "&#60;$FILEINFO_HDR&#62;" &#62;&#62;$savefile
 163&nbsp;fill_in Filename_Versioned
 164&nbsp;fill_in Filename_Previous
 165&nbsp;fill_in Filename_Generic
 166&nbsp;fill_in Filename_Long
 167&nbsp;fill_in File_Size_Bytes
 168&nbsp;fill_in File_Size_K
 169&nbsp;fill_in File_Size_MB
 170&nbsp;echo -e "\t&#60;/$FILEINFO_HDR&#62;" &#62;&#62;$savefile
 171&nbsp;  # END File_Info 
 172&nbsp;
 173&nbsp;clear
 174&nbsp;
 175&nbsp;  # Expire_Info 
 176&nbsp;echo "EXPIRE INFO"
 177&nbsp;EXPIRE_HDR="Expire_Info"
 178&nbsp;echo "&#60;$EXPIRE_HDR&#62;" &#62;&#62;$savefile
 179&nbsp;fill_in Has_Expire_Info "Y/N"
 180&nbsp;fill_in Expire_Count
 181&nbsp;fill_in Expire_Based_On
 182&nbsp;fill_in Expire_Other_Info
 183&nbsp;fill_in Expire_Month
 184&nbsp;fill_in Expire_Day
 185&nbsp;fill_in Expire_Year
 186&nbsp;echo -e "\t&#60;/$EXPIRE_HDR&#62;" &#62;&#62;$savefile
 187&nbsp;  # END Expire_Info 
 188&nbsp;
 189&nbsp;clear
 190&nbsp;
 191&nbsp;  # More Program_Info
 192&nbsp;echo "ADDITIONAL PROGRAM INFO"
 193&nbsp;fill_in Program_Change_Info
 194&nbsp;fill_in Program_Specific_Category
 195&nbsp;fill_in Program_Categories
 196&nbsp;fill_in Includes_JAVA_VM "[Y/N]"
 197&nbsp;fill_in Includes_VB_Runtime "[Y/N]"
 198&nbsp;fill_in Includes_DirectX "[Y/N]"
 199&nbsp;  # END More Program_Info
 200&nbsp;
 201&nbsp;echo "&#60;/$PROGRAM_HDR&#62;" &#62;&#62;$savefile
 202&nbsp;# END Program_Info 
 203&nbsp;
 204&nbsp;clear
 205&nbsp;
 206&nbsp;# Program Description
 207&nbsp;echo "PROGRAM DESCRIPTIONS"
 208&nbsp;PROGDESC_HDR="Program_Descriptions"
 209&nbsp;echo "&#60;$PROGDESC_HDR&#62;" &#62;&#62;$savefile
 210&nbsp;
 211&nbsp;LANG="English"
 212&nbsp;echo "&#60;$LANG&#62;" &#62;&#62;$savefile
 213&nbsp;
 214&nbsp;fill_in Keywords "[comma + space separated]"
 215&nbsp;echo
 216&nbsp;echo "45, 80, 250, 450, 2000 word program descriptions"
 217&nbsp;echo "(may cut and paste into field)"
 218&nbsp;#  It would be highly appropriate to compose the following
 219&nbsp;#+ "Char_Desc" fields with a text editor,
 220&nbsp;#+ then cut-and-paste the text into the answer fields.
 221&nbsp;echo
 222&nbsp;echo "              |---------------45 characters---------------|"
 223&nbsp;fill_in Char_Desc_45
 224&nbsp;check_field_length 45 "$?"
 225&nbsp;echo
 226&nbsp;fill_in Char_Desc_80
 227&nbsp;check_field_length 80 "$?"
 228&nbsp;
 229&nbsp;fill_in Char_Desc_250
 230&nbsp;check_field_length 250 "$?"
 231&nbsp;
 232&nbsp;fill_in Char_Desc_450
 233&nbsp;fill_in Char_Desc_2000
 234&nbsp;
 235&nbsp;echo "&#60;/$LANG&#62;" &#62;&#62;$savefile
 236&nbsp;echo "&#60;/$PROGDESC_HDR&#62;" &#62;&#62;$savefile
 237&nbsp;# END Program Description
 238&nbsp;
 239&nbsp;clear
 240&nbsp;echo "Done."; echo; echo
 241&nbsp;echo "Save file is:  \""$savefile"\""
 242&nbsp;
 243&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="HOMEWORK"
></A
><P
><B
>Example A-40. An all-purpose shell scripting homework assignment solution</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# homework.sh: All-purpose homework assignment solution.
   3&nbsp;#  Author: M. Leo Cooper
   4&nbsp;#  If you substitute your own name as author, then it is plagiarism,
   5&nbsp;#+ possibly a lesser sin than cheating on your homework!
   6&nbsp;#  License: Public Domain
   7&nbsp;
   8&nbsp;#  This script may be turned in to your instructor
   9&nbsp;#+ in fulfillment of ALL Bash scripting homework assignments.
  10&nbsp;#  It's sparsely commented, but you, the student, can easily remedy that.
  11&nbsp;#  The script author repudiates all responsibility!
  12&nbsp;
  13&nbsp;DLA=1
  14&nbsp;P1=2
  15&nbsp;P2=4
  16&nbsp;P3=7
  17&nbsp;PP1=0
  18&nbsp;PP2=8
  19&nbsp;MAXL=9
  20&nbsp;E_LZY=99
  21&nbsp;
  22&nbsp;declare -a L
  23&nbsp;L[0]="3 4 0 17 29 8 13 18 19 17 20 2 19 14 17 28"
  24&nbsp;L[1]="8 29 12 14 18 19 29 4 12 15 7 0 19 8 2 0 11 11 24 29 17 4 6 17 4 19"
  25&nbsp;L[2]="29 19 7 0 19 29 8 29 7 0 21 4 29 13 4 6 11 4 2 19 4 3"
  26&nbsp;L[3]="19 14 29 2 14 12 15 11 4 19 4 29 19 7 8 18 29"
  27&nbsp;L[4]="18 2 7 14 14 11 22 14 17 10 29 0 18 18 8 6 13 12 4 13 19 26"
  28&nbsp;L[5]="15 11 4 0 18 4 29 0 2 2 4 15 19 29 12 24 29 7 20 12 1 11 4 29"
  29&nbsp;L[6]="4 23 2 20 18 4 29 14 5 29 4 6 17 4 6 8 14 20 18 29"
  30&nbsp;L[7]="11 0 25 8 13 4 18 18 27"
  31&nbsp;L[8]="0 13 3 29 6 17 0 3 4 29 12 4 29 0 2 2 14 17 3 8 13 6 11 24 26"
  32&nbsp;L[9]="19 7 0 13 10 29 24 14 20 26"
  33&nbsp;
  34&nbsp;declare -a \
  35&nbsp;alph=( A B C D E F G H I J K L M N O P Q R S T U V W X Y Z . , : ' ' )
  36&nbsp;
  37&nbsp;
  38&nbsp;pt_lt ()
  39&nbsp;{
  40&nbsp;  echo -n "${alph[$1]}"
  41&nbsp;  echo -n -e "\a"
  42&nbsp;  sleep $DLA
  43&nbsp;}
  44&nbsp;
  45&nbsp;b_r ()
  46&nbsp;{
  47&nbsp; echo -e '\E[31;48m\033[1m'
  48&nbsp;}
  49&nbsp;
  50&nbsp;cr ()
  51&nbsp;{
  52&nbsp; echo -e "\a"
  53&nbsp; sleep $DLA
  54&nbsp;}
  55&nbsp;
  56&nbsp;restore ()
  57&nbsp;{
  58&nbsp;  echo -e '\033[0m'            # Bold off.
  59&nbsp;  tput sgr0                    # Normal.
  60&nbsp;}
  61&nbsp;
  62&nbsp;
  63&nbsp;p_l ()
  64&nbsp;{
  65&nbsp;  for ltr in $1
  66&nbsp;  do
  67&nbsp;    pt_lt "$ltr"
  68&nbsp;  done
  69&nbsp;}
  70&nbsp;
  71&nbsp;# ----------------------
  72&nbsp;b_r
  73&nbsp;
  74&nbsp;for i in $(seq 0 $MAXL)
  75&nbsp;do
  76&nbsp; p_l "${L[i]}"
  77&nbsp; if [[ "$i" -eq "$P1" || "$i" -eq "$P2" || "$i" -eq "$P3" ]]
  78&nbsp; then
  79&nbsp;   cr
  80&nbsp;   elif [[ "$i" -eq "$PP1" || "$i" -eq "$PP2" ]]
  81&nbsp;   then
  82&nbsp;     cr; cr
  83&nbsp;fi
  84&nbsp;done
  85&nbsp;
  86&nbsp;restore
  87&nbsp;# ----------------------
  88&nbsp;
  89&nbsp;echo
  90&nbsp;
  91&nbsp;exit $E_LZY
  92&nbsp;
  93&nbsp;#  An example of an obfuscated script that is difficult to understand,
  94&nbsp;#+ and frustrating to maintain.
  95&nbsp;#  In your career as a sysadmin, you'll run into these all too often.</PRE
></TD
></TR
></TABLE
><HR></DIV
><P
><A
NAME="BASICSREV0"
></A
>To end this section, a review of the
      basics . . . and more.</P
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="BASICSREVIEWED"
></A
><P
><B
>Example A-41. Basics Reviewed</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# basics-reviewed.bash
   3&nbsp;
   4&nbsp;# File extension == *.bash == specific to Bash
   5&nbsp;
   6&nbsp;#   Copyright (c) Michael S. Zick, 2003; All rights reserved.
   7&nbsp;#   License: Use in any form, for any purpose.
   8&nbsp;#   Revision: $ID$
   9&nbsp;#
  10&nbsp;#              Edited for layout by M.C.
  11&nbsp;#   (author of the "Advanced Bash Scripting Guide")
  12&nbsp;
  13&nbsp;
  14&nbsp;#  This script tested under Bash versions 2.04, 2.05a and 2.05b.
  15&nbsp;#  It may not work with earlier versions.
  16&nbsp;#  This demonstration script generates one --intentional--
  17&nbsp;#+ "command not found" error message. See line 394.
  18&nbsp;
  19&nbsp;#  The current Bash maintainer, Chet Ramey, has fixed the items noted
  20&nbsp;#+ for an upcoming version of Bash.
  21&nbsp;
  22&nbsp;
  23&nbsp;
  24&nbsp;        ###-------------------------------------------###
  25&nbsp;        ###  Pipe the output of this script to 'more' ###
  26&nbsp;        ###+ else it will scroll off the page.        ###
  27&nbsp;        ###                                           ###
  28&nbsp;        ###  You may also redirect its output         ###
  29&nbsp;        ###+ to a file for examination.               ###  
  30&nbsp;        ###-------------------------------------------###
  31&nbsp;
  32&nbsp;
  33&nbsp;
  34&nbsp;#  Most of the following points are described at length in
  35&nbsp;#+ the text of the foregoing "Advanced Bash Scripting Guide."
  36&nbsp;#  This demonstration script is mostly just a reorganized presentation.
  37&nbsp;#      -- msz
  38&nbsp;
  39&nbsp;# Variables are not typed unless otherwise specified.
  40&nbsp;
  41&nbsp;#  Variables are named. Names must contain a non-digit.
  42&nbsp;#  File descriptor names (as in, for example: 2&#62;&#38;1)
  43&nbsp;#+ contain ONLY digits.
  44&nbsp;
  45&nbsp;# Parameters and Bash array elements are numbered.
  46&nbsp;# (Parameters are very similar to Bash arrays.)
  47&nbsp;
  48&nbsp;# A variable name may be undefined (null reference).
  49&nbsp;unset VarNull
  50&nbsp;
  51&nbsp;# A variable name may be defined but empty (null contents).
  52&nbsp;VarEmpty=''                         # Two, adjacent, single quotes.
  53&nbsp;
  54&nbsp;# A variable name my be defined and non-empty
  55&nbsp;VarSomething='Literal'
  56&nbsp;
  57&nbsp;# A variable may contain:
  58&nbsp;#   * A whole number as a signed 32-bit (or larger) integer
  59&nbsp;#   * A string
  60&nbsp;# A variable may also be an array.
  61&nbsp;
  62&nbsp;#  A string may contain embedded blanks and may be treated
  63&nbsp;#+ as if it where a function name with optional arguments.
  64&nbsp;
  65&nbsp;#  The names of variables and the names of functions
  66&nbsp;#+ are in different namespaces.
  67&nbsp;
  68&nbsp;
  69&nbsp;#  A variable may be defined as a Bash array either explicitly or
  70&nbsp;#+ implicitly by the syntax of the assignment statement.
  71&nbsp;#  Explicit:
  72&nbsp;declare -a ArrayVar
  73&nbsp;
  74&nbsp;
  75&nbsp;
  76&nbsp;# The echo command is a built-in.
  77&nbsp;echo $VarSomething
  78&nbsp;
  79&nbsp;# The printf command is a built-in.
  80&nbsp;# Translate %s as: String-Format
  81&nbsp;printf %s $VarSomething         # No linebreak specified, none output.
  82&nbsp;echo                            # Default, only linebreak output.
  83&nbsp;
  84&nbsp;
  85&nbsp;
  86&nbsp;
  87&nbsp;# The Bash parser word breaks on whitespace.
  88&nbsp;# Whitespace, or the lack of it is significant.
  89&nbsp;# (This holds true in general; there are, of course, exceptions.)
  90&nbsp;
  91&nbsp;
  92&nbsp;
  93&nbsp;
  94&nbsp;# Translate the DOLLAR_SIGN character as: Content-Of.
  95&nbsp;
  96&nbsp;# Extended-Syntax way of writing Content-Of:
  97&nbsp;echo ${VarSomething}
  98&nbsp;
  99&nbsp;#  The ${ ... } Extended-Syntax allows more than just the variable
 100&nbsp;#+ name to be specified.
 101&nbsp;#  In general, $VarSomething can always be written as: ${VarSomething}.
 102&nbsp;
 103&nbsp;# Call this script with arguments to see the following in action.
 104&nbsp;
 105&nbsp;
 106&nbsp;
 107&nbsp;#  Outside of double-quotes, the special characters @ and *
 108&nbsp;#+ specify identical behavior.
 109&nbsp;#  May be pronounced as: All-Elements-Of.
 110&nbsp;
 111&nbsp;#  Without specification of a name, they refer to the
 112&nbsp;#+ pre-defined parameter Bash-Array.
 113&nbsp;
 114&nbsp;
 115&nbsp;
 116&nbsp;# Glob-Pattern references
 117&nbsp;echo $*                         # All parameters to script or function
 118&nbsp;echo ${*}                       # Same
 119&nbsp;
 120&nbsp;# Bash disables filename expansion for Glob-Patterns.
 121&nbsp;# Only character matching is active.
 122&nbsp;
 123&nbsp;
 124&nbsp;# All-Elements-Of references
 125&nbsp;echo $@                         # Same as above
 126&nbsp;echo ${@}                       # Same as above
 127&nbsp;
 128&nbsp;
 129&nbsp;
 130&nbsp;
 131&nbsp;#  Within double-quotes, the behavior of Glob-Pattern references
 132&nbsp;#+ depends on the setting of IFS (Input Field Separator).
 133&nbsp;#  Within double-quotes, All-Elements-Of references behave the same.
 134&nbsp;
 135&nbsp;
 136&nbsp;#  Specifying only the name of a variable holding a string refers
 137&nbsp;#+ to all elements (characters) of a string.
 138&nbsp;
 139&nbsp;
 140&nbsp;#  To specify an element (character) of a string,
 141&nbsp;#+ the Extended-Syntax reference notation (see below) MAY be used.
 142&nbsp;
 143&nbsp;
 144&nbsp;
 145&nbsp;
 146&nbsp;#  Specifying only the name of a Bash array references
 147&nbsp;#+ the subscript zero element,
 148&nbsp;#+ NOT the FIRST DEFINED nor the FIRST WITH CONTENTS element.
 149&nbsp;
 150&nbsp;#  Additional qualification is needed to reference other elements,
 151&nbsp;#+ which means that the reference MUST be written in Extended-Syntax.
 152&nbsp;#  The general form is: ${name[subscript]}.
 153&nbsp;
 154&nbsp;#  The string forms may also be used: ${name:subscript}
 155&nbsp;#+ for Bash-Arrays when referencing the subscript zero element.
 156&nbsp;
 157&nbsp;
 158&nbsp;# Bash-Arrays are implemented internally as linked lists,
 159&nbsp;#+ not as a fixed area of storage as in some programming languages.
 160&nbsp;
 161&nbsp;
 162&nbsp;#   Characteristics of Bash arrays (Bash-Arrays):
 163&nbsp;#   --------------------------------------------
 164&nbsp;
 165&nbsp;#   If not otherwise specified, Bash-Array subscripts begin with
 166&nbsp;#+  subscript number zero. Literally: [0]
 167&nbsp;#   This is called zero-based indexing.
 168&nbsp;###
 169&nbsp;#   If not otherwise specified, Bash-Arrays are subscript packed
 170&nbsp;#+  (sequential subscripts without subscript gaps).
 171&nbsp;###
 172&nbsp;#   Negative subscripts are not allowed.
 173&nbsp;###
 174&nbsp;#   Elements of a Bash-Array need not all be of the same type.
 175&nbsp;###
 176&nbsp;#   Elements of a Bash-Array may be undefined (null reference).
 177&nbsp;#       That is, a Bash-Array my be "subscript sparse."
 178&nbsp;###
 179&nbsp;#   Elements of a Bash-Array may be defined and empty (null contents).
 180&nbsp;###
 181&nbsp;#   Elements of a Bash-Array may contain:
 182&nbsp;#     * A whole number as a signed 32-bit (or larger) integer
 183&nbsp;#     * A string
 184&nbsp;#     * A string formated so that it appears to be a function name
 185&nbsp;#     + with optional arguments
 186&nbsp;###
 187&nbsp;#   Defined elements of a Bash-Array may be undefined (unset).
 188&nbsp;#       That is, a subscript packed Bash-Array may be changed
 189&nbsp;#   +   into a subscript sparse Bash-Array.
 190&nbsp;###
 191&nbsp;#   Elements may be added to a Bash-Array by defining an element
 192&nbsp;#+  not previously defined.
 193&nbsp;###
 194&nbsp;# For these reasons, I have been calling them "Bash-Arrays".
 195&nbsp;# I'll return to the generic term "array" from now on.
 196&nbsp;#     -- msz
 197&nbsp;
 198&nbsp;
 199&nbsp;
 200&nbsp;
 201&nbsp;#  Demo time -- initialize the previously declared ArrayVar as a
 202&nbsp;#+ sparse array.
 203&nbsp;#  (The 'unset ... ' is just documentation here.)
 204&nbsp;
 205&nbsp;unset ArrayVar[0]                   # Just for the record
 206&nbsp;ArrayVar[1]=one                     # Unquoted literal
 207&nbsp;ArrayVar[2]=''                      # Defined, and empty
 208&nbsp;unset ArrayVar[3]                   # Just for the record
 209&nbsp;ArrayVar[4]='four'                  # Quoted literal
 210&nbsp;
 211&nbsp;
 212&nbsp;
 213&nbsp;# Translate the %q format as: Quoted-Respecting-IFS-Rules.
 214&nbsp;echo
 215&nbsp;echo '- - Outside of double-quotes - -'
 216&nbsp;###
 217&nbsp;printf %q ${ArrayVar[*]}            # Glob-Pattern All-Elements-Of
 218&nbsp;echo
 219&nbsp;echo 'echo command:'${ArrayVar[*]}
 220&nbsp;###
 221&nbsp;printf %q ${ArrayVar[@]}            # All-Elements-Of
 222&nbsp;echo
 223&nbsp;echo 'echo command:'${ArrayVar[@]}
 224&nbsp;
 225&nbsp;# The use of double-quotes may be translated as: Enable-Substitution.
 226&nbsp;
 227&nbsp;# There are five cases recognized for the IFS setting.
 228&nbsp;
 229&nbsp;echo
 230&nbsp;echo '- - Within double-quotes - Default IFS of space-tab-newline - -'
 231&nbsp;IFS=$'\x20'$'\x09'$'\x0A'           #  These three bytes,
 232&nbsp;                                    #+ in exactly this order.
 233&nbsp;
 234&nbsp;
 235&nbsp;printf %q "${ArrayVar[*]}"          # Glob-Pattern All-Elements-Of
 236&nbsp;echo
 237&nbsp;echo 'echo command:'"${ArrayVar[*]}"
 238&nbsp;###
 239&nbsp;printf %q "${ArrayVar[@]}"          # All-Elements-Of
 240&nbsp;echo
 241&nbsp;echo 'echo command:'"${ArrayVar[@]}"
 242&nbsp;
 243&nbsp;
 244&nbsp;echo
 245&nbsp;echo '- - Within double-quotes - First character of IFS is ^ - -'
 246&nbsp;# Any printing, non-whitespace character should do the same.
 247&nbsp;IFS='^'$IFS                         # ^ + space tab newline
 248&nbsp;###
 249&nbsp;printf %q "${ArrayVar[*]}"          # Glob-Pattern All-Elements-Of
 250&nbsp;echo
 251&nbsp;echo 'echo command:'"${ArrayVar[*]}"
 252&nbsp;###
 253&nbsp;printf %q "${ArrayVar[@]}"          # All-Elements-Of
 254&nbsp;echo
 255&nbsp;echo 'echo command:'"${ArrayVar[@]}"
 256&nbsp;
 257&nbsp;
 258&nbsp;echo
 259&nbsp;echo '- - Within double-quotes - Without whitespace in IFS - -'
 260&nbsp;IFS='^:%!'
 261&nbsp;###
 262&nbsp;printf %q "${ArrayVar[*]}"          # Glob-Pattern All-Elements-Of
 263&nbsp;echo
 264&nbsp;echo 'echo command:'"${ArrayVar[*]}"
 265&nbsp;###
 266&nbsp;printf %q "${ArrayVar[@]}"          # All-Elements-Of
 267&nbsp;echo
 268&nbsp;echo 'echo command:'"${ArrayVar[@]}"
 269&nbsp;
 270&nbsp;
 271&nbsp;echo
 272&nbsp;echo '- - Within double-quotes - IFS set and empty - -'
 273&nbsp;IFS=''
 274&nbsp;###
 275&nbsp;printf %q "${ArrayVar[*]}"          # Glob-Pattern All-Elements-Of
 276&nbsp;echo
 277&nbsp;echo 'echo command:'"${ArrayVar[*]}"
 278&nbsp;###
 279&nbsp;printf %q "${ArrayVar[@]}"          # All-Elements-Of
 280&nbsp;echo
 281&nbsp;echo 'echo command:'"${ArrayVar[@]}"
 282&nbsp;
 283&nbsp;
 284&nbsp;echo
 285&nbsp;echo '- - Within double-quotes - IFS undefined - -'
 286&nbsp;unset IFS
 287&nbsp;###
 288&nbsp;printf %q "${ArrayVar[*]}"          # Glob-Pattern All-Elements-Of
 289&nbsp;echo
 290&nbsp;echo 'echo command:'"${ArrayVar[*]}"
 291&nbsp;###
 292&nbsp;printf %q "${ArrayVar[@]}"          # All-Elements-Of
 293&nbsp;echo
 294&nbsp;echo 'echo command:'"${ArrayVar[@]}"
 295&nbsp;
 296&nbsp;
 297&nbsp;# Put IFS back to the default.
 298&nbsp;# Default is exactly these three bytes.
 299&nbsp;IFS=$'\x20'$'\x09'$'\x0A'           # In exactly this order.
 300&nbsp;
 301&nbsp;# Interpretation of the above outputs:
 302&nbsp;#   A Glob-Pattern is I/O; the setting of IFS matters.
 303&nbsp;###
 304&nbsp;#   An All-Elements-Of does not consider IFS settings.
 305&nbsp;###
 306&nbsp;#   Note the different output using the echo command and the
 307&nbsp;#+  quoted format operator of the printf command.
 308&nbsp;
 309&nbsp;
 310&nbsp;#  Recall:
 311&nbsp;#   Parameters are similar to arrays and have the similar behaviors.
 312&nbsp;###
 313&nbsp;#  The above examples demonstrate the possible variations.
 314&nbsp;#  To retain the shape of a sparse array, additional script
 315&nbsp;#+ programming is required.
 316&nbsp;###
 317&nbsp;#  The source code of Bash has a routine to output the
 318&nbsp;#+ [subscript]=value   array assignment format.
 319&nbsp;#  As of version 2.05b, that routine is not used,
 320&nbsp;#+ but that might change in future releases.
 321&nbsp;
 322&nbsp;
 323&nbsp;
 324&nbsp;# The length of a string, measured in non-null elements (characters):
 325&nbsp;echo
 326&nbsp;echo '- - Non-quoted references - -'
 327&nbsp;echo 'Non-Null character count: '${#VarSomething}' characters.'
 328&nbsp;
 329&nbsp;# test='Lit'$'\x00''eral'           # $'\x00' is a null character.
 330&nbsp;# echo ${#test}                     # See that?
 331&nbsp;
 332&nbsp;
 333&nbsp;
 334&nbsp;#  The length of an array, measured in defined elements,
 335&nbsp;#+ including null content elements.
 336&nbsp;echo
 337&nbsp;echo 'Defined content count: '${#ArrayVar[@]}' elements.'
 338&nbsp;# That is NOT the maximum subscript (4).
 339&nbsp;# That is NOT the range of the subscripts (1 . . 4 inclusive).
 340&nbsp;# It IS the length of the linked list.
 341&nbsp;###
 342&nbsp;#  Both the maximum subscript and the range of the subscripts may
 343&nbsp;#+ be found with additional script programming.
 344&nbsp;
 345&nbsp;# The length of a string, measured in non-null elements (characters):
 346&nbsp;echo
 347&nbsp;echo '- - Quoted, Glob-Pattern references - -'
 348&nbsp;echo 'Non-Null character count: '"${#VarSomething}"' characters.'
 349&nbsp;
 350&nbsp;#  The length of an array, measured in defined elements,
 351&nbsp;#+ including null-content elements.
 352&nbsp;echo
 353&nbsp;echo 'Defined element count: '"${#ArrayVar[*]}"' elements.'
 354&nbsp;
 355&nbsp;#  Interpretation: Substitution does not effect the ${# ... } operation.
 356&nbsp;#  Suggestion:
 357&nbsp;#  Always use the All-Elements-Of character
 358&nbsp;#+ if that is what is intended (independence from IFS).
 359&nbsp;
 360&nbsp;
 361&nbsp;
 362&nbsp;#  Define a simple function.
 363&nbsp;#  I include an underscore in the name
 364&nbsp;#+ to make it distinctive in the examples below.
 365&nbsp;###
 366&nbsp;#  Bash separates variable names and function names
 367&nbsp;#+ in different namespaces.
 368&nbsp;#  The Mark-One eyeball isn't that advanced.
 369&nbsp;###
 370&nbsp;_simple() {
 371&nbsp;    echo -n 'SimpleFunc'$@          #  Newlines are swallowed in
 372&nbsp;}                                   #+ result returned in any case.
 373&nbsp;
 374&nbsp;
 375&nbsp;# The ( ... ) notation invokes a command or function.
 376&nbsp;# The $( ... ) notation is pronounced: Result-Of.
 377&nbsp;
 378&nbsp;
 379&nbsp;# Invoke the function _simple
 380&nbsp;echo
 381&nbsp;echo '- - Output of function _simple - -'
 382&nbsp;_simple                             # Try passing arguments.
 383&nbsp;echo
 384&nbsp;# or
 385&nbsp;(_simple)                           # Try passing arguments.
 386&nbsp;echo
 387&nbsp;
 388&nbsp;echo '- Is there a variable of that name? -'
 389&nbsp;echo $_simple not defined           # No variable by that name.
 390&nbsp;
 391&nbsp;# Invoke the result of function _simple (Error msg intended)
 392&nbsp;
 393&nbsp;###
 394&nbsp;$(_simple)                          # Gives an error message:
 395&nbsp;#                          line 394: SimpleFunc: command not found
 396&nbsp;#                          ---------------------------------------
 397&nbsp;
 398&nbsp;echo
 399&nbsp;###
 400&nbsp;
 401&nbsp;#  The first word of the result of function _simple
 402&nbsp;#+ is neither a valid Bash command nor the name of a defined function.
 403&nbsp;###
 404&nbsp;# This demonstrates that the output of _simple is subject to evaluation.
 405&nbsp;###
 406&nbsp;# Interpretation:
 407&nbsp;#   A function can be used to generate in-line Bash commands.
 408&nbsp;
 409&nbsp;
 410&nbsp;# A simple function where the first word of result IS a bash command:
 411&nbsp;###
 412&nbsp;_print() {
 413&nbsp;    echo -n 'printf %q '$@
 414&nbsp;}
 415&nbsp;
 416&nbsp;echo '- - Outputs of function _print - -'
 417&nbsp;_print parm1 parm2                  # An Output NOT A Command.
 418&nbsp;echo
 419&nbsp;
 420&nbsp;$(_print parm1 parm2)               #  Executes: printf %q parm1 parm2
 421&nbsp;                                    #  See above IFS examples for the
 422&nbsp;                                    #+ various possibilities.
 423&nbsp;echo
 424&nbsp;
 425&nbsp;$(_print $VarSomething)             # The predictable result.
 426&nbsp;echo
 427&nbsp;
 428&nbsp;
 429&nbsp;
 430&nbsp;# Function variables
 431&nbsp;# ------------------
 432&nbsp;
 433&nbsp;echo
 434&nbsp;echo '- - Function variables - -'
 435&nbsp;# A variable may represent a signed integer, a string or an array.
 436&nbsp;# A string may be used like a function name with optional arguments.
 437&nbsp;
 438&nbsp;# set -vx                           #  Enable if desired
 439&nbsp;declare -f funcVar                  #+ in namespace of functions
 440&nbsp;
 441&nbsp;funcVar=_print                      # Contains name of function.
 442&nbsp;$funcVar parm1                      # Same as _print at this point.
 443&nbsp;echo
 444&nbsp;
 445&nbsp;funcVar=$(_print )                  # Contains result of function.
 446&nbsp;$funcVar                            # No input, No output.
 447&nbsp;$funcVar $VarSomething              # The predictable result.
 448&nbsp;echo
 449&nbsp;
 450&nbsp;funcVar=$(_print $VarSomething)     #  $VarSomething replaced HERE.
 451&nbsp;$funcVar                            #  The expansion is part of the
 452&nbsp;echo                                #+ variable contents.
 453&nbsp;
 454&nbsp;funcVar="$(_print $VarSomething)"   #  $VarSomething replaced HERE.
 455&nbsp;$funcVar                            #  The expansion is part of the
 456&nbsp;echo                                #+ variable contents.
 457&nbsp;
 458&nbsp;#  The difference between the unquoted and the double-quoted versions
 459&nbsp;#+ above can be seen in the "protect_literal.sh" example.
 460&nbsp;#  The first case above is processed as two, unquoted, Bash-Words.
 461&nbsp;#  The second case above is processed as one, quoted, Bash-Word.
 462&nbsp;
 463&nbsp;
 464&nbsp;
 465&nbsp;
 466&nbsp;# Delayed replacement
 467&nbsp;# -------------------
 468&nbsp;
 469&nbsp;echo
 470&nbsp;echo '- - Delayed replacement - -'
 471&nbsp;funcVar="$(_print '$VarSomething')" # No replacement, single Bash-Word.
 472&nbsp;eval $funcVar                       # $VarSomething replaced HERE.
 473&nbsp;echo
 474&nbsp;
 475&nbsp;VarSomething='NewThing'
 476&nbsp;eval $funcVar                       # $VarSomething replaced HERE.
 477&nbsp;echo
 478&nbsp;
 479&nbsp;# Restore the original setting trashed above.
 480&nbsp;VarSomething=Literal
 481&nbsp;
 482&nbsp;#  There are a pair of functions demonstrated in the
 483&nbsp;#+ "protect_literal.sh" and "unprotect_literal.sh" examples.
 484&nbsp;#  These are general purpose functions for delayed replacement literals
 485&nbsp;#+ containing variables.
 486&nbsp;
 487&nbsp;
 488&nbsp;
 489&nbsp;
 490&nbsp;
 491&nbsp;# REVIEW:
 492&nbsp;# ------
 493&nbsp;
 494&nbsp;#  A string can be considered a Classic-Array of elements (characters).
 495&nbsp;#  A string operation applies to all elements (characters) of the string
 496&nbsp;#+ (in concept, anyway).
 497&nbsp;###
 498&nbsp;#  The notation: ${array_name[@]} represents all elements of the
 499&nbsp;#+ Bash-Array: array_name.
 500&nbsp;###
 501&nbsp;#  The Extended-Syntax string operations can be applied to all
 502&nbsp;#+ elements of an array.
 503&nbsp;###
 504&nbsp;#  This may be thought of as a For-Each operation on a vector of strings.
 505&nbsp;###
 506&nbsp;#  Parameters are similar to an array.
 507&nbsp;#  The initialization of a parameter array for a script
 508&nbsp;#+ and a parameter array for a function only differ
 509&nbsp;#+ in the initialization of ${0}, which never changes its setting.
 510&nbsp;###
 511&nbsp;#  Subscript zero of the script's parameter array contains
 512&nbsp;#+ the name of the script.
 513&nbsp;###
 514&nbsp;#  Subscript zero of a function's parameter array DOES NOT contain
 515&nbsp;#+ the name of the function.
 516&nbsp;#  The name of the current function is accessed by the $FUNCNAME variable.
 517&nbsp;###
 518&nbsp;#  A quick, review list follows (quick, not short).
 519&nbsp;
 520&nbsp;echo
 521&nbsp;echo '- - Test (but not change) - -'
 522&nbsp;echo '- null reference -'
 523&nbsp;echo -n ${VarNull-'NotSet'}' '          # NotSet
 524&nbsp;echo ${VarNull}                         # NewLine only
 525&nbsp;echo -n ${VarNull:-'NotSet'}' '         # NotSet
 526&nbsp;echo ${VarNull}                         # Newline only
 527&nbsp;
 528&nbsp;echo '- null contents -'
 529&nbsp;echo -n ${VarEmpty-'Empty'}' '          # Only the space
 530&nbsp;echo ${VarEmpty}                        # Newline only
 531&nbsp;echo -n ${VarEmpty:-'Empty'}' '         # Empty
 532&nbsp;echo ${VarEmpty}                        # Newline only
 533&nbsp;
 534&nbsp;echo '- contents -'
 535&nbsp;echo ${VarSomething-'Content'}          # Literal
 536&nbsp;echo ${VarSomething:-'Content'}         # Literal
 537&nbsp;
 538&nbsp;echo '- Sparse Array -'
 539&nbsp;echo ${ArrayVar[@]-'not set'}
 540&nbsp;
 541&nbsp;# ASCII-Art time
 542&nbsp;# State     Y==yes, N==no
 543&nbsp;#           -       :-
 544&nbsp;# Unset     Y       Y       ${# ... } == 0
 545&nbsp;# Empty     N       Y       ${# ... } == 0
 546&nbsp;# Contents  N       N       ${# ... } &#62; 0
 547&nbsp;
 548&nbsp;#  Either the first and/or the second part of the tests
 549&nbsp;#+ may be a command or a function invocation string.
 550&nbsp;echo
 551&nbsp;echo '- - Test 1 for undefined - -'
 552&nbsp;declare -i t
 553&nbsp;_decT() {
 554&nbsp;    t=$t-1
 555&nbsp;}
 556&nbsp;
 557&nbsp;# Null reference, set: t == -1
 558&nbsp;t=${#VarNull}                           # Results in zero.
 559&nbsp;${VarNull- _decT }                      # Function executes, t now -1.
 560&nbsp;echo $t
 561&nbsp;
 562&nbsp;# Null contents, set: t == 0
 563&nbsp;t=${#VarEmpty}                          # Results in zero.
 564&nbsp;${VarEmpty- _decT }                     # _decT function NOT executed.
 565&nbsp;echo $t
 566&nbsp;
 567&nbsp;# Contents, set: t == number of non-null characters
 568&nbsp;VarSomething='_simple'                  # Set to valid function name.
 569&nbsp;t=${#VarSomething}                      # non-zero length
 570&nbsp;${VarSomething- _decT }                 # Function _simple executed.
 571&nbsp;echo $t                                 # Note the Append-To action.
 572&nbsp;
 573&nbsp;# Exercise: clean up that example.
 574&nbsp;unset t
 575&nbsp;unset _decT
 576&nbsp;VarSomething=Literal
 577&nbsp;
 578&nbsp;echo
 579&nbsp;echo '- - Test and Change - -'
 580&nbsp;echo '- Assignment if null reference -'
 581&nbsp;echo -n ${VarNull='NotSet'}' '          # NotSet NotSet
 582&nbsp;echo ${VarNull}
 583&nbsp;unset VarNull
 584&nbsp;
 585&nbsp;echo '- Assignment if null reference -'
 586&nbsp;echo -n ${VarNull:='NotSet'}' '         # NotSet NotSet
 587&nbsp;echo ${VarNull}
 588&nbsp;unset VarNull
 589&nbsp;
 590&nbsp;echo '- No assignment if null contents -'
 591&nbsp;echo -n ${VarEmpty='Empty'}' '          # Space only
 592&nbsp;echo ${VarEmpty}
 593&nbsp;VarEmpty=''
 594&nbsp;
 595&nbsp;echo '- Assignment if null contents -'
 596&nbsp;echo -n ${VarEmpty:='Empty'}' '         # Empty Empty
 597&nbsp;echo ${VarEmpty}
 598&nbsp;VarEmpty=''
 599&nbsp;
 600&nbsp;echo '- No change if already has contents -'
 601&nbsp;echo ${VarSomething='Content'}          # Literal
 602&nbsp;echo ${VarSomething:='Content'}         # Literal
 603&nbsp;
 604&nbsp;
 605&nbsp;# "Subscript sparse" Bash-Arrays
 606&nbsp;###
 607&nbsp;#  Bash-Arrays are subscript packed, beginning with
 608&nbsp;#+ subscript zero unless otherwise specified.
 609&nbsp;###
 610&nbsp;#  The initialization of ArrayVar was one way
 611&nbsp;#+ to "otherwise specify".  Here is the other way:
 612&nbsp;###
 613&nbsp;echo
 614&nbsp;declare -a ArraySparse
 615&nbsp;ArraySparse=( [1]=one [2]='' [4]='four' )
 616&nbsp;# [0]=null reference, [2]=null content, [3]=null reference
 617&nbsp;
 618&nbsp;echo '- - Array-Sparse List - -'
 619&nbsp;# Within double-quotes, default IFS, Glob-Pattern
 620&nbsp;
 621&nbsp;IFS=$'\x20'$'\x09'$'\x0A'
 622&nbsp;printf %q "${ArraySparse[*]}"
 623&nbsp;echo
 624&nbsp;
 625&nbsp;#  Note that the output does not distinguish between "null content"
 626&nbsp;#+ and "null reference".
 627&nbsp;#  Both print as escaped whitespace.
 628&nbsp;###
 629&nbsp;#  Note also that the output does NOT contain escaped whitespace
 630&nbsp;#+ for the "null reference(s)" prior to the first defined element.
 631&nbsp;###
 632&nbsp;# This behavior of 2.04, 2.05a and 2.05b has been reported
 633&nbsp;#+ and may change in a future version of Bash.
 634&nbsp;
 635&nbsp;#  To output a sparse array and maintain the [subscript]=value
 636&nbsp;#+ relationship without change requires a bit of programming.
 637&nbsp;#  One possible code fragment:
 638&nbsp;###
 639&nbsp;# local l=${#ArraySparse[@]}        # Count of defined elements
 640&nbsp;# local f=0                         # Count of found subscripts
 641&nbsp;# local i=0                         # Subscript to test
 642&nbsp;(                                   # Anonymous in-line function
 643&nbsp;    for (( l=${#ArraySparse[@]}, f = 0, i = 0 ; f &#60; l ; i++ ))
 644&nbsp;    do
 645&nbsp;        # 'if defined then...'
 646&nbsp;        ${ArraySparse[$i]+ eval echo '\ ['$i']='${ArraySparse[$i]} ; (( f++ )) }
 647&nbsp;    done
 648&nbsp;)
 649&nbsp;
 650&nbsp;# The reader coming upon the above code fragment cold
 651&nbsp;#+ might want to review "command lists" and "multiple commands on a line"
 652&nbsp;#+ in the text of the foregoing "Advanced Bash Scripting Guide."
 653&nbsp;###
 654&nbsp;#  Note:
 655&nbsp;#  The "read -a array_name" version of the "read" command
 656&nbsp;#+ begins filling array_name at subscript zero.
 657&nbsp;#  ArraySparse does not define a value at subscript zero.
 658&nbsp;###
 659&nbsp;#  The user needing to read/write a sparse array to either
 660&nbsp;#+ external storage or a communications socket must invent
 661&nbsp;#+ a read/write code pair suitable for their purpose.
 662&nbsp;###
 663&nbsp;# Exercise: clean it up.
 664&nbsp;
 665&nbsp;unset ArraySparse
 666&nbsp;
 667&nbsp;echo
 668&nbsp;echo '- - Conditional alternate (But not change)- -'
 669&nbsp;echo '- No alternate if null reference -'
 670&nbsp;echo -n ${VarNull+'NotSet'}' '
 671&nbsp;echo ${VarNull}
 672&nbsp;unset VarNull
 673&nbsp;
 674&nbsp;echo '- No alternate if null reference -'
 675&nbsp;echo -n ${VarNull:+'NotSet'}' '
 676&nbsp;echo ${VarNull}
 677&nbsp;unset VarNull
 678&nbsp;
 679&nbsp;echo '- Alternate if null contents -'
 680&nbsp;echo -n ${VarEmpty+'Empty'}' '              # Empty
 681&nbsp;echo ${VarEmpty}
 682&nbsp;VarEmpty=''
 683&nbsp;
 684&nbsp;echo '- No alternate if null contents -'
 685&nbsp;echo -n ${VarEmpty:+'Empty'}' '             # Space only
 686&nbsp;echo ${VarEmpty}
 687&nbsp;VarEmpty=''
 688&nbsp;
 689&nbsp;echo '- Alternate if already has contents -'
 690&nbsp;
 691&nbsp;# Alternate literal
 692&nbsp;echo -n ${VarSomething+'Content'}' '        # Content Literal
 693&nbsp;echo ${VarSomething}
 694&nbsp;
 695&nbsp;# Invoke function
 696&nbsp;echo -n ${VarSomething:+ $(_simple) }' '    # SimpleFunc Literal
 697&nbsp;echo ${VarSomething}
 698&nbsp;echo
 699&nbsp;
 700&nbsp;echo '- - Sparse Array - -'
 701&nbsp;echo ${ArrayVar[@]+'Empty'}                 # An array of 'Empty'(ies)
 702&nbsp;echo
 703&nbsp;
 704&nbsp;echo '- - Test 2 for undefined - -'
 705&nbsp;
 706&nbsp;declare -i t
 707&nbsp;_incT() {
 708&nbsp;    t=$t+1
 709&nbsp;}
 710&nbsp;
 711&nbsp;#  Note:
 712&nbsp;#  This is the same test used in the sparse array
 713&nbsp;#+ listing code fragment.
 714&nbsp;
 715&nbsp;# Null reference, set: t == -1
 716&nbsp;t=${#VarNull}-1                     # Results in minus-one.
 717&nbsp;${VarNull+ _incT }                  # Does not execute.
 718&nbsp;echo $t' Null reference'
 719&nbsp;
 720&nbsp;# Null contents, set: t == 0
 721&nbsp;t=${#VarEmpty}-1                    # Results in minus-one.
 722&nbsp;${VarEmpty+ _incT }                 # Executes.
 723&nbsp;echo $t'  Null content'
 724&nbsp;
 725&nbsp;# Contents, set: t == (number of non-null characters)
 726&nbsp;t=${#VarSomething}-1                # non-null length minus-one
 727&nbsp;${VarSomething+ _incT }             # Executes.
 728&nbsp;echo $t'  Contents'
 729&nbsp;
 730&nbsp;# Exercise: clean up that example.
 731&nbsp;unset t
 732&nbsp;unset _incT
 733&nbsp;
 734&nbsp;# ${name?err_msg} ${name:?err_msg}
 735&nbsp;#  These follow the same rules but always exit afterwards
 736&nbsp;#+ if an action is specified following the question mark.
 737&nbsp;#  The action following the question mark may be a literal
 738&nbsp;#+ or a function result.
 739&nbsp;###
 740&nbsp;#  ${name?} ${name:?} are test-only, the return can be tested.
 741&nbsp;
 742&nbsp;
 743&nbsp;
 744&nbsp;
 745&nbsp;# Element operations
 746&nbsp;# ------------------
 747&nbsp;
 748&nbsp;echo
 749&nbsp;echo '- - Trailing sub-element selection - -'
 750&nbsp;
 751&nbsp;#  Strings, Arrays and Positional parameters
 752&nbsp;
 753&nbsp;#  Call this script with multiple arguments
 754&nbsp;#+ to see the parameter selections.
 755&nbsp;
 756&nbsp;echo '- All -'
 757&nbsp;echo ${VarSomething:0}              # all non-null characters
 758&nbsp;echo ${ArrayVar[@]:0}               # all elements with content
 759&nbsp;echo ${@:0}                         # all parameters with content;
 760&nbsp;                                    # ignoring parameter[0]
 761&nbsp;
 762&nbsp;echo
 763&nbsp;echo '- All after -'
 764&nbsp;echo ${VarSomething:1}              # all non-null after character[0]
 765&nbsp;echo ${ArrayVar[@]:1}               # all after element[0] with content
 766&nbsp;echo ${@:2}                         # all after param[1] with content
 767&nbsp;
 768&nbsp;echo
 769&nbsp;echo '- Range after -'
 770&nbsp;echo ${VarSomething:4:3}            # ral
 771&nbsp;                                    # Three characters after
 772&nbsp;                                    # character[3]
 773&nbsp;
 774&nbsp;echo '- Sparse array gotch -'
 775&nbsp;echo ${ArrayVar[@]:1:2}     #  four - The only element with content.
 776&nbsp;                            #  Two elements after (if that many exist).
 777&nbsp;                            #  the FIRST WITH CONTENTS
 778&nbsp;                            #+ (the FIRST WITH  CONTENTS is being
 779&nbsp;                            #+ considered as if it
 780&nbsp;                            #+ were subscript zero).
 781&nbsp;#  Executed as if Bash considers ONLY array elements with CONTENT
 782&nbsp;#  printf %q "${ArrayVar[@]:0:3}"    # Try this one
 783&nbsp;
 784&nbsp;#  In versions 2.04, 2.05a and 2.05b,
 785&nbsp;#+ Bash does not handle sparse arrays as expected using this notation.
 786&nbsp;#
 787&nbsp;#  The current Bash maintainer, Chet Ramey, has corrected this
 788&nbsp;#+ for an upcoming version of Bash.
 789&nbsp;
 790&nbsp;
 791&nbsp;echo '- Non-sparse array -'
 792&nbsp;echo ${@:2:2}               # Two parameters following parameter[1]
 793&nbsp;
 794&nbsp;# New victims for string vector examples:
 795&nbsp;stringZ=abcABC123ABCabc
 796&nbsp;arrayZ=( abcabc ABCABC 123123 ABCABC abcabc )
 797&nbsp;sparseZ=( [1]='abcabc' [3]='ABCABC' [4]='' [5]='123123' )
 798&nbsp;
 799&nbsp;echo
 800&nbsp;echo ' - - Victim string - -'$stringZ'- - '
 801&nbsp;echo ' - - Victim array - -'${arrayZ[@]}'- - '
 802&nbsp;echo ' - - Sparse array - -'${sparseZ[@]}'- - '
 803&nbsp;echo ' - [0]==null ref, [2]==null ref, [4]==null content - '
 804&nbsp;echo ' - [1]=abcabc [3]=ABCABC [5]=123123 - '
 805&nbsp;echo ' - non-null-reference count: '${#sparseZ[@]}' elements'
 806&nbsp;
 807&nbsp;echo
 808&nbsp;echo '- - Prefix sub-element removal - -'
 809&nbsp;echo '- - Glob-Pattern match must include the first character. - -'
 810&nbsp;echo '- - Glob-Pattern may be a literal or a function result. - -'
 811&nbsp;echo
 812&nbsp;
 813&nbsp;
 814&nbsp;# Function returning a simple, Literal, Glob-Pattern
 815&nbsp;_abc() {
 816&nbsp;    echo -n 'abc'
 817&nbsp;}
 818&nbsp;
 819&nbsp;echo '- Shortest prefix -'
 820&nbsp;echo ${stringZ#123}                 # Unchanged (not a prefix).
 821&nbsp;echo ${stringZ#$(_abc)}             # ABC123ABCabc
 822&nbsp;echo ${arrayZ[@]#abc}               # Applied to each element.
 823&nbsp;
 824&nbsp;# Fixed by Chet Ramey for an upcoming version of Bash.
 825&nbsp;# echo ${sparseZ[@]#abc}            # Version-2.05b core dumps.
 826&nbsp;
 827&nbsp;# The -it would be nice- First-Subscript-Of
 828&nbsp;# echo ${#sparseZ[@]#*}             # This is NOT valid Bash.
 829&nbsp;
 830&nbsp;echo
 831&nbsp;echo '- Longest prefix -'
 832&nbsp;echo ${stringZ##1*3}                # Unchanged (not a prefix)
 833&nbsp;echo ${stringZ##a*C}                # abc
 834&nbsp;echo ${arrayZ[@]##a*c}              # ABCABC 123123 ABCABC
 835&nbsp;
 836&nbsp;# Fixed by Chet Ramey for an upcoming version of Bash
 837&nbsp;# echo ${sparseZ[@]##a*c}           # Version-2.05b core dumps.
 838&nbsp;
 839&nbsp;echo
 840&nbsp;echo '- - Suffix sub-element removal - -'
 841&nbsp;echo '- - Glob-Pattern match must include the last character. - -'
 842&nbsp;echo '- - Glob-Pattern may be a literal or a function result. - -'
 843&nbsp;echo
 844&nbsp;echo '- Shortest suffix -'
 845&nbsp;echo ${stringZ%1*3}                 # Unchanged (not a suffix).
 846&nbsp;echo ${stringZ%$(_abc)}             # abcABC123ABC
 847&nbsp;echo ${arrayZ[@]%abc}               # Applied to each element.
 848&nbsp;
 849&nbsp;# Fixed by Chet Ramey for an upcoming version of Bash.
 850&nbsp;# echo ${sparseZ[@]%abc}            # Version-2.05b core dumps.
 851&nbsp;
 852&nbsp;# The -it would be nice- Last-Subscript-Of
 853&nbsp;# echo ${#sparseZ[@]%*}             # This is NOT valid Bash.
 854&nbsp;
 855&nbsp;echo
 856&nbsp;echo '- Longest suffix -'
 857&nbsp;echo ${stringZ%%1*3}                # Unchanged (not a suffix)
 858&nbsp;echo ${stringZ%%b*c}                # a
 859&nbsp;echo ${arrayZ[@]%%b*c}              # a ABCABC 123123 ABCABC a
 860&nbsp;
 861&nbsp;# Fixed by Chet Ramey for an upcoming version of Bash.
 862&nbsp;# echo ${sparseZ[@]%%b*c}           # Version-2.05b core dumps.
 863&nbsp;
 864&nbsp;echo
 865&nbsp;echo '- - Sub-element replacement - -'
 866&nbsp;echo '- - Sub-element at any location in string. - -'
 867&nbsp;echo '- - First specification is a Glob-Pattern - -'
 868&nbsp;echo '- - Glob-Pattern may be a literal or Glob-Pattern function result. - -'
 869&nbsp;echo '- - Second specification may be a literal or function result. - -'
 870&nbsp;echo '- - Second specification may be unspecified. Pronounce that'
 871&nbsp;echo '    as: Replace-With-Nothing (Delete) - -'
 872&nbsp;echo
 873&nbsp;
 874&nbsp;
 875&nbsp;
 876&nbsp;# Function returning a simple, Literal, Glob-Pattern
 877&nbsp;_123() {
 878&nbsp;    echo -n '123'
 879&nbsp;}
 880&nbsp;
 881&nbsp;echo '- Replace first occurrence -'
 882&nbsp;echo ${stringZ/$(_123)/999}         # Changed (123 is a component).
 883&nbsp;echo ${stringZ/ABC/xyz}             # xyzABC123ABCabc
 884&nbsp;echo ${arrayZ[@]/ABC/xyz}           # Applied to each element.
 885&nbsp;echo ${sparseZ[@]/ABC/xyz}          # Works as expected.
 886&nbsp;
 887&nbsp;echo
 888&nbsp;echo '- Delete first occurrence -'
 889&nbsp;echo ${stringZ/$(_123)/}
 890&nbsp;echo ${stringZ/ABC/}
 891&nbsp;echo ${arrayZ[@]/ABC/}
 892&nbsp;echo ${sparseZ[@]/ABC/}
 893&nbsp;
 894&nbsp;#  The replacement need not be a literal,
 895&nbsp;#+ since the result of a function invocation is allowed.
 896&nbsp;#  This is general to all forms of replacement.
 897&nbsp;echo
 898&nbsp;echo '- Replace first occurrence with Result-Of -'
 899&nbsp;echo ${stringZ/$(_123)/$(_simple)}  # Works as expected.
 900&nbsp;echo ${arrayZ[@]/ca/$(_simple)}     # Applied to each element.
 901&nbsp;echo ${sparseZ[@]/ca/$(_simple)}    # Works as expected.
 902&nbsp;
 903&nbsp;echo
 904&nbsp;echo '- Replace all occurrences -'
 905&nbsp;echo ${stringZ//[b2]/X}             # X-out b's and 2's
 906&nbsp;echo ${stringZ//abc/xyz}            # xyzABC123ABCxyz
 907&nbsp;echo ${arrayZ[@]//abc/xyz}          # Applied to each element.
 908&nbsp;echo ${sparseZ[@]//abc/xyz}         # Works as expected.
 909&nbsp;
 910&nbsp;echo
 911&nbsp;echo '- Delete all occurrences -'
 912&nbsp;echo ${stringZ//[b2]/}
 913&nbsp;echo ${stringZ//abc/}
 914&nbsp;echo ${arrayZ[@]//abc/}
 915&nbsp;echo ${sparseZ[@]//abc/}
 916&nbsp;
 917&nbsp;echo
 918&nbsp;echo '- - Prefix sub-element replacement - -'
 919&nbsp;echo '- - Match must include the first character. - -'
 920&nbsp;echo
 921&nbsp;
 922&nbsp;echo '- Replace prefix occurrences -'
 923&nbsp;echo ${stringZ/#[b2]/X}             # Unchanged (neither is a prefix).
 924&nbsp;echo ${stringZ/#$(_abc)/XYZ}        # XYZABC123ABCabc
 925&nbsp;echo ${arrayZ[@]/#abc/XYZ}          # Applied to each element.
 926&nbsp;echo ${sparseZ[@]/#abc/XYZ}         # Works as expected.
 927&nbsp;
 928&nbsp;echo
 929&nbsp;echo '- Delete prefix occurrences -'
 930&nbsp;echo ${stringZ/#[b2]/}
 931&nbsp;echo ${stringZ/#$(_abc)/}
 932&nbsp;echo ${arrayZ[@]/#abc/}
 933&nbsp;echo ${sparseZ[@]/#abc/}
 934&nbsp;
 935&nbsp;echo
 936&nbsp;echo '- - Suffix sub-element replacement - -'
 937&nbsp;echo '- - Match must include the last character. - -'
 938&nbsp;echo
 939&nbsp;
 940&nbsp;echo '- Replace suffix occurrences -'
 941&nbsp;echo ${stringZ/%[b2]/X}             # Unchanged (neither is a suffix).
 942&nbsp;echo ${stringZ/%$(_abc)/XYZ}        # abcABC123ABCXYZ
 943&nbsp;echo ${arrayZ[@]/%abc/XYZ}          # Applied to each element.
 944&nbsp;echo ${sparseZ[@]/%abc/XYZ}         # Works as expected.
 945&nbsp;
 946&nbsp;echo
 947&nbsp;echo '- Delete suffix occurrences -'
 948&nbsp;echo ${stringZ/%[b2]/}
 949&nbsp;echo ${stringZ/%$(_abc)/}
 950&nbsp;echo ${arrayZ[@]/%abc/}
 951&nbsp;echo ${sparseZ[@]/%abc/}
 952&nbsp;
 953&nbsp;echo
 954&nbsp;echo '- - Special cases of null Glob-Pattern - -'
 955&nbsp;echo
 956&nbsp;
 957&nbsp;echo '- Prefix all -'
 958&nbsp;# null substring pattern means 'prefix'
 959&nbsp;echo ${stringZ/#/NEW}               # NEWabcABC123ABCabc
 960&nbsp;echo ${arrayZ[@]/#/NEW}             # Applied to each element.
 961&nbsp;echo ${sparseZ[@]/#/NEW}            # Applied to null-content also.
 962&nbsp;                                    # That seems reasonable.
 963&nbsp;
 964&nbsp;echo
 965&nbsp;echo '- Suffix all -'
 966&nbsp;# null substring pattern means 'suffix'
 967&nbsp;echo ${stringZ/%/NEW}               # abcABC123ABCabcNEW
 968&nbsp;echo ${arrayZ[@]/%/NEW}             # Applied to each element.
 969&nbsp;echo ${sparseZ[@]/%/NEW}            # Applied to null-content also.
 970&nbsp;                                    # That seems reasonable.
 971&nbsp;
 972&nbsp;echo
 973&nbsp;echo '- - Special case For-Each Glob-Pattern - -'
 974&nbsp;echo '- - - - This is a nice-to-have dream - - - -'
 975&nbsp;echo
 976&nbsp;
 977&nbsp;_GenFunc() {
 978&nbsp;    echo -n ${0}                    # Illustration only.
 979&nbsp;    # Actually, that would be an arbitrary computation.
 980&nbsp;}
 981&nbsp;
 982&nbsp;# All occurrences, matching the AnyThing pattern.
 983&nbsp;# Currently //*/ does not match null-content nor null-reference.
 984&nbsp;# /#/ and /%/ does match null-content but not null-reference.
 985&nbsp;echo ${sparseZ[@]//*/$(_GenFunc)}
 986&nbsp;
 987&nbsp;
 988&nbsp;#  A possible syntax would be to make
 989&nbsp;#+ the parameter notation used within this construct mean:
 990&nbsp;#   ${1} - The full element
 991&nbsp;#   ${2} - The prefix, if any, to the matched sub-element
 992&nbsp;#   ${3} - The matched sub-element
 993&nbsp;#   ${4} - The suffix, if any, to the matched sub-element
 994&nbsp;#
 995&nbsp;# echo ${sparseZ[@]//*/$(_GenFunc ${3})}   # Same as ${1} here.
 996&nbsp;# Perhaps it will be implemented in a future version of Bash.
 997&nbsp;
 998&nbsp;
 999&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="biblio.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="refcards.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Bibliography</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Reference Cards</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>