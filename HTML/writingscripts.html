<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Writing Scripts</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><LINK
REL="HOME"
TITLE="Advanced Bash-Scripting Guide"
HREF="index.html"><LINK
REL="UP"
TITLE="Exercises"
HREF="exercises.html"><LINK
REL="PREVIOUS"
TITLE="Exercises"
HREF="exercises.html"><LINK
REL="NEXT"
TITLE="Revision History"
HREF="revisionhistory.html"><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"><LINK
REL="stylesheet"
HREF="common/kde-common.css"
TYPE="text/css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=iso-8859-1"><META
HTTP-EQUIV="Content-Language"
CONTENT="en"><LINK
REL="stylesheet"
HREF="common/kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"><LINK
REL="stylesheet"
HREF="common/kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#AA0000"
VLINK="#AA0055"
ALINK="#AA0000"
STYLE="font-family: sans-serif;"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Advanced Bash-Scripting Guide: An in-depth exploration of the art of shell scripting</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="exercises.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Appendix M. Exercises</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="revisionhistory.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="WRITINGSCRIPTS"
></A
>M.2. Writing Scripts</H1
><P
><A
NAME="WRITINGSCRIPTS1"
></A
></P
><P
>Write a script to carry out each of the following tasks.</P
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="EXEASY1"
></A
>EASY</B
></P
><DL
><DT
><B
CLASS="COMMAND"
>Home Directory Listing</B
></DT
><DD
><P
>Perform a recursive directory listing on the user's home
	      directory and save the information to a file. Compress
	      the file, have the script prompt the user to insert
	      a floppy, then press <B
CLASS="KEYCAP"
>ENTER</B
>. Finally,
	      save the file to the floppy.</P
></DD
><DT
><B
CLASS="COMMAND"
>Self-reproducing Script</B
></DT
><DD
><P
>Write a script that backs itself up, that is, copies
	      itself to a file named <TT
CLASS="FILENAME"
>backup.sh</TT
>.</P
><P
>Hint: Use the <A
HREF="external.html#CATREF"
>cat</A
> command
	      and the <A
HREF="othertypesv.html#SCRNAMEPARAM"
>appropriate positional
	      parameter</A
>.</P
></DD
><DT
><B
CLASS="COMMAND"
>Converting  <A
HREF="loops.html#FORLOOPREF1"
>for</A
>
	    loops to <A
HREF="loops.html#WHILELOOPREF"
>while</A
> and <A
HREF="loops.html#UNTILLOOPREF"
>until</A
> loops</B
></DT
><DD
><P
>Convert the <I
CLASS="FIRSTTERM"
>for loops</I
> in <A
HREF="loops.html#EX22"
>Example 10-1</A
> to <I
CLASS="FIRSTTERM"
>while
	      loops</I
>. Hint: store the data in an <A
HREF="arrays.html#ARRAYREF"
>array</A
> and step through the array
	      elements.</P
><P
>Having already done the <SPAN
CLASS="QUOTE"
>"heavy lifting"</SPAN
>,
	      now convert the loops in the example to <I
CLASS="FIRSTTERM"
> until
	      loops</I
>.</P
></DD
><DT
><B
CLASS="COMMAND"
>Changing the line spacing of a text file</B
></DT
><DD
><P
>Write a script that reads each line of a target file, then
	      writes the line back to <TT
CLASS="FILENAME"
>stdout</TT
>, but with
	      an extra blank line following. This has the effect of
	      <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>double-spacing</I
></SPAN
> the file.</P
><P
>Include all necessary code to check whether the script
	      gets the necessary command line argument (a filename),
	      and whether the specified file exists.</P
><P
>When the script runs correctly, modify it to
	      <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>triple-space</I
></SPAN
> the target file.</P
><P
>Finally, write a script to remove all blank lines from
	      the target file, <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>single-spacing</I
></SPAN
> it.</P
></DD
><DT
><B
CLASS="COMMAND"
>Backwards Listing</B
></DT
><DD
><P
>Write a script that echoes itself to
	      <TT
CLASS="FILENAME"
>stdout</TT
>, but
	      <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>backwards</I
></SPAN
>.</P
></DD
><DT
><B
CLASS="COMMAND"
>Automatically Decompressing Files</B
></DT
><DD
><P
>Given a list of filenames as input, this script
	      queries each target file (parsing the output of the
	      <A
HREF="filearchiv.html#FILEREF"
>file</A
> command) for
	      the type of compression used on it. Then the script
	      automatically invokes the appropriate decompression command
	      (<B
CLASS="COMMAND"
>gunzip</B
>, <B
CLASS="COMMAND"
>bunzip2</B
>,
	      <B
CLASS="COMMAND"
>unzip</B
>, <B
CLASS="COMMAND"
>uncompress</B
>,
	      or whatever). If a target file is not compressed, the
	      script emits a warning message, but takes no other action
	      on that particular file.</P
></DD
><DT
><B
CLASS="COMMAND"
>Unique System ID</B
></DT
><DD
><P
>Generate a <SPAN
CLASS="QUOTE"
>"unique"</SPAN
> 6-digit hexadecimal
	      identifier for your computer. Do <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
>
	      use the flawed <A
HREF="system.html#HOSTIDREF"
>hostid</A
>
	      command. Hint: <B
CLASS="COMMAND"
><A
HREF="filearchiv.html#MD5SUMREF"
>md5sum</A
>
	      <TT
CLASS="FILENAME"
>/etc/passwd</TT
></B
>, then select
	      the first 6 digits of output.</P
></DD
><DT
><B
CLASS="COMMAND"
>Backup</B
></DT
><DD
><P
>Archive as a <SPAN
CLASS="QUOTE"
>"tarball"</SPAN
>
	      (<TT
CLASS="FILENAME"
>*.tar.gz</TT
> file) all the files
	      in your home directory tree
	      (<TT
CLASS="FILENAME"
>/home/your-name</TT
>) that have
	      been modified in the last 24 hours. Hint: use <A
HREF="moreadv.html#FINDREF"
>find</A
>.</P
></DD
><DT
><B
CLASS="COMMAND"
>Checking whether a process is still running</B
></DT
><DD
><P
>Given a <A
HREF="special-chars.html#PROCESSIDREF"
>process ID</A
>
	      (<I
CLASS="FIRSTTERM"
>PID</I
>) as an argument, this script
	      will check, at user-specified intervals, whether
	      the given process is still running. You may use
	      the <A
HREF="system.html#PPSSREF"
>ps</A
> and <A
HREF="timedate.html#SLEEPREF"
>sleep</A
> commands.</P
></DD
><DT
><B
CLASS="COMMAND"
>Primes</B
></DT
><DD
><P
>Print (to stdout) all prime numbers between 60000 and
	      63000. The output should be nicely formatted in columns
	      (hint: use <A
HREF="internal.html#PRINTFREF"
>printf</A
>).</P
></DD
><DT
><B
CLASS="COMMAND"
>Lottery Numbers</B
></DT
><DD
><P
>One type of lottery involves picking five
	      different numbers, in the range of 1 - 50. Write a
	      script that generates five pseudorandom numbers in this
	      range, <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>with no duplicates</I
></SPAN
>. The
	      script will give the option of echoing the numbers to
	      <TT
CLASS="FILENAME"
>stdout</TT
> or saving them to a file,
	      along with the date and time the particular number set
	      was generated.</P
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="EXMEDIUM1"
></A
>INTERMEDIATE</B
></P
><DL
><DT
><B
CLASS="COMMAND"
>Integer or String</B
></DT
><DD
><P
>Write a script <A
HREF="functions.html#FUNCTIONREF"
>function</A
>
	      that determines if an argument passed to it is an integer
	      or a string. The function will return TRUE (0) if
	      passed an integer, and FALSE (1) if passed a string.</P
><P
>Hint: What does the following expression return
	      when <TT
CLASS="VARNAME"
>$1</TT
> is <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
>
	      an integer?</P
><P
><TT
CLASS="VARNAME"
>expr $1 + 0</TT
></P
></DD
><DT
><B
CLASS="COMMAND"
>Managing Disk Space</B
></DT
><DD
><P
>List, one at a time, all files larger than 100K in
	      the <TT
CLASS="FILENAME"
>/home/username</TT
>
	      directory tree. Give the user the option to delete or
	      compress the file, then proceed to show the next one. Write
	      to a logfile the names of all deleted files and the
	      deletion times.</P
></DD
><DT
><B
CLASS="COMMAND"
>Removing Inactive Accounts</B
></DT
><DD
><P
>Inactive accounts on a network waste disk space and may
	      become a security risk. Write an administrative script
	      (to be invoked by <I
CLASS="FIRSTTERM"
>root</I
> or the <A
HREF="system.html#CRONREF"
>cron daemon</A
>) that checks
	      for and deletes user accounts that have not been accessed
	      within the last 90 days.</P
></DD
><DT
><B
CLASS="COMMAND"
>Enforcing Disk Quotas</B
></DT
><DD
><P
>Write a script for a multi-user system that checks users'
	      disk usage. If a user surpasses the preset limit
	      (100 MB, for example) in her <TT
CLASS="FILENAME"
>/home/username</TT
> directory,
	      then the script will automatically send her a warning
	      e-mail.</P
><P
>The script will use the <A
HREF="system.html#DUREF"
>du</A
> and
	      <A
HREF="communications.html#COMMMAIL1"
>mail</A
> commands. As an option,
	      it will allow setting and enforcing quotas using the <A
HREF="system.html#QUOTAREF"
>quota</A
> and <A
HREF="system.html#SETQUOTAREF"
>setquota</A
> commands.</P
></DD
><DT
><B
CLASS="COMMAND"
>Logged in User Information</B
></DT
><DD
><P
>For all logged in users, show their real names and the time
              and date of their last login.</P
><P
>Hint: use <A
HREF="system.html#WHOREF"
>who</A
>,
	      <A
HREF="system.html#LASTLOGREF"
>lastlog</A
>,
	      and parse <TT
CLASS="FILENAME"
>/etc/passwd</TT
>.</P
></DD
><DT
><B
CLASS="COMMAND"
>Safe Delete</B
></DT
><DD
><P
>Implement, as a script, a <SPAN
CLASS="QUOTE"
>"safe"</SPAN
> delete
	      command, <TT
CLASS="FILENAME"
>sdel.sh</TT
>. Filenames passed as
	      command-line arguments to this script are not deleted,
	      but instead <A
HREF="filearchiv.html#GZIPREF"
>gzipped</A
>
	      if not already compressed (use <A
HREF="filearchiv.html#FILEREF"
>file</A
> to check), then moved
	      to a <TT
CLASS="FILENAME"
>~/TRASH</TT
>
	      directory. Upon invocation, the script checks the <TT
CLASS="FILENAME"
>~/TRASH</TT
> directory for files
	      older than 48 hours and <A
HREF="external.html#RMREF"
>permanently
	      deletes</A
> them. (An better alternative might be to
	      have a second script handle this -- periodically invoked
	      by the <A
HREF="system.html#CRONREF"
>cron daemon</A
>.)</P
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Extra credit:</I
></SPAN
> Write the script
	      so it can handle files and directories <A
HREF="external.html#RMRECURS"
>recursively</A
>. This would give it
	      the capability of <SPAN
CLASS="QUOTE"
>"safely deleting"</SPAN
> entire
	      directory structures.</P
></DD
><DT
><B
CLASS="COMMAND"
>Making Change</B
></DT
><DD
><P
>What is the most efficient way to make change for $1.68,
	      using only coins in common circulations (up to 25c)? It's
	      6 quarters, 1 dime, a nickel, and three cents.</P
><P
>Given any arbitrary command line input in dollars and
	      cents ($*.??), calculate the change, using the minimum
	      number of coins. If your home country is not the United
	      States, you may use your local currency units instead. The
	      script will need to parse the command line input, then
	      change it to multiples of the smallest monetary unit (cents
	      or whatever). Hint: look at <A
HREF="functions.html#EX61"
>Example 23-8</A
>.</P
></DD
><DT
><B
CLASS="COMMAND"
>Quadratic Equations</B
></DT
><DD
><P
>Solve a <SPAN
CLASS="QUOTE"
>"quadratic"</SPAN
> equation of the form
	      <TT
CLASS="PARAMETER"
><I
>Ax^2 + Bx + C = 0</I
></TT
>. Have a script take
	      as arguments the coefficients, <TT
CLASS="USERINPUT"
><B
>A</B
></TT
>,
	      <TT
CLASS="USERINPUT"
><B
>B</B
></TT
>, and <TT
CLASS="USERINPUT"
><B
>C</B
></TT
>,
	      and return the solutions to four decimal places.</P
><P
>Hint: pipe the coefficients to <A
HREF="mathc.html#BCREF"
>bc</A
>, using the well-known formula,
	      <TT
CLASS="PARAMETER"
><I
>x = ( -B +/- sqrt( B^2 - 4AC ) ) / 2A</I
></TT
>.</P
></DD
><DT
><B
CLASS="COMMAND"
>Sum of Matching Numbers</B
></DT
><DD
><P
>Find the sum of all five-digit numbers (in the range
	      10000 - 99999) containing <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>exactly two</I
></SPAN
>
	      out of the following set of digits: { 4, 5, 6 }. These may
	      repeat within the same number, and if so, they count once
	      for each occurrence.</P
><P
>Some examples of matching numbers are
	      42057, 74638, and 89515.</P
></DD
><DT
><B
CLASS="COMMAND"
>Lucky Numbers</B
></DT
><DD
><P
>A "lucky number" is one whose individual digits add
	      up to 7, in successive additions. For example, 62431 is a
	      "lucky number" (6 + 2 + 4 + 3 + 1 = 16, 1 + 6 = 7). Find
	      all the "lucky numbers" between 1000 and 10000.</P
></DD
><DT
><B
CLASS="COMMAND"
>Alphabetizing a String</B
></DT
><DD
><P
>Alphabetize (in ASCII order) an arbitrary string
	      read from the command line.</P
></DD
><DT
><B
CLASS="COMMAND"
>Parsing</B
></DT
><DD
><P
>Parse <TT
CLASS="FILENAME"
>/etc/passwd</TT
>, and output
	      its contents in nice, easy-to-read tabular form.</P
></DD
><DT
><B
CLASS="COMMAND"
>Logging Logins</B
></DT
><DD
><P
>Parse <TT
CLASS="FILENAME"
>/var/log/messages</TT
> to
	      produce a nicely formatted file of user logins and login
	      times. The script may need to run as
	      <I
CLASS="FIRSTTERM"
>root</I
>. (Hint: Search for the string
	      <SPAN
CLASS="QUOTE"
>"LOGIN."</SPAN
>)</P
></DD
><DT
><B
CLASS="COMMAND"
>Pretty-Printing a Data File</B
></DT
><DD
><P
>Certain database and spreadsheet packages use save-files
	      with <I
CLASS="FIRSTTERM"
>comma-separated values</I
>
	      (CSVs). Other applications often need to parse these
	      files.</P
><P
>Given a data file with comma-separated fields,
	      of the form:
	        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;Jones,Bill,235 S. Williams St.,Denver,CO,80221,(303) 244-7989
   2&nbsp;Smith,Tom,404 Polk Ave.,Los Angeles,CA,90003,(213) 879-5612
   3&nbsp;...</PRE
></TD
></TR
></TABLE
>
	      Reformat the data and print it out to
	      <TT
CLASS="FILENAME"
>stdout</TT
> in labeled, evenly-spaced columns.</P
></DD
><DT
><B
CLASS="COMMAND"
>Justification</B
></DT
><DD
><P
>Given ASCII text input either from
	      <TT
CLASS="FILENAME"
>stdin</TT
> or a file, adjust
	      the word spacing to right-justify each line to a
	      user-specified line-width, then send the output to
	      <TT
CLASS="FILENAME"
>stdout</TT
>.</P
></DD
><DT
><B
CLASS="COMMAND"
>Mailing List</B
></DT
><DD
><P
>Using the <A
HREF="communications.html#COMMMAIL1"
>mail</A
> command,
	      write a script that manages a simple mailing list. The
	      script automatically e-mails the monthly company newsletter,
	      read from a specified text file, and sends it to all the
	      addresses on the mailing list, which the script reads from
	      another specified file.</P
></DD
><DT
><B
CLASS="COMMAND"
>Generating Passwords</B
></DT
><DD
><P
>Generate pseudorandom 8-character passwords, using
	      characters in the ranges [0-9], [A-Z], [a-z]. Each password
	      must contain at least two digits.</P
></DD
><DT
><B
CLASS="COMMAND"
>Monitoring a User</B
></DT
><DD
><P
>You suspect that one particular user on the network
	      has been abusing his privileges and possibly attempting to
	      hack the system. Write a script to automatically monitor
	      and log his activities when he's signed on. The log file
	      will save entries for the previous week, and delete those
	      entries more than seven days old.</P
><P
>You may use <A
HREF="system.html#LASTREF"
>last</A
>,
             <A
HREF="system.html#LASTLOGREF"
>lastlog</A
>, and <A
HREF="system.html#LASTCOMMREF"
>lastcomm</A
> to aid your
             surveillance of the suspected malefactor.</P
></DD
><DT
><B
CLASS="COMMAND"
>Checking for Broken Links</B
></DT
><DD
><P
>Using <A
HREF="communications.html#LYNXREF"
>lynx</A
> with the
	      <TT
CLASS="OPTION"
>-traversal</TT
> option, write a script that
	      checks a Web site for broken links.</P
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="EXDIFFICULT1"
></A
>DIFFICULT</B
></P
><DL
><DT
><B
CLASS="COMMAND"
>Testing Passwords</B
></DT
><DD
><P
>Write a script to check and validate passwords. The object
	      is to flag <SPAN
CLASS="QUOTE"
>"weak"</SPAN
> or easily guessed password
	      candidates.</P
><P
>A trial password will be input to the script as a
	       command line parameter. To be considered acceptable,
	       a password must meet the following minimum qualifications:

            <UL
><LI
><P
>Minimum length of 8 characters</P
></LI
><LI
><P
>Must contain at least one numeric character</P
></LI
><LI
><P
>Must contain at least one of the following
		  non-alphabetic characters: <SPAN
CLASS="TOKEN"
>@</SPAN
>,
		  <SPAN
CLASS="TOKEN"
>#</SPAN
>, <SPAN
CLASS="TOKEN"
>$</SPAN
>, <SPAN
CLASS="TOKEN"
>%</SPAN
>,
		  <SPAN
CLASS="TOKEN"
>&#38;</SPAN
>, <SPAN
CLASS="TOKEN"
>*</SPAN
>, <SPAN
CLASS="TOKEN"
>+</SPAN
>,
		  <SPAN
CLASS="TOKEN"
>-</SPAN
>, <SPAN
CLASS="TOKEN"
>=</SPAN
></P
></LI
></UL
></P
><P
>Optional:

            <UL
><LI
><P
>Do a dictionary check on every sequence of at least
		  four consecutive alphabetic characters in the password under
		  test. This will eliminate passwords containing embedded
		  <SPAN
CLASS="QUOTE"
>"words"</SPAN
> found in a standard dictionary.</P
></LI
><LI
><P
>Enable the script to check all the passwords on your
		  system. These may or may not reside in
		  <TT
CLASS="FILENAME"
>/etc/passwd</TT
>.</P
></LI
></UL
></P
><P
>This exercise tests mastery of <A
HREF="regexp.html#REGEXREF"
>Regular Expressions</A
>.</P
></DD
><DT
><B
CLASS="COMMAND"
>Cross Reference</B
></DT
><DD
><P
>Write a script that generates a
	      <I
CLASS="FIRSTTERM"
>cross-reference</I
>
	      (<I
CLASS="FIRSTTERM"
>concordance</I
>) on a target file.
	      The output will be a listing of all word occurrences in
	      the target file, along with the line numbers in which
	      each word occurs. Traditionally, <I
CLASS="FIRSTTERM"
>linked
	      list</I
> constructs would be used in such
	      applications. Therefore, you should investigate <A
HREF="arrays.html#ARRAYREF"
>arrays</A
> in the course of
	      this exercise. <A
HREF="textproc.html#WF"
>Example 15-12</A
> is probably
	      <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>not</I
></SPAN
> a good place to start.</P
></DD
><DT
><A
NAME="NEWTONSQRT"
></A
><B
CLASS="COMMAND"
>Square Root</B
></DT
><DD
><P
>Write a script to calculate square roots of numbers
              using <I
CLASS="FIRSTTERM"
>Newton's Method</I
>.</P
><P
>The algorithm for this, expressed as a snippet of Bash
              <A
HREF="assortedtips.html#PSEUDOCODEREF"
>pseudo-code</A
> is:</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#  (Isaac) Newton's Method for speedy extraction
   2&nbsp;#+ of square roots.
   3&nbsp;
   4&nbsp;guess = $argument
   5&nbsp;#  $argument is the number to find the square root of.
   6&nbsp;#  $guess is each successive calculated "guess" -- or trial solution --
   7&nbsp;#+ of the square root.
   8&nbsp;#  Our first "guess" at a square root is the argument itself.
   9&nbsp;
  10&nbsp;oldguess = 0
  11&nbsp;# $oldguess is the previous $guess.
  12&nbsp;
  13&nbsp;tolerance = .000001
  14&nbsp;# To how close a tolerance we wish to calculate.
  15&nbsp;
  16&nbsp;loopcnt = 0
  17&nbsp;# Let's keep track of how many times through the loop.
  18&nbsp;# Some arguments will require more loop iterations than others.
  19&nbsp;
  20&nbsp;
  21&nbsp;while [ ABS( $guess $oldguess ) -gt $tolerance ]
  22&nbsp;#       ^^^^^^^^^^^^^^^^^^^^^^^ Fix up syntax, of course.
  23&nbsp;
  24&nbsp;#      "ABS" is a (floating point) function to find the absolute value
  25&nbsp;#+      of the difference between the two terms.
  26&nbsp;#             So, as long as difference between current and previous
  27&nbsp;#+            trial solution (guess) exceeds the tolerance, keep looping.
  28&nbsp;
  29&nbsp;do
  30&nbsp;   oldguess = $guess  # Update $oldguess to previous $guess.
  31&nbsp;
  32&nbsp;#  =======================================================
  33&nbsp;   guess = ( $oldguess + ( $argument / $oldguess ) ) / 2.0
  34&nbsp;#        = 1/2 ( ($oldguess **2 + $argument) / $oldguess )
  35&nbsp;#  equivalent to:
  36&nbsp;#        = 1/2 ( $oldguess + $argument / $oldguess )
  37&nbsp;#  that is, "averaging out" the trial solution and
  38&nbsp;#+ the proportion of argument deviation
  39&nbsp;#+ (in effect, splitting the error in half).
  40&nbsp;#  This converges on an accurate solution
  41&nbsp;#+ with surprisingly few loop iterations . . .
  42&nbsp;#+ for arguments &#62; $tolerance, of course.
  43&nbsp;#  =======================================================
  44&nbsp;
  45&nbsp;   (( loopcnt++ ))     # Update loop counter.
  46&nbsp;done</PRE
></TD
></TR
></TABLE
></P
><P
>It's a simple enough recipe, and
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>seems</I
></SPAN
> at first glance easy enough to
              convert into a working Bash script. The problem, though,
              is that Bash has <A
HREF="operations.html#NOFLOATINGPOINT"
>no native
              support for floating point numbers</A
>. So, the script
              writer needs to use <A
HREF="mathc.html#BCREF"
>bc</A
> or
              possibly <A
HREF="awk.html#AWKREF"
>awk</A
> to convert the
              numbers and do the calculations. It may get rather messy
              . . .</P
></DD
><DT
><B
CLASS="COMMAND"
>Logging File Accesses</B
></DT
><DD
><P
>Log all accesses to the files in <TT
CLASS="FILENAME"
>/etc</TT
> during the course of
	      a single day. This information should include the filename,
	      user name, and access time. If any alterations to the
	      files take place, that should be flagged. Write this data
	      as neatly formatted records in a logfile.</P
></DD
><DT
><B
CLASS="COMMAND"
>Monitoring Processes</B
></DT
><DD
><P
>Write a script to continually monitor all running
	      processes and to keep track of how many child processes each
	      parent spawns. If a process spawns more than five children,
	      then the script sends an e-mail to the system administrator
	      (or <I
CLASS="FIRSTTERM"
>root</I
>) with all relevant
	      information, including the time, PID of the parent, PIDs
	      of the children, etc. The script appends a report to a log
	      file every ten minutes.  </P
></DD
><DT
><B
CLASS="COMMAND"
>Strip Comments</B
></DT
><DD
><P
>Strip all comments from a shell script whose name
	      is specified on the command line. Note that the <SPAN
CLASS="QUOTE"
>"#!
	      line"</SPAN
> must not be stripped out.</P
></DD
><DT
><B
CLASS="COMMAND"
>Strip HTML Tags</B
></DT
><DD
><P
>Strip all HTML tags from a specified HTML file, then
	      reformat it into lines between 60 and 75 characters
	      in length. Reset paragraph and block spacing, as
	      appropriate, and convert HTML tables to their approximate
	      text equivalent.</P
></DD
><DT
><B
CLASS="COMMAND"
>XML Conversion</B
></DT
><DD
><P
>Convert an XML file to both HTML and text format.</P
></DD
><DT
><A
NAME="CSPAMMERS"
></A
><B
CLASS="COMMAND"
>Chasing Spammers</B
></DT
><DD
><P
> Write a script that analyzes a spam e-mail by doing
	      DNS lookups on the IP addresses in the headers to identify
	      the relay hosts as well as the originating ISP. The
	      script will forward the unaltered spam message to the
	      responsible ISPs. Of course, it will be necessary to
	      filter out <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>your own ISP's IP address</I
></SPAN
>,
	      so you don't end up complaining about yourself.</P
><P
>As necessary, use the appropriate <A
HREF="communications.html#COMMUNINFO1"
>network analysis commands</A
>.</P
><P
>For some ideas, see <A
HREF="communications.html#ISSPAMMER"
>Example 15-40</A
> and <A
HREF="contributed-scripts.html#ISSPAMMER2"
>Example A-30</A
>.</P
><P
>Optional: Write a script that searches through a list of
	      e-mail messages and deletes the spam according to specified
	      filters.</P
></DD
><DT
><B
CLASS="COMMAND"
>Creating man pages</B
></DT
><DD
><P
>Write a script that automates the process of creating
	      <A
HREF="external.html#MANREF"
>man pages</A
>.</P
><P
>Given a text file which contains information to be
	      formatted into a <I
CLASS="FIRSTTERM"
>man page</I
>, the
	      script will read the file, then invoke the appropriate
	      <A
HREF="textproc.html#GROFFREF"
>groff</A
> commands to
	      output the corresponding <I
CLASS="FIRSTTERM"
>man page</I
>
	      to <TT
CLASS="FILENAME"
>stdout</TT
>. The text file contains
	      blocks of information under the standard <I
CLASS="FIRSTTERM"
>man
	      page</I
> headings, i.e., <SPAN
CLASS="QUOTE"
>"NAME,"</SPAN
>
	      <SPAN
CLASS="QUOTE"
>"SYNOPSIS,"</SPAN
> <SPAN
CLASS="QUOTE"
>"DESCRIPTION,"</SPAN
>
	      etc.</P
><P
>See <A
HREF="textproc.html#MANVIEW"
>Example 15-28</A
>.</P
></DD
><DT
><B
CLASS="COMMAND"
>Morse Code</B
></DT
><DD
><P
>Convert a text file to Morse code. Each character of the
	      text file will be represented as a corresponding Morse
	      code group of dots and dashes (underscores), separated by
	      whitespace from the next. For example:
		<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;Invoke the "morse.sh" script with "script"
   2&nbsp;as an argument to convert to Morse.
   3&nbsp;
   4&nbsp;
   5&nbsp;$ sh morse.sh script
   6&nbsp;
   7&nbsp;... _._. ._. .. .__. _
   8&nbsp;s   c    r   i   p   t</PRE
></TD
></TR
></TABLE
></P
></DD
><DT
><B
CLASS="COMMAND"
>Hex Dump</B
></DT
><DD
><P
>Do a hex(adecimal) dump on a binary file
	      specified as an argument. The output should be in neat
	      tabular fields, with the first field showing the address,
	      each of the next 8 fields a 4-byte hex number, and the final
	      field the ASCII equivalent of the previous 8 fields.</P
><P
>The obvious followup to this is to extend the hex dump
	      script into a disassembler. Using a lookup table, or some other
	      clever gimmick, convert the hex values into 80x86 op
	      codes.</P
></DD
><DT
><B
CLASS="COMMAND"
>Emulating a Shift Register</B
></DT
><DD
><P
>Using <A
HREF="arrays.html#STACKEX"
>Example 26-15</A
> as an inspiration,
	      write a script that emulates a 64-bit shift register as
	      an <A
HREF="arrays.html#ARRAYREF"
>array</A
>. Implement
	      functions to <I
CLASS="FIRSTTERM"
>load</I
> the register,
	      <I
CLASS="FIRSTTERM"
>shift left</I
>, <I
CLASS="FIRSTTERM"
>shift
	      right</I
>, and <I
CLASS="FIRSTTERM"
>rotate</I
>
	      it. Finally, write a function that interprets the register
	      contents as eight 8-bit ASCII characters.</P
></DD
><DT
><B
CLASS="COMMAND"
>Determinant</B
></DT
><DD
><P
>Solve a 4 x 4 determinant.</P
></DD
><DT
><B
CLASS="COMMAND"
>Hidden Words</B
></DT
><DD
><P
>Write a <SPAN
CLASS="QUOTE"
>"word-find"</SPAN
> puzzle generator,
	      a script that hides 10 input words in a 10 x 10 matrix
	      of random letters. The words may be hidden across, down,
	      or diagonally.</P
><P
>Optional: Write a script that <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>solves</I
></SPAN
>
	      word-find puzzles. To keep this from becoming too difficult,
	      the solution script will find only horizontal and vertical
	      words. (Hint: Treat each row and column as a string, and
	      search for substrings.)</P
></DD
><DT
><B
CLASS="COMMAND"
>Anagramming</B
></DT
><DD
><P
> Anagram 4-letter input. For example, the
	      anagrams of <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>word</I
></SPAN
> are:
	      <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>do or rod row word</I
></SPAN
>. You may use
	      <TT
CLASS="FILENAME"
>/usr/share/dict/linux.words</TT
> as the
	      reference list.</P
></DD
><DT
><B
CLASS="COMMAND"
>Word Ladders</B
></DT
><DD
><P
>A <SPAN
CLASS="QUOTE"
>"word ladder"</SPAN
> is a sequence of words,
              with each successive word in the sequence differing from
              the previous one by a single letter.</P
><P
>For example, to <SPAN
CLASS="QUOTE"
>"ladder"</SPAN
> from
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>mark</I
></SPAN
> to
              <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>vase</I
></SPAN
>:</P
><P
>	    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;mark --&#62; park --&#62; part --&#62; past --&#62; vast --&#62; vase
   2&nbsp;         ^           ^       ^      ^           ^</PRE
></TD
></TR
></TABLE
>
            </P
><P
>Write a script that solves word ladder puzzles. Given
	      a starting and an ending word, the script will list all
	      intermediate steps in the <SPAN
CLASS="QUOTE"
>"ladder."</SPAN
> Note
	      that <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>all</I
></SPAN
> words in the sequence must
	      be legitimate dictionary words.</P
></DD
><DT
><B
CLASS="COMMAND"
>Fog Index</B
></DT
><DD
><P
>The <SPAN
CLASS="QUOTE"
>"fog index"</SPAN
> of a passage of text
	      estimates its reading difficulty, as a number corresponding
	      roughly to a school grade level. For example, a passage
	      with a fog index of 12 should be comprehensible to anyone
	      with 12 years of schooling.</P
><P
>The Gunning version of the fog index uses the following
	      algorithm.</P
><OL
TYPE="1"
><LI
><P
>Choose a section of the text at least
                 100 words in length.</P
></LI
><LI
><P
>Count the number of sentences (a portion of
                 a sentence truncated by the boundary of the text section
                 counts as one).</P
></LI
><LI
><P
>Find the average number of words per
                   sentence.</P
><P
>AVE_WDS_SEN = TOTAL_WORDS / SENTENCES</P
></LI
><LI
><P
>Count the number of <SPAN
CLASS="QUOTE"
>"difficult"</SPAN
>
		   words in the segment -- those containing at least
		   3 syllables. Divide this quantity by total words to
		   get the proportion of difficult words.</P
><P
>PRO_DIFF_WORDS = LONG_WORDS / TOTAL_WORDS</P
></LI
><LI
><P
>The Gunning fog index is the sum of the above two
                   quantities, multiplied by 0.4, then rounded to the
                   nearest integer.</P
><P
>G_FOG_INDEX = int ( 0.4 * ( AVE_WDS_SEN  + PRO_DIFF_WORDS ) )</P
></LI
></OL
><P
>Step 4 is by far the most difficult portion of the
	      exercise. There exist various algorithms for estimating
	      the syllable count of a word. A rule-of-thumb formula
	      might consider the number of letters in a word and the
	      vowel-consonant mix.</P
><P
>A strict interpretation of the Gunning fog index does
	      not count compound words and proper nouns as
	      <SPAN
CLASS="QUOTE"
>"difficult"</SPAN
> words, but this would enormously
	      complicate the script.</P
></DD
><DT
><B
CLASS="COMMAND"
>Calculating PI using Buffon's Needle</B
></DT
><DD
><P
>The Eighteenth Century French mathematician de Buffon
	      came up with a novel experiment. Repeatedly drop a
	      needle of length <SPAN
CLASS="QUOTE"
>"n"</SPAN
> onto a wooden floor
	      composed of long and narrow parallel boards. The cracks
	      separating the equal-width floorboards are a fixed distance
	      <SPAN
CLASS="QUOTE"
>"d"</SPAN
> apart. Keep track of the total drops and
	      the number of times the needle intersects a crack on the
	      floor. The ratio of these two quantities turns out to be
	      a fractional multiple of PI.</P
><P
>In the spirit of <A
HREF="mathc.html#CANNON"
>Example 15-48</A
>, write a
	      script that runs a Monte Carlo simulation of Buffon's
	      Needle. To simplify matters, set the needle length
	      equal to the distance between the cracks, <TT
CLASS="PARAMETER"
><I
>n =
	      d</I
></TT
>.</P
><P
>Hint: there are actually two critical variables:
              the distance from the center of the needle to the crack
              nearest to it, and the angle of the needle to that
              crack. You may use <A
HREF="mathc.html#BCREF"
>bc</A
> to
              handle the calculations.</P
></DD
><DT
><B
CLASS="COMMAND"
>Playfair Cipher</B
></DT
><DD
><P
>Implement the Playfair (Wheatstone) Cipher in a
	      script.</P
><P
>The Playfair Cipher encrypts text by substitution
	      of <SPAN
CLASS="QUOTE"
>"digrams"</SPAN
> (2-letter groupings).  It is
	      traditional to use a 5 x 5 letter scrambled-alphabet
	      <I
CLASS="FIRSTTERM"
>key square</I
> for the encryption and
	      decryption.</P
><P
>	     <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;   C O D E S
   2&nbsp;   A B F G H
   3&nbsp;   I K L M N
   4&nbsp;   P Q R T U
   5&nbsp;   V W X Y Z
   6&nbsp;
   7&nbsp;Each letter of the alphabet appears once, except "I" also represents
   8&nbsp;"J". The arbitrarily chosen key word, "CODES" comes first, then all
   9&nbsp;the rest of the alphabet, in order from left to right, skipping letters
  10&nbsp;already used.
  11&nbsp;
  12&nbsp;To encrypt, separate the plaintext message into digrams (2-letter
  13&nbsp;groups). If a group has two identical letters, delete the second, and
  14&nbsp;form a new group. If there is a single letter left over at the end,
  15&nbsp;insert a "null" character, typically an "X."
  16&nbsp;
  17&nbsp;THIS IS A TOP SECRET MESSAGE
  18&nbsp;
  19&nbsp;TH IS IS AT OP SE CR ET ME SA GE
  20&nbsp;
  21&nbsp;For each digram, there are three possibilities.
  22&nbsp;----------------------------------------------
  23&nbsp;1) Both letters will be on the same row of the key square
  24&nbsp;   For each letter, substitute the one immediately to the right, in that
  25&nbsp;   row. If necessary, wrap around left to the beginning of the row.
  26&nbsp;
  27&nbsp;or
  28&nbsp;
  29&nbsp;2) Both letters will be in the same column of the key square
  30&nbsp;   For each letter, substitute the one immediately below it, in that
  31&nbsp;   row. If necessary, wrap around to the top of the column.
  32&nbsp;
  33&nbsp;or
  34&nbsp;
  35&nbsp;3) Both letters will form the corners of a rectangle within the key
  36&nbsp;   square. For each letter, substitute the one on the other corner the
  37&nbsp;   rectangle which lies on the same row.
  38&nbsp;
  39&nbsp;
  40&nbsp;The "TH" digram falls under case #3.
  41&nbsp;G H
  42&nbsp;M N
  43&nbsp;T U           (Rectangle with "T" and "H" at corners)
  44&nbsp;
  45&nbsp;T --&#62; U
  46&nbsp;H --&#62; G
  47&nbsp;
  48&nbsp;
  49&nbsp;The "SE" digram falls under case #1.
  50&nbsp;C O D E S     (Row containing "S" and "E")
  51&nbsp;
  52&nbsp;S --&#62; C  (wraps around left to beginning of row)
  53&nbsp;E --&#62; S
  54&nbsp;
  55&nbsp;=========================================================================
  56&nbsp;
  57&nbsp;To decrypt encrypted text, reverse the above procedure under cases #1
  58&nbsp;and #2 (move in opposite direction for substitution). Under case #3,
  59&nbsp;just take the remaining two corners of the rectangle.
  60&nbsp;
  61&nbsp;
  62&nbsp;Helen Fouche Gaines' classic work, ELEMENTARY CRYPTANALYSIS (1939), gives a
  63&nbsp;fairly detailed rundown on the Playfair Cipher and its solution methods.</PRE
></TD
></TR
></TABLE
>
             </P
><P
>This script will have three main sections</P
><OL
TYPE="I"
><LI
><P
>Generating the <SPAN
CLASS="QUOTE"
>"key square"</SPAN
>,
	         based on a user-input keyword.</P
></LI
><LI
><P
>Encrypting a <SPAN
CLASS="QUOTE"
>"plaintext"</SPAN
>
	         message.</P
></LI
><LI
><P
>Decrypting encrypted
	         text.</P
></LI
></OL
><P
>The script will make extensive use of <A
HREF="arrays.html#ARRAYREF"
>arrays</A
> and <A
HREF="functions.html#FUNCTIONREF"
>functions</A
>.</P
></DD
></DL
></DIV
><P
>--</P
><P
>Please do not send the author your solutions to these
            exercises. There are better ways to impress him with your
            cleverness, such as submitting bugfixes and suggestions for
            improving this book.</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="exercises.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="revisionhistory.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Exercises</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="exercises.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Revision History</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>